"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-equals";
exports.ids = ["vendor-chunks/fast-equals"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-equals/dist/fast-equals.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDeepEqual: () => (/* binding */ circularDeepEqual),\n/* harmony export */   circularShallowEqual: () => (/* binding */ circularShallowEqual),\n/* harmony export */   createCustomCircularEqual: () => (/* binding */ createCustomCircularEqual),\n/* harmony export */   createCustomEqual: () => (/* binding */ createCustomEqual),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   sameValueZeroEqual: () => (/* binding */ sameValueZeroEqual),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual)\n/* harmony export */ });\n/**\r\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\r\n * use inside the built comparator.\r\n */\r\nfunction createDefaultIsNestedEqual(comparator) {\r\n    return function isEqual(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {\r\n        return comparator(a, b, meta);\r\n    };\r\n}\r\n/**\r\n * Wrap the provided `areItemsEqual` method to manage the circular cache, allowing\r\n * for circular references to be safely included in the comparison without creating\r\n * stack overflows.\r\n */\r\nfunction createIsCircular(areItemsEqual) {\r\n    return function isCircular(a, b, isEqual, cache) {\r\n        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\r\n            return areItemsEqual(a, b, isEqual, cache);\r\n        }\r\n        var cachedA = cache.get(a);\r\n        var cachedB = cache.get(b);\r\n        if (cachedA && cachedB) {\r\n            return cachedA === b && cachedB === a;\r\n        }\r\n        cache.set(a, b);\r\n        cache.set(b, a);\r\n        var result = areItemsEqual(a, b, isEqual, cache);\r\n        cache.delete(a);\r\n        cache.delete(b);\r\n        return result;\r\n    };\r\n}\r\n/**\r\n * Targeted shallow merge of two objects.\r\n *\r\n * @NOTE\r\n * This exists as a tinier compiled version of the `__assign` helper that\r\n * `tsc` injects in case of `Object.assign` not being present.\r\n */\r\nfunction merge(a, b) {\r\n    var merged = {};\r\n    for (var key in a) {\r\n        merged[key] = a[key];\r\n    }\r\n    for (var key in b) {\r\n        merged[key] = b[key];\r\n    }\r\n    return merged;\r\n}\r\n/**\r\n * Whether the value is a plain object.\r\n *\r\n * @NOTE\r\n * This is a same-realm compariosn only.\r\n */\r\nfunction isPlainObject(value) {\r\n    return value.constructor === Object || value.constructor == null;\r\n}\r\n/**\r\n * When the value is `Promise`-like, aka \"then-able\".\r\n */\r\nfunction isPromiseLike(value) {\r\n    return typeof value.then === 'function';\r\n}\r\n/**\r\n * Whether the values passed are strictly equal or both NaN.\r\n */\r\nfunction sameValueZeroEqual(a, b) {\r\n    return a === b || (a !== a && b !== b);\r\n}\n\nvar ARGUMENTS_TAG = '[object Arguments]';\r\nvar BOOLEAN_TAG = '[object Boolean]';\r\nvar DATE_TAG = '[object Date]';\r\nvar REG_EXP_TAG = '[object RegExp]';\r\nvar MAP_TAG = '[object Map]';\r\nvar NUMBER_TAG = '[object Number]';\r\nvar OBJECT_TAG = '[object Object]';\r\nvar SET_TAG = '[object Set]';\r\nvar STRING_TAG = '[object String]';\r\nvar toString = Object.prototype.toString;\r\nfunction createComparator(_a) {\r\n    var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areMapsEqual = _a.areMapsEqual, areObjectsEqual = _a.areObjectsEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, createIsNestedEqual = _a.createIsNestedEqual;\r\n    var isEqual = createIsNestedEqual(comparator);\r\n    /**\r\n     * compare the value of the two objects and return true if they are equivalent in values\r\n     */\r\n    function comparator(a, b, meta) {\r\n        // If the items are strictly equal, no need to do a value comparison.\r\n        if (a === b) {\r\n            return true;\r\n        }\r\n        // If the items are not non-nullish objects, then the only possibility\r\n        // of them being equal but not strictly is if they are both `NaN`. Since\r\n        // `NaN` is uniquely not equal to itself, we can use self-comparison of\r\n        // both objects, which is faster than `isNaN()`.\r\n        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\r\n            return a !== a && b !== b;\r\n        }\r\n        // Checks are listed in order of commonality of use-case:\r\n        //   1. Common complex object types (plain object, array)\r\n        //   2. Common data values (date, regexp)\r\n        //   3. Less-common complex object types (map, set)\r\n        //   4. Less-common data values (promise, primitive wrappers)\r\n        // Inherently this is both subjective and assumptive, however\r\n        // when reviewing comparable libraries in the wild this order\r\n        // appears to be generally consistent.\r\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\r\n        // comparisons are rare, and will be handled in the ultimate fallback, so\r\n        // we can avoid the `toString.call()` cost unless necessary.\r\n        if (isPlainObject(a) && isPlainObject(b)) {\r\n            return areObjectsEqual(a, b, isEqual, meta);\r\n        }\r\n        // `isArray()` works on subclasses and is cross-realm, so we can again avoid\r\n        // the `toString.call()` cost unless necessary by just checking if either\r\n        // and then both are arrays.\r\n        var aArray = Array.isArray(a);\r\n        var bArray = Array.isArray(b);\r\n        if (aArray || bArray) {\r\n            return aArray === bArray && areArraysEqual(a, b, isEqual, meta);\r\n        }\r\n        // Since this is a custom object, use the classic `toString.call()` to get its\r\n        // type. This is reasonably performant in modern environments like v8 and\r\n        // SpiderMonkey, and allows for cross-realm comparison when other checks like\r\n        // `instanceof` do not.\r\n        var aTag = toString.call(a);\r\n        if (aTag !== toString.call(b)) {\r\n            return false;\r\n        }\r\n        if (aTag === DATE_TAG) {\r\n            // `getTime()` showed better results compared to alternatives like `valueOf()`\r\n            // or the unary `+` operator.\r\n            return areDatesEqual(a, b, isEqual, meta);\r\n        }\r\n        if (aTag === REG_EXP_TAG) {\r\n            return areRegExpsEqual(a, b, isEqual, meta);\r\n        }\r\n        if (aTag === MAP_TAG) {\r\n            return areMapsEqual(a, b, isEqual, meta);\r\n        }\r\n        if (aTag === SET_TAG) {\r\n            return areSetsEqual(a, b, isEqual, meta);\r\n        }\r\n        // If a simple object tag, then we can prioritize a simple object comparison because\r\n        // it is likely a custom class. If an arguments tag, it should be treated as a standard\r\n        // object.\r\n        if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {\r\n            // The exception for value comparison is `Promise`-like contracts. These should be\r\n            // treated the same as standard `Promise` objects, which means strict equality.\r\n            return isPromiseLike(a) || isPromiseLike(b)\r\n                ? false\r\n                : areObjectsEqual(a, b, isEqual, meta);\r\n        }\r\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\r\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\r\n        // types.\r\n        if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {\r\n            return sameValueZeroEqual(a.valueOf(), b.valueOf());\r\n        }\r\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\r\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\r\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\r\n        //     comparison that can be made.\r\n        //   - For types that can be introspected, but rarely have requirements to be compared\r\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\r\n        //     use-cases (may be included in a future release, if requested enough).\r\n        //   - For types that can be introspected but do not have an objective definition of what\r\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\r\n        // In all cases, these decisions should be reevaluated based on changes to the language and\r\n        // common development practices.\r\n        return false;\r\n    }\r\n    return comparator;\r\n}\n\n/**\r\n * Whether the arrays are equal in value.\r\n */\r\nfunction areArraysEqual(a, b, isEqual, meta) {\r\n    var index = a.length;\r\n    if (b.length !== index) {\r\n        return false;\r\n    }\r\n    // Decrementing `while` showed faster results than either incrementing or\r\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\r\n    // methods like `some` / `every` were not used to avoid incurring the garbage\r\n    // cost of anonymous callbacks.\r\n    while (index-- > 0) {\r\n        if (!isEqual(a[index], b[index], index, index, a, b, meta)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the arrays are equal in value, including circular references.\r\n */\r\nvar areArraysEqualCircular = createIsCircular(areArraysEqual);\n\n/**\r\n * Whether the dates passed are equal in value.\r\n *\r\n * @NOTE\r\n * This is a standalone function instead of done inline in the comparator\r\n * to allow for overrides.\r\n */\r\nfunction areDatesEqual(a, b) {\r\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\r\n}\n\n/**\r\n * Whether the `Map`s are equal in value.\r\n */\r\nfunction areMapsEqual(a, b, isEqual, meta) {\r\n    var isValueEqual = a.size === b.size;\r\n    if (!isValueEqual) {\r\n        return false;\r\n    }\r\n    if (!a.size) {\r\n        return true;\r\n    }\r\n    // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\r\n    // the inability to control the performance of the resulting code. It also avoids excessive\r\n    // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\r\n    // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\r\n    // equality checks themselves.\r\n    var matchedIndices = {};\r\n    var indexA = 0;\r\n    a.forEach(function (aValue, aKey) {\r\n        if (!isValueEqual) {\r\n            return;\r\n        }\r\n        var hasMatch = false;\r\n        var matchIndexB = 0;\r\n        b.forEach(function (bValue, bKey) {\r\n            if (!hasMatch &&\r\n                !matchedIndices[matchIndexB] &&\r\n                (hasMatch =\r\n                    isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) &&\r\n                        isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {\r\n                matchedIndices[matchIndexB] = true;\r\n            }\r\n            matchIndexB++;\r\n        });\r\n        indexA++;\r\n        isValueEqual = hasMatch;\r\n    });\r\n    return isValueEqual;\r\n}\r\n/**\r\n * Whether the `Map`s are equal in value, including circular references.\r\n */\r\nvar areMapsEqualCircular = createIsCircular(areMapsEqual);\n\nvar OWNER = '_owner';\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n/**\r\n * Whether the objects are equal in value.\r\n */\r\nfunction areObjectsEqual(a, b, isEqual, meta) {\r\n    var keysA = Object.keys(a);\r\n    var index = keysA.length;\r\n    if (Object.keys(b).length !== index) {\r\n        return false;\r\n    }\r\n    var key;\r\n    // Decrementing `while` showed faster results than either incrementing or\r\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\r\n    // methods like `some` / `every` were not used to avoid incurring the garbage\r\n    // cost of anonymous callbacks.\r\n    while (index-- > 0) {\r\n        key = keysA[index];\r\n        if (key === OWNER) {\r\n            var reactElementA = !!a.$$typeof;\r\n            var reactElementB = !!b.$$typeof;\r\n            if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {\r\n                return false;\r\n            }\r\n        }\r\n        if (!hasOwnProperty.call(b, key) ||\r\n            !isEqual(a[key], b[key], key, key, a, b, meta)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the objects are equal in value, including circular references.\r\n */\r\nvar areObjectsEqualCircular = createIsCircular(areObjectsEqual);\n\n/**\r\n * Whether the regexps passed are equal in value.\r\n *\r\n * @NOTE\r\n * This is a standalone function instead of done inline in the comparator\r\n * to allow for overrides. An example of this would be supporting a\r\n * pre-ES2015 environment where the `flags` property is not available.\r\n */\r\nfunction areRegExpsEqual(a, b) {\r\n    return a.source === b.source && a.flags === b.flags;\r\n}\n\n/**\r\n * Whether the `Set`s are equal in value.\r\n */\r\nfunction areSetsEqual(a, b, isEqual, meta) {\r\n    var isValueEqual = a.size === b.size;\r\n    if (!isValueEqual) {\r\n        return false;\r\n    }\r\n    if (!a.size) {\r\n        return true;\r\n    }\r\n    // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\r\n    // the inability to control the performance of the resulting code. It also avoids excessive\r\n    // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\r\n    // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\r\n    // equality checks themselves.\r\n    var matchedIndices = {};\r\n    a.forEach(function (aValue, aKey) {\r\n        if (!isValueEqual) {\r\n            return;\r\n        }\r\n        var hasMatch = false;\r\n        var matchIndex = 0;\r\n        b.forEach(function (bValue, bKey) {\r\n            if (!hasMatch &&\r\n                !matchedIndices[matchIndex] &&\r\n                (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {\r\n                matchedIndices[matchIndex] = true;\r\n            }\r\n            matchIndex++;\r\n        });\r\n        isValueEqual = hasMatch;\r\n    });\r\n    return isValueEqual;\r\n}\r\n/**\r\n * Whether the `Set`s are equal in value, including circular references.\r\n */\r\nvar areSetsEqualCircular = createIsCircular(areSetsEqual);\n\nvar DEFAULT_CONFIG = Object.freeze({\r\n    areArraysEqual: areArraysEqual,\r\n    areDatesEqual: areDatesEqual,\r\n    areMapsEqual: areMapsEqual,\r\n    areObjectsEqual: areObjectsEqual,\r\n    areRegExpsEqual: areRegExpsEqual,\r\n    areSetsEqual: areSetsEqual,\r\n    createIsNestedEqual: createDefaultIsNestedEqual,\r\n});\r\nvar DEFAULT_CIRCULAR_CONFIG = Object.freeze({\r\n    areArraysEqual: areArraysEqualCircular,\r\n    areDatesEqual: areDatesEqual,\r\n    areMapsEqual: areMapsEqualCircular,\r\n    areObjectsEqual: areObjectsEqualCircular,\r\n    areRegExpsEqual: areRegExpsEqual,\r\n    areSetsEqual: areSetsEqualCircular,\r\n    createIsNestedEqual: createDefaultIsNestedEqual,\r\n});\r\nvar isDeepEqual = createComparator(DEFAULT_CONFIG);\r\n/**\r\n * Whether the items passed are deeply-equal in value.\r\n */\r\nfunction deepEqual(a, b) {\r\n    return isDeepEqual(a, b, undefined);\r\n}\r\nvar isShallowEqual = createComparator(merge(DEFAULT_CONFIG, { createIsNestedEqual: function () { return sameValueZeroEqual; } }));\r\n/**\r\n * Whether the items passed are shallowly-equal in value.\r\n */\r\nfunction shallowEqual(a, b) {\r\n    return isShallowEqual(a, b, undefined);\r\n}\r\nvar isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);\r\n/**\r\n * Whether the items passed are deeply-equal in value, including circular references.\r\n */\r\nfunction circularDeepEqual(a, b) {\r\n    return isCircularDeepEqual(a, b, new WeakMap());\r\n}\r\nvar isCircularShallowEqual = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, {\r\n    createIsNestedEqual: function () { return sameValueZeroEqual; },\r\n}));\r\n/**\r\n * Whether the items passed are shallowly-equal in value, including circular references.\r\n */\r\nfunction circularShallowEqual(a, b) {\r\n    return isCircularShallowEqual(a, b, new WeakMap());\r\n}\r\n/**\r\n * Create a custom equality comparison method.\r\n *\r\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n * where the standard methods are not performant enough, but can also be used to provide\r\n * support for legacy environments that do not support expected features like\r\n * `RegExp.prototype.flags` out of the box.\r\n */\r\nfunction createCustomEqual(getComparatorOptions) {\r\n    return createComparator(merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG)));\r\n}\r\n/**\r\n * Create a custom equality comparison method that handles circular references. This is very\r\n * similar to `createCustomEqual`, with the only difference being that `meta` expects to be\r\n * populated with a `WeakMap`-like contract.\r\n *\r\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n * where the standard methods are not performant enough, but can also be used to provide\r\n * support for legacy environments that do not support expected features like\r\n * `WeakMap` out of the box.\r\n */\r\nfunction createCustomCircularEqual(getComparatorOptions) {\r\n    var comparator = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, getComparatorOptions(DEFAULT_CIRCULAR_CONFIG)));\r\n    return (function (a, b, meta) {\r\n        if (meta === void 0) { meta = new WeakMap(); }\r\n        return comparator(a, b, meta);\r\n    });\r\n}\n\n\n//# sourceMappingURL=fast-equals.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9mYXN0LWVxdWFscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxtQ0FBbUMsOEJBQThCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7O0FBRThJO0FBQzlJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RvY2ttYXN0ZXItaW1zLy4vbm9kZV9tb2R1bGVzL2Zhc3QtZXF1YWxzL2Rpc3QvZmFzdC1lcXVhbHMuZXNtLmpzP2YwMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERlZmF1bHQgZXF1YWxpdHkgY29tcGFyYXRvciBwYXNzLXRocm91Z2gsIHVzZWQgYXMgdGhlIHN0YW5kYXJkIGBpc0VxdWFsYCBjcmVhdG9yIGZvclxyXG4gKiB1c2UgaW5zaWRlIHRoZSBidWlsdCBjb21wYXJhdG9yLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdElzTmVzdGVkRXF1YWwoY29tcGFyYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgX2luZGV4T3JLZXlBLCBfaW5kZXhPcktleUIsIF9wYXJlbnRBLCBfcGFyZW50QiwgbWV0YSkge1xyXG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIsIG1ldGEpO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogV3JhcCB0aGUgcHJvdmlkZWQgYGFyZUl0ZW1zRXF1YWxgIG1ldGhvZCB0byBtYW5hZ2UgdGhlIGNpcmN1bGFyIGNhY2hlLCBhbGxvd2luZ1xyXG4gKiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byBiZSBzYWZlbHkgaW5jbHVkZWQgaW4gdGhlIGNvbXBhcmlzb24gd2l0aG91dCBjcmVhdGluZ1xyXG4gKiBzdGFjayBvdmVyZmxvd3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVJc0NpcmN1bGFyKGFyZUl0ZW1zRXF1YWwpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBpc0NpcmN1bGFyKGEsIGIsIGlzRXF1YWwsIGNhY2hlKSB7XHJcbiAgICAgICAgaWYgKCFhIHx8ICFiIHx8IHR5cGVvZiBhICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZUl0ZW1zRXF1YWwoYSwgYiwgaXNFcXVhbCwgY2FjaGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FjaGVkQSA9IGNhY2hlLmdldChhKTtcclxuICAgICAgICB2YXIgY2FjaGVkQiA9IGNhY2hlLmdldChiKTtcclxuICAgICAgICBpZiAoY2FjaGVkQSAmJiBjYWNoZWRCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRBID09PSBiICYmIGNhY2hlZEIgPT09IGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhY2hlLnNldChhLCBiKTtcclxuICAgICAgICBjYWNoZS5zZXQoYiwgYSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFyZUl0ZW1zRXF1YWwoYSwgYiwgaXNFcXVhbCwgY2FjaGUpO1xyXG4gICAgICAgIGNhY2hlLmRlbGV0ZShhKTtcclxuICAgICAgICBjYWNoZS5kZWxldGUoYik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFRhcmdldGVkIHNoYWxsb3cgbWVyZ2Ugb2YgdHdvIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBOT1RFXHJcbiAqIFRoaXMgZXhpc3RzIGFzIGEgdGluaWVyIGNvbXBpbGVkIHZlcnNpb24gb2YgdGhlIGBfX2Fzc2lnbmAgaGVscGVyIHRoYXRcclxuICogYHRzY2AgaW5qZWN0cyBpbiBjYXNlIG9mIGBPYmplY3QuYXNzaWduYCBub3QgYmVpbmcgcHJlc2VudC5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcclxuICAgIHZhciBtZXJnZWQgPSB7fTtcclxuICAgIGZvciAodmFyIGtleSBpbiBhKSB7XHJcbiAgICAgICAgbWVyZ2VkW2tleV0gPSBhW2tleV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gYikge1xyXG4gICAgICAgIG1lcmdlZFtrZXldID0gYltrZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lcmdlZDtcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBOT1RFXHJcbiAqIFRoaXMgaXMgYSBzYW1lLXJlYWxtIGNvbXBhcmlvc24gb25seS5cclxuICovXHJcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHZhbHVlLmNvbnN0cnVjdG9yID09IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFdoZW4gdGhlIHZhbHVlIGlzIGBQcm9taXNlYC1saWtlLCBha2EgXCJ0aGVuLWFibGVcIi5cclxuICovXHJcbmZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgdmFsdWVzIHBhc3NlZCBhcmUgc3RyaWN0bHkgZXF1YWwgb3IgYm90aCBOYU4uXHJcbiAqL1xyXG5mdW5jdGlvbiBzYW1lVmFsdWVaZXJvRXF1YWwoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgPT09IGIgfHwgKGEgIT09IGEgJiYgYiAhPT0gYik7XHJcbn1cblxudmFyIEFSR1VNRU5UU19UQUcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcclxudmFyIEJPT0xFQU5fVEFHID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xyXG52YXIgREFURV9UQUcgPSAnW29iamVjdCBEYXRlXSc7XHJcbnZhciBSRUdfRVhQX1RBRyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xyXG52YXIgTUFQX1RBRyA9ICdbb2JqZWN0IE1hcF0nO1xyXG52YXIgTlVNQkVSX1RBRyA9ICdbb2JqZWN0IE51bWJlcl0nO1xyXG52YXIgT0JKRUNUX1RBRyA9ICdbb2JqZWN0IE9iamVjdF0nO1xyXG52YXIgU0VUX1RBRyA9ICdbb2JqZWN0IFNldF0nO1xyXG52YXIgU1RSSU5HX1RBRyA9ICdbb2JqZWN0IFN0cmluZ10nO1xyXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5mdW5jdGlvbiBjcmVhdGVDb21wYXJhdG9yKF9hKSB7XHJcbiAgICB2YXIgYXJlQXJyYXlzRXF1YWwgPSBfYS5hcmVBcnJheXNFcXVhbCwgYXJlRGF0ZXNFcXVhbCA9IF9hLmFyZURhdGVzRXF1YWwsIGFyZU1hcHNFcXVhbCA9IF9hLmFyZU1hcHNFcXVhbCwgYXJlT2JqZWN0c0VxdWFsID0gX2EuYXJlT2JqZWN0c0VxdWFsLCBhcmVSZWdFeHBzRXF1YWwgPSBfYS5hcmVSZWdFeHBzRXF1YWwsIGFyZVNldHNFcXVhbCA9IF9hLmFyZVNldHNFcXVhbCwgY3JlYXRlSXNOZXN0ZWRFcXVhbCA9IF9hLmNyZWF0ZUlzTmVzdGVkRXF1YWw7XHJcbiAgICB2YXIgaXNFcXVhbCA9IGNyZWF0ZUlzTmVzdGVkRXF1YWwoY29tcGFyYXRvcik7XHJcbiAgICAvKipcclxuICAgICAqIGNvbXBhcmUgdGhlIHZhbHVlIG9mIHRoZSB0d28gb2JqZWN0cyBhbmQgcmV0dXJuIHRydWUgaWYgdGhleSBhcmUgZXF1aXZhbGVudCBpbiB2YWx1ZXNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29tcGFyYXRvcihhLCBiLCBtZXRhKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGl0ZW1zIGFyZSBzdHJpY3RseSBlcXVhbCwgbm8gbmVlZCB0byBkbyBhIHZhbHVlIGNvbXBhcmlzb24uXHJcbiAgICAgICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBpdGVtcyBhcmUgbm90IG5vbi1udWxsaXNoIG9iamVjdHMsIHRoZW4gdGhlIG9ubHkgcG9zc2liaWxpdHlcclxuICAgICAgICAvLyBvZiB0aGVtIGJlaW5nIGVxdWFsIGJ1dCBub3Qgc3RyaWN0bHkgaXMgaWYgdGhleSBhcmUgYm90aCBgTmFOYC4gU2luY2VcclxuICAgICAgICAvLyBgTmFOYCBpcyB1bmlxdWVseSBub3QgZXF1YWwgdG8gaXRzZWxmLCB3ZSBjYW4gdXNlIHNlbGYtY29tcGFyaXNvbiBvZlxyXG4gICAgICAgIC8vIGJvdGggb2JqZWN0cywgd2hpY2ggaXMgZmFzdGVyIHRoYW4gYGlzTmFOKClgLlxyXG4gICAgICAgIGlmICghYSB8fCAhYiB8fCB0eXBlb2YgYSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrcyBhcmUgbGlzdGVkIGluIG9yZGVyIG9mIGNvbW1vbmFsaXR5IG9mIHVzZS1jYXNlOlxyXG4gICAgICAgIC8vICAgMS4gQ29tbW9uIGNvbXBsZXggb2JqZWN0IHR5cGVzIChwbGFpbiBvYmplY3QsIGFycmF5KVxyXG4gICAgICAgIC8vICAgMi4gQ29tbW9uIGRhdGEgdmFsdWVzIChkYXRlLCByZWdleHApXHJcbiAgICAgICAgLy8gICAzLiBMZXNzLWNvbW1vbiBjb21wbGV4IG9iamVjdCB0eXBlcyAobWFwLCBzZXQpXHJcbiAgICAgICAgLy8gICA0LiBMZXNzLWNvbW1vbiBkYXRhIHZhbHVlcyAocHJvbWlzZSwgcHJpbWl0aXZlIHdyYXBwZXJzKVxyXG4gICAgICAgIC8vIEluaGVyZW50bHkgdGhpcyBpcyBib3RoIHN1YmplY3RpdmUgYW5kIGFzc3VtcHRpdmUsIGhvd2V2ZXJcclxuICAgICAgICAvLyB3aGVuIHJldmlld2luZyBjb21wYXJhYmxlIGxpYnJhcmllcyBpbiB0aGUgd2lsZCB0aGlzIG9yZGVyXHJcbiAgICAgICAgLy8gYXBwZWFycyB0byBiZSBnZW5lcmFsbHkgY29uc2lzdGVudC5cclxuICAgICAgICAvLyBgaXNQbGFpbk9iamVjdGAgb25seSBjaGVja3MgYWdhaW5zdCB0aGUgb2JqZWN0J3Mgb3duIHJlYWxtLiBDcm9zcy1yZWFsbVxyXG4gICAgICAgIC8vIGNvbXBhcmlzb25zIGFyZSByYXJlLCBhbmQgd2lsbCBiZSBoYW5kbGVkIGluIHRoZSB1bHRpbWF0ZSBmYWxsYmFjaywgc29cclxuICAgICAgICAvLyB3ZSBjYW4gYXZvaWQgdGhlIGB0b1N0cmluZy5jYWxsKClgIGNvc3QgdW5sZXNzIG5lY2Vzc2FyeS5cclxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGBpc0FycmF5KClgIHdvcmtzIG9uIHN1YmNsYXNzZXMgYW5kIGlzIGNyb3NzLXJlYWxtLCBzbyB3ZSBjYW4gYWdhaW4gYXZvaWRcclxuICAgICAgICAvLyB0aGUgYHRvU3RyaW5nLmNhbGwoKWAgY29zdCB1bmxlc3MgbmVjZXNzYXJ5IGJ5IGp1c3QgY2hlY2tpbmcgaWYgZWl0aGVyXHJcbiAgICAgICAgLy8gYW5kIHRoZW4gYm90aCBhcmUgYXJyYXlzLlxyXG4gICAgICAgIHZhciBhQXJyYXkgPSBBcnJheS5pc0FycmF5KGEpO1xyXG4gICAgICAgIHZhciBiQXJyYXkgPSBBcnJheS5pc0FycmF5KGIpO1xyXG4gICAgICAgIGlmIChhQXJyYXkgfHwgYkFycmF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhQXJyYXkgPT09IGJBcnJheSAmJiBhcmVBcnJheXNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGN1c3RvbSBvYmplY3QsIHVzZSB0aGUgY2xhc3NpYyBgdG9TdHJpbmcuY2FsbCgpYCB0byBnZXQgaXRzXHJcbiAgICAgICAgLy8gdHlwZS4gVGhpcyBpcyByZWFzb25hYmx5IHBlcmZvcm1hbnQgaW4gbW9kZXJuIGVudmlyb25tZW50cyBsaWtlIHY4IGFuZFxyXG4gICAgICAgIC8vIFNwaWRlck1vbmtleSwgYW5kIGFsbG93cyBmb3IgY3Jvc3MtcmVhbG0gY29tcGFyaXNvbiB3aGVuIG90aGVyIGNoZWNrcyBsaWtlXHJcbiAgICAgICAgLy8gYGluc3RhbmNlb2ZgIGRvIG5vdC5cclxuICAgICAgICB2YXIgYVRhZyA9IHRvU3RyaW5nLmNhbGwoYSk7XHJcbiAgICAgICAgaWYgKGFUYWcgIT09IHRvU3RyaW5nLmNhbGwoYikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYVRhZyA9PT0gREFURV9UQUcpIHtcclxuICAgICAgICAgICAgLy8gYGdldFRpbWUoKWAgc2hvd2VkIGJldHRlciByZXN1bHRzIGNvbXBhcmVkIHRvIGFsdGVybmF0aXZlcyBsaWtlIGB2YWx1ZU9mKClgXHJcbiAgICAgICAgICAgIC8vIG9yIHRoZSB1bmFyeSBgK2Agb3BlcmF0b3IuXHJcbiAgICAgICAgICAgIHJldHVybiBhcmVEYXRlc0VxdWFsKGEsIGIsIGlzRXF1YWwsIG1ldGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYVRhZyA9PT0gUkVHX0VYUF9UQUcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZVJlZ0V4cHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFUYWcgPT09IE1BUF9UQUcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZU1hcHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFUYWcgPT09IFNFVF9UQUcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZVNldHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYSBzaW1wbGUgb2JqZWN0IHRhZywgdGhlbiB3ZSBjYW4gcHJpb3JpdGl6ZSBhIHNpbXBsZSBvYmplY3QgY29tcGFyaXNvbiBiZWNhdXNlXHJcbiAgICAgICAgLy8gaXQgaXMgbGlrZWx5IGEgY3VzdG9tIGNsYXNzLiBJZiBhbiBhcmd1bWVudHMgdGFnLCBpdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHN0YW5kYXJkXHJcbiAgICAgICAgLy8gb2JqZWN0LlxyXG4gICAgICAgIGlmIChhVGFnID09PSBPQkpFQ1RfVEFHIHx8IGFUYWcgPT09IEFSR1VNRU5UU19UQUcpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGV4Y2VwdGlvbiBmb3IgdmFsdWUgY29tcGFyaXNvbiBpcyBgUHJvbWlzZWAtbGlrZSBjb250cmFjdHMuIFRoZXNlIHNob3VsZCBiZVxyXG4gICAgICAgICAgICAvLyB0cmVhdGVkIHRoZSBzYW1lIGFzIHN0YW5kYXJkIGBQcm9taXNlYCBvYmplY3RzLCB3aGljaCBtZWFucyBzdHJpY3QgZXF1YWxpdHkuXHJcbiAgICAgICAgICAgIHJldHVybiBpc1Byb21pc2VMaWtlKGEpIHx8IGlzUHJvbWlzZUxpa2UoYilcclxuICAgICAgICAgICAgICAgID8gZmFsc2VcclxuICAgICAgICAgICAgICAgIDogYXJlT2JqZWN0c0VxdWFsKGEsIGIsIGlzRXF1YWwsIG1ldGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBcyB0aGUgcGVudWx0aW1hdGUgZmFsbGJhY2ssIGNoZWNrIGlmIHRoZSB2YWx1ZXMgcGFzc2VkIGFyZSBwcmltaXRpdmUgd3JhcHBlcnMuIFRoaXNcclxuICAgICAgICAvLyBpcyB2ZXJ5IHJhcmUgaW4gbW9kZXJuIEpTLCB3aGljaCBpcyB3aHkgaXQgaXMgZGVwcmlvcml0aXplZCBjb21wYXJlZCB0byBhbGwgb3RoZXIgb2JqZWN0XHJcbiAgICAgICAgLy8gdHlwZXMuXHJcbiAgICAgICAgaWYgKGFUYWcgPT09IEJPT0xFQU5fVEFHIHx8IGFUYWcgPT09IE5VTUJFUl9UQUcgfHwgYVRhZyA9PT0gU1RSSU5HX1RBRykge1xyXG4gICAgICAgICAgICByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIG5vdCBtYXRjaGluZyBhbnkgdGFncyB0aGF0IHJlcXVpcmUgYSBzcGVjaWZpYyB0eXBlIG9mIGNvbXBhcmlzb24sIHRoZW4gd2UgaGFyZC1jb2RlIGZhbHNlIGJlY2F1c2VcclxuICAgICAgICAvLyB0aGUgb25seSB0aGluZyByZW1haW5pbmcgaXMgc3RyaWN0IGVxdWFsaXR5LCB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBhcmVkLiBUaGlzIGlzIGZvciBhIGZldyByZWFzb25zOlxyXG4gICAgICAgIC8vICAgLSBDZXJ0YWluIHR5cGVzIHRoYXQgY2Fubm90IGJlIGludHJvc3BlY3RlZCAoZS5nLiwgYFdlYWtNYXBgKS4gRm9yIHRoZXNlIHR5cGVzLCB0aGlzIGlzIHRoZSBvbmx5XHJcbiAgICAgICAgLy8gICAgIGNvbXBhcmlzb24gdGhhdCBjYW4gYmUgbWFkZS5cclxuICAgICAgICAvLyAgIC0gRm9yIHR5cGVzIHRoYXQgY2FuIGJlIGludHJvc3BlY3RlZCwgYnV0IHJhcmVseSBoYXZlIHJlcXVpcmVtZW50cyB0byBiZSBjb21wYXJlZFxyXG4gICAgICAgIC8vICAgICAoYEFycmF5QnVmZmVyYCwgYERhdGFWaWV3YCwgZXRjLiksIHRoZSBjb3N0IGlzIGF2b2lkZWQgdG8gcHJpb3JpdGl6ZSB0aGUgY29tbW9uXHJcbiAgICAgICAgLy8gICAgIHVzZS1jYXNlcyAobWF5IGJlIGluY2x1ZGVkIGluIGEgZnV0dXJlIHJlbGVhc2UsIGlmIHJlcXVlc3RlZCBlbm91Z2gpLlxyXG4gICAgICAgIC8vICAgLSBGb3IgdHlwZXMgdGhhdCBjYW4gYmUgaW50cm9zcGVjdGVkIGJ1dCBkbyBub3QgaGF2ZSBhbiBvYmplY3RpdmUgZGVmaW5pdGlvbiBvZiB3aGF0XHJcbiAgICAgICAgLy8gICAgIGVxdWFsaXR5IGlzIChgRXJyb3JgLCBldGMuKSwgdGhlIHN1YmplY3RpdmUgZGVjaXNpb24gaXMgdG8gYmUgY29uc2VydmF0aXZlIGFuZCBzdHJpY3RseSBjb21wYXJlLlxyXG4gICAgICAgIC8vIEluIGFsbCBjYXNlcywgdGhlc2UgZGVjaXNpb25zIHNob3VsZCBiZSByZWV2YWx1YXRlZCBiYXNlZCBvbiBjaGFuZ2VzIHRvIHRoZSBsYW5ndWFnZSBhbmRcclxuICAgICAgICAvLyBjb21tb24gZGV2ZWxvcG1lbnQgcHJhY3RpY2VzLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb21wYXJhdG9yO1xyXG59XG5cbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBhcnJheXMgYXJlIGVxdWFsIGluIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSkge1xyXG4gICAgdmFyIGluZGV4ID0gYS5sZW5ndGg7XHJcbiAgICBpZiAoYi5sZW5ndGggIT09IGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gRGVjcmVtZW50aW5nIGB3aGlsZWAgc2hvd2VkIGZhc3RlciByZXN1bHRzIHRoYW4gZWl0aGVyIGluY3JlbWVudGluZyBvclxyXG4gICAgLy8gZGVjcmVtZW50aW5nIGBmb3JgIGxvb3AgYW5kIHRoYW4gYW4gaW5jcmVtZW50aW5nIGB3aGlsZWAgbG9vcC4gRGVjbGFyYXRpdmVcclxuICAgIC8vIG1ldGhvZHMgbGlrZSBgc29tZWAgLyBgZXZlcnlgIHdlcmUgbm90IHVzZWQgdG8gYXZvaWQgaW5jdXJyaW5nIHRoZSBnYXJiYWdlXHJcbiAgICAvLyBjb3N0IG9mIGFub255bW91cyBjYWxsYmFja3MuXHJcbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcclxuICAgICAgICBpZiAoIWlzRXF1YWwoYVtpbmRleF0sIGJbaW5kZXhdLCBpbmRleCwgaW5kZXgsIGEsIGIsIG1ldGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgYXJyYXlzIGFyZSBlcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXHJcbiAqL1xyXG52YXIgYXJlQXJyYXlzRXF1YWxDaXJjdWxhciA9IGNyZWF0ZUlzQ2lyY3VsYXIoYXJlQXJyYXlzRXF1YWwpO1xuXG4vKipcclxuICogV2hldGhlciB0aGUgZGF0ZXMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICpcclxuICogQE5PVEVcclxuICogVGhpcyBpcyBhIHN0YW5kYWxvbmUgZnVuY3Rpb24gaW5zdGVhZCBvZiBkb25lIGlubGluZSBpbiB0aGUgY29tcGFyYXRvclxyXG4gKiB0byBhbGxvdyBmb3Igb3ZlcnJpZGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJlRGF0ZXNFcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSk7XHJcbn1cblxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGBNYXBgcyBhcmUgZXF1YWwgaW4gdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVNYXBzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSkge1xyXG4gICAgdmFyIGlzVmFsdWVFcXVhbCA9IGEuc2l6ZSA9PT0gYi5zaXplO1xyXG4gICAgaWYgKCFpc1ZhbHVlRXF1YWwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWEuc2l6ZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlIHVzZSBvZiBgZm9yRWFjaCgpYCBpcyB0byBhdm9pZCB0aGUgdHJhbnNwaWxhdGlvbiBjb3N0IG9mIGBmb3IuLi5vZmAgY29tcGFyaXNvbnMsIGFuZFxyXG4gICAgLy8gdGhlIGluYWJpbGl0eSB0byBjb250cm9sIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgcmVzdWx0aW5nIGNvZGUuIEl0IGFsc28gYXZvaWRzIGV4Y2Vzc2l2ZVxyXG4gICAgLy8gaXRlcmF0aW9uIGNvbXBhcmVkIHRvIGRvaW5nIGNvbXBhcmlzb25zIG9mIGBrZXlzKClgIGFuZCBgdmFsdWVzKClgLiBBcyBhIHJlc3VsdCwgdGhvdWdoLFxyXG4gICAgLy8gd2UgY2Fubm90IHNob3J0LWNpcmN1aXQgdGhlIGl0ZXJhdGlvbnM7IGJvb2trZWVwaW5nIG11c3QgYmUgZG9uZSB0byBzaG9ydC1jaXJjdWl0IHRoZVxyXG4gICAgLy8gZXF1YWxpdHkgY2hlY2tzIHRoZW1zZWx2ZXMuXHJcbiAgICB2YXIgbWF0Y2hlZEluZGljZXMgPSB7fTtcclxuICAgIHZhciBpbmRleEEgPSAwO1xyXG4gICAgYS5mb3JFYWNoKGZ1bmN0aW9uIChhVmFsdWUsIGFLZXkpIHtcclxuICAgICAgICBpZiAoIWlzVmFsdWVFcXVhbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoYXNNYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBtYXRjaEluZGV4QiA9IDA7XHJcbiAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiVmFsdWUsIGJLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFoYXNNYXRjaCAmJlxyXG4gICAgICAgICAgICAgICAgIW1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhCXSAmJlxyXG4gICAgICAgICAgICAgICAgKGhhc01hdGNoID1cclxuICAgICAgICAgICAgICAgICAgICBpc0VxdWFsKGFLZXksIGJLZXksIGluZGV4QSwgbWF0Y2hJbmRleEIsIGEsIGIsIG1ldGEpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXF1YWwoYVZhbHVlLCBiVmFsdWUsIGFLZXksIGJLZXksIGEsIGIsIG1ldGEpKSkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleEJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRjaEluZGV4QisrO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGluZGV4QSsrO1xyXG4gICAgICAgIGlzVmFsdWVFcXVhbCA9IGhhc01hdGNoO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gaXNWYWx1ZUVxdWFsO1xyXG59XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBgTWFwYHMgYXJlIGVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcy5cclxuICovXHJcbnZhciBhcmVNYXBzRXF1YWxDaXJjdWxhciA9IGNyZWF0ZUlzQ2lyY3VsYXIoYXJlTWFwc0VxdWFsKTtcblxudmFyIE9XTkVSID0gJ19vd25lcic7XHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGFyZU9iamVjdHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKSB7XHJcbiAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcclxuICAgIHZhciBpbmRleCA9IGtleXNBLmxlbmd0aDtcclxuICAgIGlmIChPYmplY3Qua2V5cyhiKS5sZW5ndGggIT09IGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIGtleTtcclxuICAgIC8vIERlY3JlbWVudGluZyBgd2hpbGVgIHNob3dlZCBmYXN0ZXIgcmVzdWx0cyB0aGFuIGVpdGhlciBpbmNyZW1lbnRpbmcgb3JcclxuICAgIC8vIGRlY3JlbWVudGluZyBgZm9yYCBsb29wIGFuZCB0aGFuIGFuIGluY3JlbWVudGluZyBgd2hpbGVgIGxvb3AuIERlY2xhcmF0aXZlXHJcbiAgICAvLyBtZXRob2RzIGxpa2UgYHNvbWVgIC8gYGV2ZXJ5YCB3ZXJlIG5vdCB1c2VkIHRvIGF2b2lkIGluY3VycmluZyB0aGUgZ2FyYmFnZVxyXG4gICAgLy8gY29zdCBvZiBhbm9ueW1vdXMgY2FsbGJhY2tzLlxyXG4gICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XHJcbiAgICAgICAga2V5ID0ga2V5c0FbaW5kZXhdO1xyXG4gICAgICAgIGlmIChrZXkgPT09IE9XTkVSKSB7XHJcbiAgICAgICAgICAgIHZhciByZWFjdEVsZW1lbnRBID0gISFhLiQkdHlwZW9mO1xyXG4gICAgICAgICAgICB2YXIgcmVhY3RFbGVtZW50QiA9ICEhYi4kJHR5cGVvZjtcclxuICAgICAgICAgICAgaWYgKChyZWFjdEVsZW1lbnRBIHx8IHJlYWN0RWxlbWVudEIpICYmIHJlYWN0RWxlbWVudEEgIT09IHJlYWN0RWxlbWVudEIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSB8fFxyXG4gICAgICAgICAgICAhaXNFcXVhbChhW2tleV0sIGJba2V5XSwga2V5LCBrZXksIGEsIGIsIG1ldGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gKi9cclxudmFyIGFyZU9iamVjdHNFcXVhbENpcmN1bGFyID0gY3JlYXRlSXNDaXJjdWxhcihhcmVPYmplY3RzRXF1YWwpO1xuXG4vKipcclxuICogV2hldGhlciB0aGUgcmVnZXhwcyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxyXG4gKlxyXG4gKiBATk9URVxyXG4gKiBUaGlzIGlzIGEgc3RhbmRhbG9uZSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGRvbmUgaW5saW5lIGluIHRoZSBjb21wYXJhdG9yXHJcbiAqIHRvIGFsbG93IGZvciBvdmVycmlkZXMuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBzdXBwb3J0aW5nIGFcclxuICogcHJlLUVTMjAxNSBlbnZpcm9ubWVudCB3aGVyZSB0aGUgYGZsYWdzYCBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJlUmVnRXhwc0VxdWFsKGEsIGIpIHtcclxuICAgIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcclxufVxuXG4vKipcclxuICogV2hldGhlciB0aGUgYFNldGBzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGFyZVNldHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKSB7XHJcbiAgICB2YXIgaXNWYWx1ZUVxdWFsID0gYS5zaXplID09PSBiLnNpemU7XHJcbiAgICBpZiAoIWlzVmFsdWVFcXVhbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghYS5zaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgdXNlIG9mIGBmb3JFYWNoKClgIGlzIHRvIGF2b2lkIHRoZSB0cmFuc3BpbGF0aW9uIGNvc3Qgb2YgYGZvci4uLm9mYCBjb21wYXJpc29ucywgYW5kXHJcbiAgICAvLyB0aGUgaW5hYmlsaXR5IHRvIGNvbnRyb2wgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSByZXN1bHRpbmcgY29kZS4gSXQgYWxzbyBhdm9pZHMgZXhjZXNzaXZlXHJcbiAgICAvLyBpdGVyYXRpb24gY29tcGFyZWQgdG8gZG9pbmcgY29tcGFyaXNvbnMgb2YgYGtleXMoKWAgYW5kIGB2YWx1ZXMoKWAuIEFzIGEgcmVzdWx0LCB0aG91Z2gsXHJcbiAgICAvLyB3ZSBjYW5ub3Qgc2hvcnQtY2lyY3VpdCB0aGUgaXRlcmF0aW9uczsgYm9va2tlZXBpbmcgbXVzdCBiZSBkb25lIHRvIHNob3J0LWNpcmN1aXQgdGhlXHJcbiAgICAvLyBlcXVhbGl0eSBjaGVja3MgdGhlbXNlbHZlcy5cclxuICAgIHZhciBtYXRjaGVkSW5kaWNlcyA9IHt9O1xyXG4gICAgYS5mb3JFYWNoKGZ1bmN0aW9uIChhVmFsdWUsIGFLZXkpIHtcclxuICAgICAgICBpZiAoIWlzVmFsdWVFcXVhbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoYXNNYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBtYXRjaEluZGV4ID0gMDtcclxuICAgICAgICBiLmZvckVhY2goZnVuY3Rpb24gKGJWYWx1ZSwgYktleSkge1xyXG4gICAgICAgICAgICBpZiAoIWhhc01hdGNoICYmXHJcbiAgICAgICAgICAgICAgICAhbWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleF0gJiZcclxuICAgICAgICAgICAgICAgIChoYXNNYXRjaCA9IGlzRXF1YWwoYVZhbHVlLCBiVmFsdWUsIGFLZXksIGJLZXksIGEsIGIsIG1ldGEpKSkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcclxuICAgICAgICB9KTtcclxuICAgICAgICBpc1ZhbHVlRXF1YWwgPSBoYXNNYXRjaDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGlzVmFsdWVFcXVhbDtcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgYFNldGBzIGFyZSBlcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXHJcbiAqL1xyXG52YXIgYXJlU2V0c0VxdWFsQ2lyY3VsYXIgPSBjcmVhdGVJc0NpcmN1bGFyKGFyZVNldHNFcXVhbCk7XG5cbnZhciBERUZBVUxUX0NPTkZJRyA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgYXJlQXJyYXlzRXF1YWw6IGFyZUFycmF5c0VxdWFsLFxyXG4gICAgYXJlRGF0ZXNFcXVhbDogYXJlRGF0ZXNFcXVhbCxcclxuICAgIGFyZU1hcHNFcXVhbDogYXJlTWFwc0VxdWFsLFxyXG4gICAgYXJlT2JqZWN0c0VxdWFsOiBhcmVPYmplY3RzRXF1YWwsXHJcbiAgICBhcmVSZWdFeHBzRXF1YWw6IGFyZVJlZ0V4cHNFcXVhbCxcclxuICAgIGFyZVNldHNFcXVhbDogYXJlU2V0c0VxdWFsLFxyXG4gICAgY3JlYXRlSXNOZXN0ZWRFcXVhbDogY3JlYXRlRGVmYXVsdElzTmVzdGVkRXF1YWwsXHJcbn0pO1xyXG52YXIgREVGQVVMVF9DSVJDVUxBUl9DT05GSUcgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIGFyZUFycmF5c0VxdWFsOiBhcmVBcnJheXNFcXVhbENpcmN1bGFyLFxyXG4gICAgYXJlRGF0ZXNFcXVhbDogYXJlRGF0ZXNFcXVhbCxcclxuICAgIGFyZU1hcHNFcXVhbDogYXJlTWFwc0VxdWFsQ2lyY3VsYXIsXHJcbiAgICBhcmVPYmplY3RzRXF1YWw6IGFyZU9iamVjdHNFcXVhbENpcmN1bGFyLFxyXG4gICAgYXJlUmVnRXhwc0VxdWFsOiBhcmVSZWdFeHBzRXF1YWwsXHJcbiAgICBhcmVTZXRzRXF1YWw6IGFyZVNldHNFcXVhbENpcmN1bGFyLFxyXG4gICAgY3JlYXRlSXNOZXN0ZWRFcXVhbDogY3JlYXRlRGVmYXVsdElzTmVzdGVkRXF1YWwsXHJcbn0pO1xyXG52YXIgaXNEZWVwRXF1YWwgPSBjcmVhdGVDb21wYXJhdG9yKERFRkFVTFRfQ09ORklHKTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgZGVlcGx5LWVxdWFsIGluIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcclxuICAgIHJldHVybiBpc0RlZXBFcXVhbChhLCBiLCB1bmRlZmluZWQpO1xyXG59XHJcbnZhciBpc1NoYWxsb3dFcXVhbCA9IGNyZWF0ZUNvbXBhcmF0b3IobWVyZ2UoREVGQVVMVF9DT05GSUcsIHsgY3JlYXRlSXNOZXN0ZWRFcXVhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsOyB9IH0pKTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKGEsIGIpIHtcclxuICAgIHJldHVybiBpc1NoYWxsb3dFcXVhbChhLCBiLCB1bmRlZmluZWQpO1xyXG59XHJcbnZhciBpc0NpcmN1bGFyRGVlcEVxdWFsID0gY3JlYXRlQ29tcGFyYXRvcihERUZBVUxUX0NJUkNVTEFSX0NPTkZJRyk7XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjaXJjdWxhckRlZXBFcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gaXNDaXJjdWxhckRlZXBFcXVhbChhLCBiLCBuZXcgV2Vha01hcCgpKTtcclxufVxyXG52YXIgaXNDaXJjdWxhclNoYWxsb3dFcXVhbCA9IGNyZWF0ZUNvbXBhcmF0b3IobWVyZ2UoREVGQVVMVF9DSVJDVUxBUl9DT05GSUcsIHtcclxuICAgIGNyZWF0ZUlzTmVzdGVkRXF1YWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbDsgfSxcclxufSkpO1xyXG4vKipcclxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBzaGFsbG93bHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gY2lyY3VsYXJTaGFsbG93RXF1YWwoYSwgYikge1xyXG4gICAgcmV0dXJuIGlzQ2lyY3VsYXJTaGFsbG93RXF1YWwoYSwgYiwgbmV3IFdlYWtNYXAoKSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGN1c3RvbSBlcXVhbGl0eSBjb21wYXJpc29uIG1ldGhvZC5cclxuICpcclxuICogVGhpcyBjYW4gYmUgZG9uZSB0byBjcmVhdGUgdmVyeSB0YXJnZXRlZCBjb21wYXJpc29ucyBpbiBleHRyZW1lIGhvdC1wYXRoIHNjZW5hcmlvc1xyXG4gKiB3aGVyZSB0aGUgc3RhbmRhcmQgbWV0aG9kcyBhcmUgbm90IHBlcmZvcm1hbnQgZW5vdWdoLCBidXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlXHJcbiAqIHN1cHBvcnQgZm9yIGxlZ2FjeSBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBleHBlY3RlZCBmZWF0dXJlcyBsaWtlXHJcbiAqIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBvdXQgb2YgdGhlIGJveC5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUN1c3RvbUVxdWFsKGdldENvbXBhcmF0b3JPcHRpb25zKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlQ29tcGFyYXRvcihtZXJnZShERUZBVUxUX0NPTkZJRywgZ2V0Q29tcGFyYXRvck9wdGlvbnMoREVGQVVMVF9DT05GSUcpKSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGN1c3RvbSBlcXVhbGl0eSBjb21wYXJpc29uIG1ldGhvZCB0aGF0IGhhbmRsZXMgY2lyY3VsYXIgcmVmZXJlbmNlcy4gVGhpcyBpcyB2ZXJ5XHJcbiAqIHNpbWlsYXIgdG8gYGNyZWF0ZUN1c3RvbUVxdWFsYCwgd2l0aCB0aGUgb25seSBkaWZmZXJlbmNlIGJlaW5nIHRoYXQgYG1ldGFgIGV4cGVjdHMgdG8gYmVcclxuICogcG9wdWxhdGVkIHdpdGggYSBgV2Vha01hcGAtbGlrZSBjb250cmFjdC5cclxuICpcclxuICogVGhpcyBjYW4gYmUgZG9uZSB0byBjcmVhdGUgdmVyeSB0YXJnZXRlZCBjb21wYXJpc29ucyBpbiBleHRyZW1lIGhvdC1wYXRoIHNjZW5hcmlvc1xyXG4gKiB3aGVyZSB0aGUgc3RhbmRhcmQgbWV0aG9kcyBhcmUgbm90IHBlcmZvcm1hbnQgZW5vdWdoLCBidXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlXHJcbiAqIHN1cHBvcnQgZm9yIGxlZ2FjeSBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBleHBlY3RlZCBmZWF0dXJlcyBsaWtlXHJcbiAqIGBXZWFrTWFwYCBvdXQgb2YgdGhlIGJveC5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUN1c3RvbUNpcmN1bGFyRXF1YWwoZ2V0Q29tcGFyYXRvck9wdGlvbnMpIHtcclxuICAgIHZhciBjb21wYXJhdG9yID0gY3JlYXRlQ29tcGFyYXRvcihtZXJnZShERUZBVUxUX0NJUkNVTEFSX0NPTkZJRywgZ2V0Q29tcGFyYXRvck9wdGlvbnMoREVGQVVMVF9DSVJDVUxBUl9DT05GSUcpKSk7XHJcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChhLCBiLCBtZXRhKSB7XHJcbiAgICAgICAgaWYgKG1ldGEgPT09IHZvaWQgMCkgeyBtZXRhID0gbmV3IFdlYWtNYXAoKTsgfVxyXG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIsIG1ldGEpO1xyXG4gICAgfSk7XHJcbn1cblxuZXhwb3J0IHsgY2lyY3VsYXJEZWVwRXF1YWwsIGNpcmN1bGFyU2hhbGxvd0VxdWFsLCBjcmVhdGVDdXN0b21DaXJjdWxhckVxdWFsLCBjcmVhdGVDdXN0b21FcXVhbCwgZGVlcEVxdWFsLCBzYW1lVmFsdWVaZXJvRXF1YWwsIHNoYWxsb3dFcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFzdC1lcXVhbHMuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\n");

/***/ })

};
;