/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-grid-layout";
exports.ids = ["vendor-chunks/react-grid-layout"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-grid-layout/build/GridItem.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-grid-layout/build/GridItem.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _reactDraggable = __webpack_require__(/*! react-draggable */ \"(ssr)/./node_modules/react-draggable/build/cjs/cjs.js\");\nvar _reactResizable = __webpack_require__(/*! react-resizable */ \"(ssr)/./node_modules/react-resizable/index.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nvar _calculateUtils = __webpack_require__(/*! ./calculateUtils */ \"(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\");\nvar _ReactGridLayoutPropTypes = __webpack_require__(/*! ./ReactGridLayoutPropTypes */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/*:: import type { Element as ReactElement, Node as ReactNode } from \"react\";*/\n/*:: import type {\n  ReactDraggableCallbackData,\n  GridDragEvent,\n  GridResizeEvent,\n  DroppingPosition,\n  Position,\n  ResizeHandleAxis\n} from \"./utils\";*/\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: import type { ResizeHandle, ReactRef } from \"./ReactGridLayoutPropTypes\";*/\n/*:: type PartialPosition = { top: number, left: number };*/\n/*:: type GridItemCallback<Data: GridDragEvent | GridResizeEvent> = (\n  i: string,\n  w: number,\n  h: number,\n  Data\n) => void;*/\n/*:: type ResizeCallbackData = {\n  node: HTMLElement,\n  size: Position,\n  handle: ResizeHandleAxis\n};*/\n/*:: type GridItemResizeCallback = (\n  e: Event,\n  data: ResizeCallbackData,\n  position: Position\n) => void;*/\n/*:: type State = {\n  resizing: ?{ top: number, left: number, width: number, height: number },\n  dragging: ?{ top: number, left: number },\n  className: string\n};*/\n/*:: type Props = {\n  children: ReactElement<any>,\n  cols: number,\n  containerWidth: number,\n  margin: [number, number],\n  containerPadding: [number, number],\n  rowHeight: number,\n  maxRows: number,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isBounded: boolean,\n  static?: boolean,\n  useCSSTransforms?: boolean,\n  usePercentages?: boolean,\n  transformScale: number,\n  droppingPosition?: DroppingPosition,\n\n  className: string,\n  style?: Object,\n  // Draggability\n  cancel: string,\n  handle: string,\n\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n\n  minW: number,\n  maxW: number,\n  minH: number,\n  maxH: number,\n  i: string,\n\n  resizeHandles?: ResizeHandleAxis[],\n  resizeHandle?: ResizeHandle,\n\n  onDrag?: GridItemCallback<GridDragEvent>,\n  onDragStart?: GridItemCallback<GridDragEvent>,\n  onDragStop?: GridItemCallback<GridDragEvent>,\n  onResize?: GridItemCallback<GridResizeEvent>,\n  onResizeStart?: GridItemCallback<GridResizeEvent>,\n  onResizeStop?: GridItemCallback<GridResizeEvent>\n};*/\n/*:: type DefaultProps = {\n  className: string,\n  cancel: string,\n  handle: string,\n  minH: number,\n  minW: number,\n  maxH: number,\n  maxW: number,\n  transformScale: number\n};*/\n/**\n * An individual item within a ReactGridLayout.\n */\nclass GridItem extends _react.default.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      resizing: null,\n      dragging: null,\n      className: \"\"\n    });\n    _defineProperty(this, \"elementRef\", /*#__PURE__*/_react.default.createRef());\n    /**\n     * onDragStart event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStart\", (e, _ref) => {\n      let {\n        node\n      } = _ref;\n      const {\n        onDragStart,\n        transformScale\n      } = this.props;\n      if (!onDragStart) return;\n      const newPosition /*: PartialPosition*/ = {\n        top: 0,\n        left: 0\n      };\n\n      // TODO: this wont work on nested parents\n      const {\n        offsetParent\n      } = node;\n      if (!offsetParent) return;\n      const parentRect = offsetParent.getBoundingClientRect();\n      const clientRect = node.getBoundingClientRect();\n      const cLeft = clientRect.left / transformScale;\n      const pLeft = parentRect.left / transformScale;\n      const cTop = clientRect.top / transformScale;\n      const pTop = parentRect.top / transformScale;\n      newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;\n      newPosition.top = cTop - pTop + offsetParent.scrollTop;\n      this.setState({\n        dragging: newPosition\n      });\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), newPosition.top, newPosition.left, this.props.w, this.props.h);\n      return onDragStart.call(this, this.props.i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDrag event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     * @param  {boolean} dontFlush    if true, will not call flushSync\n     */\n    _defineProperty(this, \"onDrag\", (e, _ref2, dontFlush) => {\n      let {\n        node,\n        deltaX,\n        deltaY\n      } = _ref2;\n      const {\n        onDrag\n      } = this.props;\n      if (!onDrag) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDrag called before onDragStart.\");\n      }\n      let top = this.state.dragging.top + deltaY;\n      let left = this.state.dragging.left + deltaX;\n      const {\n        isBounded,\n        i,\n        w,\n        h,\n        containerWidth\n      } = this.props;\n      const positionParams = this.getPositionParams();\n\n      // Boundary calculations; keeps items within the grid\n      if (isBounded) {\n        const {\n          offsetParent\n        } = node;\n        if (offsetParent) {\n          const {\n            margin,\n            rowHeight\n          } = this.props;\n          const bottomBoundary = offsetParent.clientHeight - (0, _calculateUtils.calcGridItemWHPx)(h, rowHeight, margin[1]);\n          top = (0, _calculateUtils.clamp)(top, 0, bottomBoundary);\n          const colWidth = (0, _calculateUtils.calcGridColWidth)(positionParams);\n          const rightBoundary = containerWidth - (0, _calculateUtils.calcGridItemWHPx)(w, colWidth, margin[0]);\n          left = (0, _calculateUtils.clamp)(left, 0, rightBoundary);\n        }\n      }\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n\n      // dontFlush is set if we're calling from inside\n      if (dontFlush) {\n        this.setState({\n          dragging: newPosition\n        });\n      } else {\n        (0, _reactDom.flushSync)(() => {\n          this.setState({\n            dragging: newPosition\n          });\n        });\n      }\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(positionParams, top, left, w, h);\n      return onDrag.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDragStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStop\", (e, _ref3) => {\n      let {\n        node\n      } = _ref3;\n      const {\n        onDragStop\n      } = this.props;\n      if (!onDragStop) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDragEnd called before onDragStart.\");\n      }\n      const {\n        w,\n        h,\n        i\n      } = this.props;\n      const {\n        left,\n        top\n      } = this.state.dragging;\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n      this.setState({\n        dragging: null\n      });\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), top, left, w, h);\n      return onDragStop.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onResizeStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    _defineProperty(this, \"onResizeStop\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStop\"));\n    // onResizeStart event handler\n    _defineProperty(this, \"onResizeStart\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStart\"));\n    // onResize event handler\n    _defineProperty(this, \"onResize\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResize\"));\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    // We can't deeply compare children. If the developer memoizes them, we can\n    // use this optimization.\n    if (this.props.children !== nextProps.children) return true;\n    if (this.props.droppingPosition !== nextProps.droppingPosition) return true;\n    // TODO memoize these calculations so they don't take so long?\n    const oldPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(this.props), this.props.x, this.props.y, this.props.w, this.props.h, this.state);\n    const newPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(nextProps), nextProps.x, nextProps.y, nextProps.w, nextProps.h, nextState);\n    return !(0, _utils.fastPositionEqual)(oldPosition, newPosition) || this.props.useCSSTransforms !== nextProps.useCSSTransforms;\n  }\n  componentDidMount() {\n    this.moveDroppingItem({});\n  }\n  componentDidUpdate(prevProps /*: Props*/) {\n    this.moveDroppingItem(prevProps);\n  }\n\n  // When a droppingPosition is present, this means we should fire a move event, as if we had moved\n  // this element by `x, y` pixels.\n  moveDroppingItem(prevProps /*: Props*/) {\n    const {\n      droppingPosition\n    } = this.props;\n    if (!droppingPosition) return;\n    const node = this.elementRef.current;\n    // Can't find DOM node (are we unmounted?)\n    if (!node) return;\n    const prevDroppingPosition = prevProps.droppingPosition || {\n      left: 0,\n      top: 0\n    };\n    const {\n      dragging\n    } = this.state;\n    const shouldDrag = dragging && droppingPosition.left !== prevDroppingPosition.left || droppingPosition.top !== prevDroppingPosition.top;\n    if (!dragging) {\n      this.onDragStart(droppingPosition.e, {\n        node,\n        deltaX: droppingPosition.left,\n        deltaY: droppingPosition.top\n      });\n    } else if (shouldDrag) {\n      const deltaX = droppingPosition.left - dragging.left;\n      const deltaY = droppingPosition.top - dragging.top;\n      this.onDrag(droppingPosition.e, {\n        node,\n        deltaX,\n        deltaY\n      }, true // dontFLush: avoid flushSync to temper warnings\n      );\n    }\n  }\n  getPositionParams() /*: PositionParams*/{\n    let props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    return {\n      cols: props.cols,\n      containerPadding: props.containerPadding,\n      containerWidth: props.containerWidth,\n      margin: props.margin,\n      maxRows: props.maxRows,\n      rowHeight: props.rowHeight\n    };\n  }\n\n  /**\n   * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it\n   * well when server rendering, and the only way to do that properly is to use percentage width/left because\n   * we don't know exactly what the browser viewport is.\n   * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage\n   * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.\n   *\n   * @param  {Object} pos Position object with width, height, left, top.\n   * @return {Object}     Style object.\n   */\n  createStyle(pos /*: Position*/) /*: { [key: string]: ?string }*/{\n    const {\n      usePercentages,\n      containerWidth,\n      useCSSTransforms\n    } = this.props;\n    let style;\n    // CSS Transforms support (default)\n    if (useCSSTransforms) {\n      style = (0, _utils.setTransform)(pos);\n    } else {\n      // top,left (slow)\n      style = (0, _utils.setTopLeft)(pos);\n\n      // This is used for server rendering.\n      if (usePercentages) {\n        style.left = (0, _utils.perc)(pos.left / containerWidth);\n        style.width = (0, _utils.perc)(pos.width / containerWidth);\n      }\n    }\n    return style;\n  }\n\n  /**\n   * Mix a Draggable instance into a child.\n   * @param  {Element} child    Child element.\n   * @return {Element}          Child wrapped in Draggable.\n   */\n  mixinDraggable(child /*: ReactElement<any>*/, isDraggable /*: boolean*/) /*: ReactElement<any>*/{\n    return /*#__PURE__*/_react.default.createElement(_reactDraggable.DraggableCore, {\n      disabled: !isDraggable,\n      onStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onStop: this.onDragStop,\n      handle: this.props.handle,\n      cancel: \".react-resizable-handle\" + (this.props.cancel ? \",\" + this.props.cancel : \"\"),\n      scale: this.props.transformScale,\n      nodeRef: this.elementRef\n    }, child);\n  }\n\n  /**\n   * Utility function to setup callback handler definitions for\n   * similarily structured resize events.\n   */\n  curryResizeHandler(position /*: Position*/, handler /*: Function*/) /*: Function*/{\n    return (e /*: Event*/, data /*: ResizeCallbackData*/) => /*: Function*/handler(e, data, position);\n  }\n\n  /**\n   * Mix a Resizable instance into a child.\n   * @param  {Element} child    Child element.\n   * @param  {Object} position  Position object (pixel values)\n   * @return {Element}          Child wrapped in Resizable.\n   */\n  mixinResizable(child /*: ReactElement<any>*/, position /*: Position*/, isResizable /*: boolean*/) /*: ReactElement<any>*/{\n    const {\n      cols,\n      minW,\n      minH,\n      maxW,\n      maxH,\n      transformScale,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const positionParams = this.getPositionParams();\n\n    // This is the max possible width - doesn't go to infinity because of the width of the window\n    const maxWidth = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, cols, 0).width;\n\n    // Calculate min/max constraints using our min & maxes\n    const mins = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, minW, minH);\n    const maxes = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, maxW, maxH);\n    const minConstraints = [mins.width, mins.height];\n    const maxConstraints = [Math.min(maxes.width, maxWidth), Math.min(maxes.height, Infinity)];\n    return /*#__PURE__*/_react.default.createElement(_reactResizable.Resizable\n    // These are opts for the resize handle itself\n    , {\n      draggableOpts: {\n        disabled: !isResizable\n      },\n      className: isResizable ? undefined : \"react-resizable-hide\",\n      width: position.width,\n      height: position.height,\n      minConstraints: minConstraints,\n      maxConstraints: maxConstraints,\n      onResizeStop: this.curryResizeHandler(position, this.onResizeStop),\n      onResizeStart: this.curryResizeHandler(position, this.onResizeStart),\n      onResize: this.curryResizeHandler(position, this.onResize),\n      transformScale: transformScale,\n      resizeHandles: resizeHandles,\n      handle: resizeHandle\n    }, child);\n  }\n  /**\n   * Wrapper around resize events to provide more useful data.\n   */\n  onResizeHandler(e /*: Event*/, _ref4 /*:: */,\n  // 'size' is updated position\n  position /*: Position*/,\n  // existing position\n  handlerName /*: string*/) /*: void*/{\n    let {\n      node,\n      size,\n      handle\n    } /*: ResizeCallbackData*/ = _ref4 /*: ResizeCallbackData*/;\n    const handler = this.props[handlerName];\n    if (!handler) return;\n    const {\n      x,\n      y,\n      i,\n      maxH,\n      minH,\n      containerWidth\n    } = this.props;\n    const {\n      minW,\n      maxW\n    } = this.props;\n\n    // Clamping of dimensions based on resize direction\n    let updatedSize = size;\n    if (node) {\n      updatedSize = (0, _utils.resizeItemInDirection)(handle, position, size, containerWidth);\n      (0, _reactDom.flushSync)(() => {\n        this.setState({\n          resizing: handlerName === \"onResizeStop\" ? null : updatedSize\n        });\n      });\n    }\n\n    // Get new XY based on pixel size\n    let {\n      w,\n      h\n    } = (0, _calculateUtils.calcWH)(this.getPositionParams(), updatedSize.width, updatedSize.height, x, y, handle);\n\n    // Min/max capping.\n    // minW should be at least 1 (TODO propTypes validation?)\n    w = (0, _calculateUtils.clamp)(w, Math.max(minW, 1), maxW);\n    h = (0, _calculateUtils.clamp)(h, minH, maxH);\n    handler.call(this, i, w, h, {\n      e,\n      node,\n      size: updatedSize,\n      handle\n    });\n  }\n  render() /*: ReactNode*/{\n    const {\n      x,\n      y,\n      w,\n      h,\n      isDraggable,\n      isResizable,\n      droppingPosition,\n      useCSSTransforms\n    } = this.props;\n    const pos = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(), x, y, w, h, this.state);\n    const child = _react.default.Children.only(this.props.children);\n\n    // Create the child element. We clone the existing element but modify its className and style.\n    let newChild = /*#__PURE__*/_react.default.cloneElement(child, {\n      ref: this.elementRef,\n      className: (0, _clsx.default)(\"react-grid-item\", child.props.className, this.props.className, {\n        static: this.props.static,\n        resizing: Boolean(this.state.resizing),\n        \"react-draggable\": isDraggable,\n        \"react-draggable-dragging\": Boolean(this.state.dragging),\n        dropping: Boolean(droppingPosition),\n        cssTransforms: useCSSTransforms\n      }),\n      // We can set the width and height on the child, but unfortunately we can't set the position.\n      style: {\n        ...this.props.style,\n        ...child.props.style,\n        ...this.createStyle(pos)\n      }\n    });\n\n    // Resizable support. This is usually on but the user can toggle it off.\n    newChild = this.mixinResizable(newChild, pos, isResizable);\n\n    // Draggable support. This is always on, except for with placeholders.\n    newChild = this.mixinDraggable(newChild, isDraggable);\n    return newChild;\n  }\n}\nexports[\"default\"] = GridItem;\n_defineProperty(GridItem, \"propTypes\", {\n  // Children must be only a single element\n  children: _propTypes.default.element,\n  // General grid attributes\n  cols: _propTypes.default.number.isRequired,\n  containerWidth: _propTypes.default.number.isRequired,\n  rowHeight: _propTypes.default.number.isRequired,\n  margin: _propTypes.default.array.isRequired,\n  maxRows: _propTypes.default.number.isRequired,\n  containerPadding: _propTypes.default.array.isRequired,\n  // These are all in grid units\n  x: _propTypes.default.number.isRequired,\n  y: _propTypes.default.number.isRequired,\n  w: _propTypes.default.number.isRequired,\n  h: _propTypes.default.number.isRequired,\n  // All optional\n  minW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minWidth not Number\");\n    if (value > props.w || value > props.maxW) return new Error(\"minWidth larger than item width/maxWidth\");\n  },\n  maxW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxWidth not Number\");\n    if (value < props.w || value < props.minW) return new Error(\"maxWidth smaller than item width/minWidth\");\n  },\n  minH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minHeight not Number\");\n    if (value > props.h || value > props.maxH) return new Error(\"minHeight larger than item height/maxHeight\");\n  },\n  maxH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxHeight not Number\");\n    if (value < props.h || value < props.minH) return new Error(\"maxHeight smaller than item height/minHeight\");\n  },\n  // ID is nice to have for callbacks\n  i: _propTypes.default.string.isRequired,\n  // Resize handle options\n  resizeHandles: _ReactGridLayoutPropTypes.resizeHandleAxesType,\n  resizeHandle: _ReactGridLayoutPropTypes.resizeHandleType,\n  // Functions\n  onDragStop: _propTypes.default.func,\n  onDragStart: _propTypes.default.func,\n  onDrag: _propTypes.default.func,\n  onResizeStop: _propTypes.default.func,\n  onResizeStart: _propTypes.default.func,\n  onResize: _propTypes.default.func,\n  // Flags\n  isDraggable: _propTypes.default.bool.isRequired,\n  isResizable: _propTypes.default.bool.isRequired,\n  isBounded: _propTypes.default.bool.isRequired,\n  static: _propTypes.default.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: _propTypes.default.bool.isRequired,\n  transformScale: _propTypes.default.number,\n  // Others\n  className: _propTypes.default.string,\n  // Selector for draggable handle\n  handle: _propTypes.default.string,\n  // Selector for draggable cancel (see react-draggable)\n  cancel: _propTypes.default.string,\n  // Current position of a dropping element\n  droppingPosition: _propTypes.default.shape({\n    e: _propTypes.default.object.isRequired,\n    left: _propTypes.default.number.isRequired,\n    top: _propTypes.default.number.isRequired\n  })\n});\n_defineProperty(GridItem, \"defaultProps\", {\n  className: \"\",\n  cancel: \"\",\n  handle: \"\",\n  minH: 1,\n  minW: 1,\n  maxH: Infinity,\n  maxW: Infinity,\n  transformScale: 1\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvR3JpZEl0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixvQ0FBb0MsbUJBQU8sQ0FBQyx3R0FBTztBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxnSEFBVztBQUNuQyx3Q0FBd0MsbUJBQU8sQ0FBQyw0REFBWTtBQUM1RCxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMsc0VBQWlCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxzRUFBUztBQUM5QixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDaEQsZ0NBQWdDLG1CQUFPLENBQUMsNEdBQTRCO0FBQ3BFLG1DQUFtQyxtQkFBTyxDQUFDLG9EQUFNO0FBQ2pELHFDQUFxQyxpQ0FBaUM7QUFDdEUsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsbUJBQW1CLDZDQUE2QyxhQUFhO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxlQUFlO0FBQ2pCLG1CQUFtQixpQkFBaUIsd0JBQXdCO0FBQzVELG1CQUFtQix5QkFBeUIsa0NBQWtDO0FBQzlFLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGVBQWUsMERBQTBEO0FBQ3pFLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCO0FBQ0Esd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0b2NrbWFzdGVyLWltcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9HcmlkSXRlbS5qcz9jNWMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcmVhY3REb20gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfcmVhY3REcmFnZ2FibGUgPSByZXF1aXJlKFwicmVhY3QtZHJhZ2dhYmxlXCIpO1xudmFyIF9yZWFjdFJlc2l6YWJsZSA9IHJlcXVpcmUoXCJyZWFjdC1yZXNpemFibGVcIik7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgX2NhbGN1bGF0ZVV0aWxzID0gcmVxdWlyZShcIi4vY2FsY3VsYXRlVXRpbHNcIik7XG52YXIgX1JlYWN0R3JpZExheW91dFByb3BUeXBlcyA9IHJlcXVpcmUoXCIuL1JlYWN0R3JpZExheW91dFByb3BUeXBlc1wiKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLyo6OiBpbXBvcnQgdHlwZSB7IEVsZW1lbnQgYXMgUmVhY3RFbGVtZW50LCBOb2RlIGFzIFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiOyovXG4vKjo6IGltcG9ydCB0eXBlIHtcbiAgUmVhY3REcmFnZ2FibGVDYWxsYmFja0RhdGEsXG4gIEdyaWREcmFnRXZlbnQsXG4gIEdyaWRSZXNpemVFdmVudCxcbiAgRHJvcHBpbmdQb3NpdGlvbixcbiAgUG9zaXRpb24sXG4gIFJlc2l6ZUhhbmRsZUF4aXNcbn0gZnJvbSBcIi4vdXRpbHNcIjsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7IFBvc2l0aW9uUGFyYW1zIH0gZnJvbSBcIi4vY2FsY3VsYXRlVXRpbHNcIjsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7IFJlc2l6ZUhhbmRsZSwgUmVhY3RSZWYgfSBmcm9tIFwiLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIjsqL1xuLyo6OiB0eXBlIFBhcnRpYWxQb3NpdGlvbiA9IHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9OyovXG4vKjo6IHR5cGUgR3JpZEl0ZW1DYWxsYmFjazxEYXRhOiBHcmlkRHJhZ0V2ZW50IHwgR3JpZFJlc2l6ZUV2ZW50PiA9IChcbiAgaTogc3RyaW5nLFxuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcbiAgRGF0YVxuKSA9PiB2b2lkOyovXG4vKjo6IHR5cGUgUmVzaXplQ2FsbGJhY2tEYXRhID0ge1xuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgc2l6ZTogUG9zaXRpb24sXG4gIGhhbmRsZTogUmVzaXplSGFuZGxlQXhpc1xufTsqL1xuLyo6OiB0eXBlIEdyaWRJdGVtUmVzaXplQ2FsbGJhY2sgPSAoXG4gIGU6IEV2ZW50LFxuICBkYXRhOiBSZXNpemVDYWxsYmFja0RhdGEsXG4gIHBvc2l0aW9uOiBQb3NpdGlvblxuKSA9PiB2b2lkOyovXG4vKjo6IHR5cGUgU3RhdGUgPSB7XG4gIHJlc2l6aW5nOiA/eyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9LFxuICBkcmFnZ2luZzogP3sgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9LFxuICBjbGFzc05hbWU6IHN0cmluZ1xufTsqL1xuLyo6OiB0eXBlIFByb3BzID0ge1xuICBjaGlsZHJlbjogUmVhY3RFbGVtZW50PGFueT4sXG4gIGNvbHM6IG51bWJlcixcbiAgY29udGFpbmVyV2lkdGg6IG51bWJlcixcbiAgbWFyZ2luOiBbbnVtYmVyLCBudW1iZXJdLFxuICBjb250YWluZXJQYWRkaW5nOiBbbnVtYmVyLCBudW1iZXJdLFxuICByb3dIZWlnaHQ6IG51bWJlcixcbiAgbWF4Um93czogbnVtYmVyLFxuICBpc0RyYWdnYWJsZTogYm9vbGVhbixcbiAgaXNSZXNpemFibGU6IGJvb2xlYW4sXG4gIGlzQm91bmRlZDogYm9vbGVhbixcbiAgc3RhdGljPzogYm9vbGVhbixcbiAgdXNlQ1NTVHJhbnNmb3Jtcz86IGJvb2xlYW4sXG4gIHVzZVBlcmNlbnRhZ2VzPzogYm9vbGVhbixcbiAgdHJhbnNmb3JtU2NhbGU6IG51bWJlcixcbiAgZHJvcHBpbmdQb3NpdGlvbj86IERyb3BwaW5nUG9zaXRpb24sXG5cbiAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gIHN0eWxlPzogT2JqZWN0LFxuICAvLyBEcmFnZ2FiaWxpdHlcbiAgY2FuY2VsOiBzdHJpbmcsXG4gIGhhbmRsZTogc3RyaW5nLFxuXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcblxuICBtaW5XOiBudW1iZXIsXG4gIG1heFc6IG51bWJlcixcbiAgbWluSDogbnVtYmVyLFxuICBtYXhIOiBudW1iZXIsXG4gIGk6IHN0cmluZyxcblxuICByZXNpemVIYW5kbGVzPzogUmVzaXplSGFuZGxlQXhpc1tdLFxuICByZXNpemVIYW5kbGU/OiBSZXNpemVIYW5kbGUsXG5cbiAgb25EcmFnPzogR3JpZEl0ZW1DYWxsYmFjazxHcmlkRHJhZ0V2ZW50PixcbiAgb25EcmFnU3RhcnQ/OiBHcmlkSXRlbUNhbGxiYWNrPEdyaWREcmFnRXZlbnQ+LFxuICBvbkRyYWdTdG9wPzogR3JpZEl0ZW1DYWxsYmFjazxHcmlkRHJhZ0V2ZW50PixcbiAgb25SZXNpemU/OiBHcmlkSXRlbUNhbGxiYWNrPEdyaWRSZXNpemVFdmVudD4sXG4gIG9uUmVzaXplU3RhcnQ/OiBHcmlkSXRlbUNhbGxiYWNrPEdyaWRSZXNpemVFdmVudD4sXG4gIG9uUmVzaXplU3RvcD86IEdyaWRJdGVtQ2FsbGJhY2s8R3JpZFJlc2l6ZUV2ZW50PlxufTsqL1xuLyo6OiB0eXBlIERlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gIGNhbmNlbDogc3RyaW5nLFxuICBoYW5kbGU6IHN0cmluZyxcbiAgbWluSDogbnVtYmVyLFxuICBtaW5XOiBudW1iZXIsXG4gIG1heEg6IG51bWJlcixcbiAgbWF4VzogbnVtYmVyLFxuICB0cmFuc2Zvcm1TY2FsZTogbnVtYmVyXG59OyovXG4vKipcbiAqIEFuIGluZGl2aWR1YWwgaXRlbSB3aXRoaW4gYSBSZWFjdEdyaWRMYXlvdXQuXG4gKi9cbmNsYXNzIEdyaWRJdGVtIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IC8qOjogPFByb3BzLCBTdGF0ZT4qL3tcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICByZXNpemluZzogbnVsbCxcbiAgICAgIGRyYWdnaW5nOiBudWxsLFxuICAgICAgY2xhc3NOYW1lOiBcIlwiXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZWxlbWVudFJlZlwiLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlUmVmKCkpO1xuICAgIC8qKlxuICAgICAqIG9uRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gIGUgICAgICAgICAgICAgZXZlbnQgZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY2FsbGJhY2tEYXRhICBhbiBvYmplY3Qgd2l0aCBub2RlLCBkZWx0YSBhbmQgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdGFydFwiLCAoZSwgX3JlZikgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWY7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgICB0cmFuc2Zvcm1TY2FsZVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIW9uRHJhZ1N0YXJ0KSByZXR1cm47XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiAvKjogUGFydGlhbFBvc2l0aW9uKi8gPSB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfTtcblxuICAgICAgLy8gVE9ETzogdGhpcyB3b250IHdvcmsgb24gbmVzdGVkIHBhcmVudHNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0UGFyZW50XG4gICAgICB9ID0gbm9kZTtcbiAgICAgIGlmICghb2Zmc2V0UGFyZW50KSByZXR1cm47XG4gICAgICBjb25zdCBwYXJlbnRSZWN0ID0gb2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY2xpZW50UmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjTGVmdCA9IGNsaWVudFJlY3QubGVmdCAvIHRyYW5zZm9ybVNjYWxlO1xuICAgICAgY29uc3QgcExlZnQgPSBwYXJlbnRSZWN0LmxlZnQgLyB0cmFuc2Zvcm1TY2FsZTtcbiAgICAgIGNvbnN0IGNUb3AgPSBjbGllbnRSZWN0LnRvcCAvIHRyYW5zZm9ybVNjYWxlO1xuICAgICAgY29uc3QgcFRvcCA9IHBhcmVudFJlY3QudG9wIC8gdHJhbnNmb3JtU2NhbGU7XG4gICAgICBuZXdQb3NpdGlvbi5sZWZ0ID0gY0xlZnQgLSBwTGVmdCArIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgbmV3UG9zaXRpb24udG9wID0gY1RvcCAtIHBUb3AgKyBvZmZzZXRQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdnaW5nOiBuZXdQb3NpdGlvblxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGwgY2FsbGJhY2sgd2l0aCB0aGlzIGRhdGFcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY1hZKSh0aGlzLmdldFBvc2l0aW9uUGFyYW1zKCksIG5ld1Bvc2l0aW9uLnRvcCwgbmV3UG9zaXRpb24ubGVmdCwgdGhpcy5wcm9wcy53LCB0aGlzLnByb3BzLmgpO1xuICAgICAgcmV0dXJuIG9uRHJhZ1N0YXJ0LmNhbGwodGhpcywgdGhpcy5wcm9wcy5pLCB4LCB5LCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5ld1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBvbkRyYWcgZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSAge0V2ZW50fSAgZSAgICAgICAgICAgICBldmVudCBkYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjYWxsYmFja0RhdGEgIGFuIG9iamVjdCB3aXRoIG5vZGUsIGRlbHRhIGFuZCBwb3NpdGlvbiBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGRvbnRGbHVzaCAgICBpZiB0cnVlLCB3aWxsIG5vdCBjYWxsIGZsdXNoU3luY1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1wiLCAoZSwgX3JlZjIsIGRvbnRGbHVzaCkgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZGVsdGFYLFxuICAgICAgICBkZWx0YVlcbiAgICAgIH0gPSBfcmVmMjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25EcmFnXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICghb25EcmFnKSByZXR1cm47XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuZHJhZ2dpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25EcmFnIGNhbGxlZCBiZWZvcmUgb25EcmFnU3RhcnQuXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHRvcCA9IHRoaXMuc3RhdGUuZHJhZ2dpbmcudG9wICsgZGVsdGFZO1xuICAgICAgbGV0IGxlZnQgPSB0aGlzLnN0YXRlLmRyYWdnaW5nLmxlZnQgKyBkZWx0YVg7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzQm91bmRlZCxcbiAgICAgICAgaSxcbiAgICAgICAgdyxcbiAgICAgICAgaCxcbiAgICAgICAgY29udGFpbmVyV2lkdGhcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgcG9zaXRpb25QYXJhbXMgPSB0aGlzLmdldFBvc2l0aW9uUGFyYW1zKCk7XG5cbiAgICAgIC8vIEJvdW5kYXJ5IGNhbGN1bGF0aW9uczsga2VlcHMgaXRlbXMgd2l0aGluIHRoZSBncmlkXG4gICAgICBpZiAoaXNCb3VuZGVkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvZmZzZXRQYXJlbnRcbiAgICAgICAgfSA9IG5vZGU7XG4gICAgICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICByb3dIZWlnaHRcbiAgICAgICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICBjb25zdCBib3R0b21Cb3VuZGFyeSA9IG9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgLSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVdIUHgpKGgsIHJvd0hlaWdodCwgbWFyZ2luWzFdKTtcbiAgICAgICAgICB0b3AgPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNsYW1wKSh0b3AsIDAsIGJvdHRvbUJvdW5kYXJ5KTtcbiAgICAgICAgICBjb25zdCBjb2xXaWR0aCA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY0dyaWRDb2xXaWR0aCkocG9zaXRpb25QYXJhbXMpO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0Qm91bmRhcnkgPSBjb250YWluZXJXaWR0aCAtICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY0dyaWRJdGVtV0hQeCkodywgY29sV2lkdGgsIG1hcmdpblswXSk7XG4gICAgICAgICAgbGVmdCA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2xhbXApKGxlZnQsIDAsIHJpZ2h0Qm91bmRhcnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiAvKjogUGFydGlhbFBvc2l0aW9uKi8gPSB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdFxuICAgICAgfTtcblxuICAgICAgLy8gZG9udEZsdXNoIGlzIHNldCBpZiB3ZSdyZSBjYWxsaW5nIGZyb20gaW5zaWRlXG4gICAgICBpZiAoZG9udEZsdXNoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGRyYWdnaW5nOiBuZXdQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfcmVhY3REb20uZmx1c2hTeW5jKSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkcmFnZ2luZzogbmV3UG9zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGwgY2FsbGJhY2sgd2l0aCB0aGlzIGRhdGFcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY1hZKShwb3NpdGlvblBhcmFtcywgdG9wLCBsZWZ0LCB3LCBoKTtcbiAgICAgIHJldHVybiBvbkRyYWcuY2FsbCh0aGlzLCBpLCB4LCB5LCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5ld1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBvbkRyYWdTdG9wIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gIGUgICAgICAgICAgICAgZXZlbnQgZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY2FsbGJhY2tEYXRhICBhbiBvYmplY3Qgd2l0aCBub2RlLCBkZWx0YSBhbmQgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdG9wXCIsIChlLCBfcmVmMykgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWYzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbkRyYWdTdG9wXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICghb25EcmFnU3RvcCkgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRyYWdnaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uRHJhZ0VuZCBjYWxsZWQgYmVmb3JlIG9uRHJhZ1N0YXJ0LlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdyxcbiAgICAgICAgaCxcbiAgICAgICAgaVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHRvcFxuICAgICAgfSA9IHRoaXMuc3RhdGUuZHJhZ2dpbmc7XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiAvKjogUGFydGlhbFBvc2l0aW9uKi8gPSB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcmFnZ2luZzogbnVsbFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNYWSkodGhpcy5nZXRQb3NpdGlvblBhcmFtcygpLCB0b3AsIGxlZnQsIHcsIGgpO1xuICAgICAgcmV0dXJuIG9uRHJhZ1N0b3AuY2FsbCh0aGlzLCBpLCB4LCB5LCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5ld1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBvblJlc2l6ZVN0b3AgZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSAge0V2ZW50fSAgZSAgICAgICAgICAgICBldmVudCBkYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjYWxsYmFja0RhdGEgIGFuIG9iamVjdCB3aXRoIG5vZGUgYW5kIHNpemUgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVN0b3BcIiwgKGUsIGNhbGxiYWNrRGF0YSwgcG9zaXRpb24pID0+IHRoaXMub25SZXNpemVIYW5kbGVyKGUsIGNhbGxiYWNrRGF0YSwgcG9zaXRpb24sIFwib25SZXNpemVTdG9wXCIpKTtcbiAgICAvLyBvblJlc2l6ZVN0YXJ0IGV2ZW50IGhhbmRsZXJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVN0YXJ0XCIsIChlLCBjYWxsYmFja0RhdGEsIHBvc2l0aW9uKSA9PiB0aGlzLm9uUmVzaXplSGFuZGxlcihlLCBjYWxsYmFja0RhdGEsIHBvc2l0aW9uLCBcIm9uUmVzaXplU3RhcnRcIikpO1xuICAgIC8vIG9uUmVzaXplIGV2ZW50IGhhbmRsZXJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVwiLCAoZSwgY2FsbGJhY2tEYXRhLCBwb3NpdGlvbikgPT4gdGhpcy5vblJlc2l6ZUhhbmRsZXIoZSwgY2FsbGJhY2tEYXRhLCBwb3NpdGlvbiwgXCJvblJlc2l6ZVwiKSk7XG4gIH1cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcyAvKjogUHJvcHMqLywgbmV4dFN0YXRlIC8qOiBTdGF0ZSovKSAvKjogYm9vbGVhbiove1xuICAgIC8vIFdlIGNhbid0IGRlZXBseSBjb21wYXJlIGNoaWxkcmVuLiBJZiB0aGUgZGV2ZWxvcGVyIG1lbW9pemVzIHRoZW0sIHdlIGNhblxuICAgIC8vIHVzZSB0aGlzIG9wdGltaXphdGlvbi5cbiAgICBpZiAodGhpcy5wcm9wcy5jaGlsZHJlbiAhPT0gbmV4dFByb3BzLmNoaWxkcmVuKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5wcm9wcy5kcm9wcGluZ1Bvc2l0aW9uICE9PSBuZXh0UHJvcHMuZHJvcHBpbmdQb3NpdGlvbikgcmV0dXJuIHRydWU7XG4gICAgLy8gVE9ETyBtZW1vaXplIHRoZXNlIGNhbGN1bGF0aW9ucyBzbyB0aGV5IGRvbid0IHRha2Ugc28gbG9uZz9cbiAgICBjb25zdCBvbGRQb3NpdGlvbiA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY0dyaWRJdGVtUG9zaXRpb24pKHRoaXMuZ2V0UG9zaXRpb25QYXJhbXModGhpcy5wcm9wcyksIHRoaXMucHJvcHMueCwgdGhpcy5wcm9wcy55LCB0aGlzLnByb3BzLncsIHRoaXMucHJvcHMuaCwgdGhpcy5zdGF0ZSk7XG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVBvc2l0aW9uKSh0aGlzLmdldFBvc2l0aW9uUGFyYW1zKG5leHRQcm9wcyksIG5leHRQcm9wcy54LCBuZXh0UHJvcHMueSwgbmV4dFByb3BzLncsIG5leHRQcm9wcy5oLCBuZXh0U3RhdGUpO1xuICAgIHJldHVybiAhKDAsIF91dGlscy5mYXN0UG9zaXRpb25FcXVhbCkob2xkUG9zaXRpb24sIG5ld1Bvc2l0aW9uKSB8fCB0aGlzLnByb3BzLnVzZUNTU1RyYW5zZm9ybXMgIT09IG5leHRQcm9wcy51c2VDU1NUcmFuc2Zvcm1zO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW92ZURyb3BwaW5nSXRlbSh7fSk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcyAvKjogUHJvcHMqLykge1xuICAgIHRoaXMubW92ZURyb3BwaW5nSXRlbShwcmV2UHJvcHMpO1xuICB9XG5cbiAgLy8gV2hlbiBhIGRyb3BwaW5nUG9zaXRpb24gaXMgcHJlc2VudCwgdGhpcyBtZWFucyB3ZSBzaG91bGQgZmlyZSBhIG1vdmUgZXZlbnQsIGFzIGlmIHdlIGhhZCBtb3ZlZFxuICAvLyB0aGlzIGVsZW1lbnQgYnkgYHgsIHlgIHBpeGVscy5cbiAgbW92ZURyb3BwaW5nSXRlbShwcmV2UHJvcHMgLyo6IFByb3BzKi8pIHtcbiAgICBjb25zdCB7XG4gICAgICBkcm9wcGluZ1Bvc2l0aW9uXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFkcm9wcGluZ1Bvc2l0aW9uKSByZXR1cm47XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZWxlbWVudFJlZi5jdXJyZW50O1xuICAgIC8vIENhbid0IGZpbmQgRE9NIG5vZGUgKGFyZSB3ZSB1bm1vdW50ZWQ/KVxuICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgIGNvbnN0IHByZXZEcm9wcGluZ1Bvc2l0aW9uID0gcHJldlByb3BzLmRyb3BwaW5nUG9zaXRpb24gfHwge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgZHJhZ2dpbmdcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzaG91bGREcmFnID0gZHJhZ2dpbmcgJiYgZHJvcHBpbmdQb3NpdGlvbi5sZWZ0ICE9PSBwcmV2RHJvcHBpbmdQb3NpdGlvbi5sZWZ0IHx8IGRyb3BwaW5nUG9zaXRpb24udG9wICE9PSBwcmV2RHJvcHBpbmdQb3NpdGlvbi50b3A7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgdGhpcy5vbkRyYWdTdGFydChkcm9wcGluZ1Bvc2l0aW9uLmUsIHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZGVsdGFYOiBkcm9wcGluZ1Bvc2l0aW9uLmxlZnQsXG4gICAgICAgIGRlbHRhWTogZHJvcHBpbmdQb3NpdGlvbi50b3BcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkRHJhZykge1xuICAgICAgY29uc3QgZGVsdGFYID0gZHJvcHBpbmdQb3NpdGlvbi5sZWZ0IC0gZHJhZ2dpbmcubGVmdDtcbiAgICAgIGNvbnN0IGRlbHRhWSA9IGRyb3BwaW5nUG9zaXRpb24udG9wIC0gZHJhZ2dpbmcudG9wO1xuICAgICAgdGhpcy5vbkRyYWcoZHJvcHBpbmdQb3NpdGlvbi5lLCB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGRlbHRhWCxcbiAgICAgICAgZGVsdGFZXG4gICAgICB9LCB0cnVlIC8vIGRvbnRGTHVzaDogYXZvaWQgZmx1c2hTeW5jIHRvIHRlbXBlciB3YXJuaW5nc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZ2V0UG9zaXRpb25QYXJhbXMoKSAvKjogUG9zaXRpb25QYXJhbXMqL3tcbiAgICBsZXQgcHJvcHMgLyo6IFByb3BzKi8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHM6IHByb3BzLmNvbHMsXG4gICAgICBjb250YWluZXJQYWRkaW5nOiBwcm9wcy5jb250YWluZXJQYWRkaW5nLFxuICAgICAgY29udGFpbmVyV2lkdGg6IHByb3BzLmNvbnRhaW5lcldpZHRoLFxuICAgICAgbWFyZ2luOiBwcm9wcy5tYXJnaW4sXG4gICAgICBtYXhSb3dzOiBwcm9wcy5tYXhSb3dzLFxuICAgICAgcm93SGVpZ2h0OiBwcm9wcy5yb3dIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgd2hlcmUgd2Ugc2V0IHRoZSBncmlkIGl0ZW0ncyBhYnNvbHV0ZSBwbGFjZW1lbnQuIEl0IGdldHMgYSBsaXR0bGUgdHJpY2t5IGJlY2F1c2Ugd2Ugd2FudCB0byBkbyBpdFxuICAgKiB3ZWxsIHdoZW4gc2VydmVyIHJlbmRlcmluZywgYW5kIHRoZSBvbmx5IHdheSB0byBkbyB0aGF0IHByb3Blcmx5IGlzIHRvIHVzZSBwZXJjZW50YWdlIHdpZHRoL2xlZnQgYmVjYXVzZVxuICAgKiB3ZSBkb24ndCBrbm93IGV4YWN0bHkgd2hhdCB0aGUgYnJvd3NlciB2aWV3cG9ydCBpcy5cbiAgICogVW5mb3J0dW5hdGVseSwgQ1NTIFRyYW5zZm9ybXMsIHdoaWNoIGFyZSBncmVhdCBmb3IgcGVyZm9ybWFuY2UsIGJyZWFrIGluIHRoaXMgaW5zdGFuY2UgYmVjYXVzZSBhIHBlcmNlbnRhZ2VcbiAgICogbGVmdCBpcyByZWxhdGl2ZSB0byB0aGUgaXRlbSBpdHNlbGYsIG5vdCBpdHMgY29udGFpbmVyISBTbyB3ZSBjYW5ub3QgdXNlIHRoZW0gb24gdGhlIHNlcnZlciByZW5kZXJpbmcgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwb3MgUG9zaXRpb24gb2JqZWN0IHdpdGggd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICBTdHlsZSBvYmplY3QuXG4gICAqL1xuICBjcmVhdGVTdHlsZShwb3MgLyo6IFBvc2l0aW9uKi8pIC8qOiB7IFtrZXk6IHN0cmluZ106ID9zdHJpbmcgfSove1xuICAgIGNvbnN0IHtcbiAgICAgIHVzZVBlcmNlbnRhZ2VzLFxuICAgICAgY29udGFpbmVyV2lkdGgsXG4gICAgICB1c2VDU1NUcmFuc2Zvcm1zXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHN0eWxlO1xuICAgIC8vIENTUyBUcmFuc2Zvcm1zIHN1cHBvcnQgKGRlZmF1bHQpXG4gICAgaWYgKHVzZUNTU1RyYW5zZm9ybXMpIHtcbiAgICAgIHN0eWxlID0gKDAsIF91dGlscy5zZXRUcmFuc2Zvcm0pKHBvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvcCxsZWZ0IChzbG93KVxuICAgICAgc3R5bGUgPSAoMCwgX3V0aWxzLnNldFRvcExlZnQpKHBvcyk7XG5cbiAgICAgIC8vIFRoaXMgaXMgdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIGlmICh1c2VQZXJjZW50YWdlcykge1xuICAgICAgICBzdHlsZS5sZWZ0ID0gKDAsIF91dGlscy5wZXJjKShwb3MubGVmdCAvIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgc3R5bGUud2lkdGggPSAoMCwgX3V0aWxzLnBlcmMpKHBvcy53aWR0aCAvIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1peCBhIERyYWdnYWJsZSBpbnN0YW5jZSBpbnRvIGEgY2hpbGQuXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGNoaWxkICAgIENoaWxkIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9ICAgICAgICAgIENoaWxkIHdyYXBwZWQgaW4gRHJhZ2dhYmxlLlxuICAgKi9cbiAgbWl4aW5EcmFnZ2FibGUoY2hpbGQgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki8sIGlzRHJhZ2dhYmxlIC8qOiBib29sZWFuKi8pIC8qOiBSZWFjdEVsZW1lbnQ8YW55Piove1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3REcmFnZ2FibGUuRHJhZ2dhYmxlQ29yZSwge1xuICAgICAgZGlzYWJsZWQ6ICFpc0RyYWdnYWJsZSxcbiAgICAgIG9uU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQsXG4gICAgICBvbkRyYWc6IHRoaXMub25EcmFnLFxuICAgICAgb25TdG9wOiB0aGlzLm9uRHJhZ1N0b3AsXG4gICAgICBoYW5kbGU6IHRoaXMucHJvcHMuaGFuZGxlLFxuICAgICAgY2FuY2VsOiBcIi5yZWFjdC1yZXNpemFibGUtaGFuZGxlXCIgKyAodGhpcy5wcm9wcy5jYW5jZWwgPyBcIixcIiArIHRoaXMucHJvcHMuY2FuY2VsIDogXCJcIiksXG4gICAgICBzY2FsZTogdGhpcy5wcm9wcy50cmFuc2Zvcm1TY2FsZSxcbiAgICAgIG5vZGVSZWY6IHRoaXMuZWxlbWVudFJlZlxuICAgIH0sIGNoaWxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIHNldHVwIGNhbGxiYWNrIGhhbmRsZXIgZGVmaW5pdGlvbnMgZm9yXG4gICAqIHNpbWlsYXJpbHkgc3RydWN0dXJlZCByZXNpemUgZXZlbnRzLlxuICAgKi9cbiAgY3VycnlSZXNpemVIYW5kbGVyKHBvc2l0aW9uIC8qOiBQb3NpdGlvbiovLCBoYW5kbGVyIC8qOiBGdW5jdGlvbiovKSAvKjogRnVuY3Rpb24qL3tcbiAgICByZXR1cm4gKGUgLyo6IEV2ZW50Ki8sIGRhdGEgLyo6IFJlc2l6ZUNhbGxiYWNrRGF0YSovKSA9PiAvKjogRnVuY3Rpb24qL2hhbmRsZXIoZSwgZGF0YSwgcG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1peCBhIFJlc2l6YWJsZSBpbnN0YW5jZSBpbnRvIGEgY2hpbGQuXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGNoaWxkICAgIENoaWxkIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gcG9zaXRpb24gIFBvc2l0aW9uIG9iamVjdCAocGl4ZWwgdmFsdWVzKVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSAgICAgICAgICBDaGlsZCB3cmFwcGVkIGluIFJlc2l6YWJsZS5cbiAgICovXG4gIG1peGluUmVzaXphYmxlKGNoaWxkIC8qOiBSZWFjdEVsZW1lbnQ8YW55PiovLCBwb3NpdGlvbiAvKjogUG9zaXRpb24qLywgaXNSZXNpemFibGUgLyo6IGJvb2xlYW4qLykgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki97XG4gICAgY29uc3Qge1xuICAgICAgY29scyxcbiAgICAgIG1pblcsXG4gICAgICBtaW5ILFxuICAgICAgbWF4VyxcbiAgICAgIG1heEgsXG4gICAgICB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgIHJlc2l6ZUhhbmRsZXMsXG4gICAgICByZXNpemVIYW5kbGVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBwb3NpdGlvblBhcmFtcyA9IHRoaXMuZ2V0UG9zaXRpb25QYXJhbXMoKTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIG1heCBwb3NzaWJsZSB3aWR0aCAtIGRvZXNuJ3QgZ28gdG8gaW5maW5pdHkgYmVjYXVzZSBvZiB0aGUgd2lkdGggb2YgdGhlIHdpbmRvd1xuICAgIGNvbnN0IG1heFdpZHRoID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1Qb3NpdGlvbikocG9zaXRpb25QYXJhbXMsIDAsIDAsIGNvbHMsIDApLndpZHRoO1xuXG4gICAgLy8gQ2FsY3VsYXRlIG1pbi9tYXggY29uc3RyYWludHMgdXNpbmcgb3VyIG1pbiAmIG1heGVzXG4gICAgY29uc3QgbWlucyA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY0dyaWRJdGVtUG9zaXRpb24pKHBvc2l0aW9uUGFyYW1zLCAwLCAwLCBtaW5XLCBtaW5IKTtcbiAgICBjb25zdCBtYXhlcyA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY0dyaWRJdGVtUG9zaXRpb24pKHBvc2l0aW9uUGFyYW1zLCAwLCAwLCBtYXhXLCBtYXhIKTtcbiAgICBjb25zdCBtaW5Db25zdHJhaW50cyA9IFttaW5zLndpZHRoLCBtaW5zLmhlaWdodF07XG4gICAgY29uc3QgbWF4Q29uc3RyYWludHMgPSBbTWF0aC5taW4obWF4ZXMud2lkdGgsIG1heFdpZHRoKSwgTWF0aC5taW4obWF4ZXMuaGVpZ2h0LCBJbmZpbml0eSldO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3RSZXNpemFibGUuUmVzaXphYmxlXG4gICAgLy8gVGhlc2UgYXJlIG9wdHMgZm9yIHRoZSByZXNpemUgaGFuZGxlIGl0c2VsZlxuICAgICwge1xuICAgICAgZHJhZ2dhYmxlT3B0czoge1xuICAgICAgICBkaXNhYmxlZDogIWlzUmVzaXphYmxlXG4gICAgICB9LFxuICAgICAgY2xhc3NOYW1lOiBpc1Jlc2l6YWJsZSA/IHVuZGVmaW5lZCA6IFwicmVhY3QtcmVzaXphYmxlLWhpZGVcIixcbiAgICAgIHdpZHRoOiBwb3NpdGlvbi53aWR0aCxcbiAgICAgIGhlaWdodDogcG9zaXRpb24uaGVpZ2h0LFxuICAgICAgbWluQ29uc3RyYWludHM6IG1pbkNvbnN0cmFpbnRzLFxuICAgICAgbWF4Q29uc3RyYWludHM6IG1heENvbnN0cmFpbnRzLFxuICAgICAgb25SZXNpemVTdG9wOiB0aGlzLmN1cnJ5UmVzaXplSGFuZGxlcihwb3NpdGlvbiwgdGhpcy5vblJlc2l6ZVN0b3ApLFxuICAgICAgb25SZXNpemVTdGFydDogdGhpcy5jdXJyeVJlc2l6ZUhhbmRsZXIocG9zaXRpb24sIHRoaXMub25SZXNpemVTdGFydCksXG4gICAgICBvblJlc2l6ZTogdGhpcy5jdXJyeVJlc2l6ZUhhbmRsZXIocG9zaXRpb24sIHRoaXMub25SZXNpemUpLFxuICAgICAgdHJhbnNmb3JtU2NhbGU6IHRyYW5zZm9ybVNjYWxlLFxuICAgICAgcmVzaXplSGFuZGxlczogcmVzaXplSGFuZGxlcyxcbiAgICAgIGhhbmRsZTogcmVzaXplSGFuZGxlXG4gICAgfSwgY2hpbGQpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcGVyIGFyb3VuZCByZXNpemUgZXZlbnRzIHRvIHByb3ZpZGUgbW9yZSB1c2VmdWwgZGF0YS5cbiAgICovXG4gIG9uUmVzaXplSGFuZGxlcihlIC8qOiBFdmVudCovLCBfcmVmNCAvKjo6ICovLFxuICAvLyAnc2l6ZScgaXMgdXBkYXRlZCBwb3NpdGlvblxuICBwb3NpdGlvbiAvKjogUG9zaXRpb24qLyxcbiAgLy8gZXhpc3RpbmcgcG9zaXRpb25cbiAgaGFuZGxlck5hbWUgLyo6IHN0cmluZyovKSAvKjogdm9pZCove1xuICAgIGxldCB7XG4gICAgICBub2RlLFxuICAgICAgc2l6ZSxcbiAgICAgIGhhbmRsZVxuICAgIH0gLyo6IFJlc2l6ZUNhbGxiYWNrRGF0YSovID0gX3JlZjQgLyo6IFJlc2l6ZUNhbGxiYWNrRGF0YSovO1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLnByb3BzW2hhbmRsZXJOYW1lXTtcbiAgICBpZiAoIWhhbmRsZXIpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGksXG4gICAgICBtYXhILFxuICAgICAgbWluSCxcbiAgICAgIGNvbnRhaW5lcldpZHRoXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgbWluVyxcbiAgICAgIG1heFdcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIENsYW1waW5nIG9mIGRpbWVuc2lvbnMgYmFzZWQgb24gcmVzaXplIGRpcmVjdGlvblxuICAgIGxldCB1cGRhdGVkU2l6ZSA9IHNpemU7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHVwZGF0ZWRTaXplID0gKDAsIF91dGlscy5yZXNpemVJdGVtSW5EaXJlY3Rpb24pKGhhbmRsZSwgcG9zaXRpb24sIHNpemUsIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICgwLCBfcmVhY3REb20uZmx1c2hTeW5jKSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHJlc2l6aW5nOiBoYW5kbGVyTmFtZSA9PT0gXCJvblJlc2l6ZVN0b3BcIiA/IG51bGwgOiB1cGRhdGVkU2l6ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdldCBuZXcgWFkgYmFzZWQgb24gcGl4ZWwgc2l6ZVxuICAgIGxldCB7XG4gICAgICB3LFxuICAgICAgaFxuICAgIH0gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNXSCkodGhpcy5nZXRQb3NpdGlvblBhcmFtcygpLCB1cGRhdGVkU2l6ZS53aWR0aCwgdXBkYXRlZFNpemUuaGVpZ2h0LCB4LCB5LCBoYW5kbGUpO1xuXG4gICAgLy8gTWluL21heCBjYXBwaW5nLlxuICAgIC8vIG1pblcgc2hvdWxkIGJlIGF0IGxlYXN0IDEgKFRPRE8gcHJvcFR5cGVzIHZhbGlkYXRpb24/KVxuICAgIHcgPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNsYW1wKSh3LCBNYXRoLm1heChtaW5XLCAxKSwgbWF4Vyk7XG4gICAgaCA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2xhbXApKGgsIG1pbkgsIG1heEgpO1xuICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBpLCB3LCBoLCB7XG4gICAgICBlLFxuICAgICAgbm9kZSxcbiAgICAgIHNpemU6IHVwZGF0ZWRTaXplLFxuICAgICAgaGFuZGxlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkgLyo6IFJlYWN0Tm9kZSove1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgdyxcbiAgICAgIGgsXG4gICAgICBpc0RyYWdnYWJsZSxcbiAgICAgIGlzUmVzaXphYmxlLFxuICAgICAgZHJvcHBpbmdQb3NpdGlvbixcbiAgICAgIHVzZUNTU1RyYW5zZm9ybXNcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBwb3MgPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVBvc2l0aW9uKSh0aGlzLmdldFBvc2l0aW9uUGFyYW1zKCksIHgsIHksIHcsIGgsIHRoaXMuc3RhdGUpO1xuICAgIGNvbnN0IGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgY2hpbGQgZWxlbWVudC4gV2UgY2xvbmUgdGhlIGV4aXN0aW5nIGVsZW1lbnQgYnV0IG1vZGlmeSBpdHMgY2xhc3NOYW1lIGFuZCBzdHlsZS5cbiAgICBsZXQgbmV3Q2hpbGQgPSAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICByZWY6IHRoaXMuZWxlbWVudFJlZixcbiAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4LmRlZmF1bHQpKFwicmVhY3QtZ3JpZC1pdGVtXCIsIGNoaWxkLnByb3BzLmNsYXNzTmFtZSwgdGhpcy5wcm9wcy5jbGFzc05hbWUsIHtcbiAgICAgICAgc3RhdGljOiB0aGlzLnByb3BzLnN0YXRpYyxcbiAgICAgICAgcmVzaXppbmc6IEJvb2xlYW4odGhpcy5zdGF0ZS5yZXNpemluZyksXG4gICAgICAgIFwicmVhY3QtZHJhZ2dhYmxlXCI6IGlzRHJhZ2dhYmxlLFxuICAgICAgICBcInJlYWN0LWRyYWdnYWJsZS1kcmFnZ2luZ1wiOiBCb29sZWFuKHRoaXMuc3RhdGUuZHJhZ2dpbmcpLFxuICAgICAgICBkcm9wcGluZzogQm9vbGVhbihkcm9wcGluZ1Bvc2l0aW9uKSxcbiAgICAgICAgY3NzVHJhbnNmb3JtczogdXNlQ1NTVHJhbnNmb3Jtc1xuICAgICAgfSksXG4gICAgICAvLyBXZSBjYW4gc2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBjaGlsZCwgYnV0IHVuZm9ydHVuYXRlbHkgd2UgY2FuJ3Qgc2V0IHRoZSBwb3NpdGlvbi5cbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIC4uLnRoaXMucHJvcHMuc3R5bGUsXG4gICAgICAgIC4uLmNoaWxkLnByb3BzLnN0eWxlLFxuICAgICAgICAuLi50aGlzLmNyZWF0ZVN0eWxlKHBvcylcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlc2l6YWJsZSBzdXBwb3J0LiBUaGlzIGlzIHVzdWFsbHkgb24gYnV0IHRoZSB1c2VyIGNhbiB0b2dnbGUgaXQgb2ZmLlxuICAgIG5ld0NoaWxkID0gdGhpcy5taXhpblJlc2l6YWJsZShuZXdDaGlsZCwgcG9zLCBpc1Jlc2l6YWJsZSk7XG5cbiAgICAvLyBEcmFnZ2FibGUgc3VwcG9ydC4gVGhpcyBpcyBhbHdheXMgb24sIGV4Y2VwdCBmb3Igd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgbmV3Q2hpbGQgPSB0aGlzLm1peGluRHJhZ2dhYmxlKG5ld0NoaWxkLCBpc0RyYWdnYWJsZSk7XG4gICAgcmV0dXJuIG5ld0NoaWxkO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBHcmlkSXRlbTtcbl9kZWZpbmVQcm9wZXJ0eShHcmlkSXRlbSwgXCJwcm9wVHlwZXNcIiwge1xuICAvLyBDaGlsZHJlbiBtdXN0IGJlIG9ubHkgYSBzaW5nbGUgZWxlbWVudFxuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0LmVsZW1lbnQsXG4gIC8vIEdlbmVyYWwgZ3JpZCBhdHRyaWJ1dGVzXG4gIGNvbHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY29udGFpbmVyV2lkdGg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgcm93SGVpZ2h0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG1hcmdpbjogX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5LmlzUmVxdWlyZWQsXG4gIG1heFJvd3M6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY29udGFpbmVyUGFkZGluZzogX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5LmlzUmVxdWlyZWQsXG4gIC8vIFRoZXNlIGFyZSBhbGwgaW4gZ3JpZCB1bml0c1xuICB4OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHk6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgdzogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICBoOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8vIEFsbCBvcHRpb25hbFxuICBtaW5XOiBmdW5jdGlvbiAocHJvcHMgLyo6IFByb3BzKi8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLykge1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHJldHVybiBuZXcgRXJyb3IoXCJtaW5XaWR0aCBub3QgTnVtYmVyXCIpO1xuICAgIGlmICh2YWx1ZSA+IHByb3BzLncgfHwgdmFsdWUgPiBwcm9wcy5tYXhXKSByZXR1cm4gbmV3IEVycm9yKFwibWluV2lkdGggbGFyZ2VyIHRoYW4gaXRlbSB3aWR0aC9tYXhXaWR0aFwiKTtcbiAgfSxcbiAgbWF4VzogZnVuY3Rpb24gKHByb3BzIC8qOiBQcm9wcyovLCBwcm9wTmFtZSAvKjogc3RyaW5nKi8pIHtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSByZXR1cm4gbmV3IEVycm9yKFwibWF4V2lkdGggbm90IE51bWJlclwiKTtcbiAgICBpZiAodmFsdWUgPCBwcm9wcy53IHx8IHZhbHVlIDwgcHJvcHMubWluVykgcmV0dXJuIG5ldyBFcnJvcihcIm1heFdpZHRoIHNtYWxsZXIgdGhhbiBpdGVtIHdpZHRoL21pbldpZHRoXCIpO1xuICB9LFxuICBtaW5IOiBmdW5jdGlvbiAocHJvcHMgLyo6IFByb3BzKi8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLykge1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHJldHVybiBuZXcgRXJyb3IoXCJtaW5IZWlnaHQgbm90IE51bWJlclwiKTtcbiAgICBpZiAodmFsdWUgPiBwcm9wcy5oIHx8IHZhbHVlID4gcHJvcHMubWF4SCkgcmV0dXJuIG5ldyBFcnJvcihcIm1pbkhlaWdodCBsYXJnZXIgdGhhbiBpdGVtIGhlaWdodC9tYXhIZWlnaHRcIik7XG4gIH0sXG4gIG1heEg6IGZ1bmN0aW9uIChwcm9wcyAvKjogUHJvcHMqLywgcHJvcE5hbWUgLyo6IHN0cmluZyovKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikgcmV0dXJuIG5ldyBFcnJvcihcIm1heEhlaWdodCBub3QgTnVtYmVyXCIpO1xuICAgIGlmICh2YWx1ZSA8IHByb3BzLmggfHwgdmFsdWUgPCBwcm9wcy5taW5IKSByZXR1cm4gbmV3IEVycm9yKFwibWF4SGVpZ2h0IHNtYWxsZXIgdGhhbiBpdGVtIGhlaWdodC9taW5IZWlnaHRcIik7XG4gIH0sXG4gIC8vIElEIGlzIG5pY2UgdG8gaGF2ZSBmb3IgY2FsbGJhY2tzXG4gIGk6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgLy8gUmVzaXplIGhhbmRsZSBvcHRpb25zXG4gIHJlc2l6ZUhhbmRsZXM6IF9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXMucmVzaXplSGFuZGxlQXhlc1R5cGUsXG4gIHJlc2l6ZUhhbmRsZTogX1JlYWN0R3JpZExheW91dFByb3BUeXBlcy5yZXNpemVIYW5kbGVUeXBlLFxuICAvLyBGdW5jdGlvbnNcbiAgb25EcmFnU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIG9uRHJhZ1N0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgb25EcmFnOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgb25SZXNpemVTdG9wOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgb25SZXNpemVTdGFydDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIG9uUmVzaXplOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gRmxhZ3NcbiAgaXNEcmFnZ2FibGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLmlzUmVxdWlyZWQsXG4gIGlzUmVzaXphYmxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbC5pc1JlcXVpcmVkLFxuICBpc0JvdW5kZWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLmlzUmVxdWlyZWQsXG4gIHN0YXRpYzogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8vIFVzZSBDU1MgdHJhbnNmb3JtcyBpbnN0ZWFkIG9mIHRvcC9sZWZ0XG4gIHVzZUNTU1RyYW5zZm9ybXM6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLmlzUmVxdWlyZWQsXG4gIHRyYW5zZm9ybVNjYWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAvLyBPdGhlcnNcbiAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICAvLyBTZWxlY3RvciBmb3IgZHJhZ2dhYmxlIGhhbmRsZVxuICBoYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8vIFNlbGVjdG9yIGZvciBkcmFnZ2FibGUgY2FuY2VsIChzZWUgcmVhY3QtZHJhZ2dhYmxlKVxuICBjYW5jZWw6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8vIEN1cnJlbnQgcG9zaXRpb24gb2YgYSBkcm9wcGluZyBlbGVtZW50XG4gIGRyb3BwaW5nUG9zaXRpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGxlZnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICB0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZFxuICB9KVxufSk7XG5fZGVmaW5lUHJvcGVydHkoR3JpZEl0ZW0sIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgY2xhc3NOYW1lOiBcIlwiLFxuICBjYW5jZWw6IFwiXCIsXG4gIGhhbmRsZTogXCJcIixcbiAgbWluSDogMSxcbiAgbWluVzogMSxcbiAgbWF4SDogSW5maW5pdHksXG4gIG1heFc6IEluZmluaXR5LFxuICB0cmFuc2Zvcm1TY2FsZTogMVxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/GridItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/ReactGridLayout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\"));\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nvar _calculateUtils = __webpack_require__(/*! ./calculateUtils */ \"(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\");\nvar _GridItem = _interopRequireDefault(__webpack_require__(/*! ./GridItem */ \"(ssr)/./node_modules/react-grid-layout/build/GridItem.js\"));\nvar _ReactGridLayoutPropTypes = _interopRequireDefault(__webpack_require__(/*! ./ReactGridLayoutPropTypes */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  CompactType,\n  GridResizeEvent,\n  GridDragEvent,\n  DragOverEvent,\n  Layout,\n  DroppingPosition,\n  LayoutItem\n} from \"./utils\";*/\n// Types\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: type State = {\n  activeDrag: ?LayoutItem,\n  layout: Layout,\n  mounted: boolean,\n  oldDragItem: ?LayoutItem,\n  oldLayout: ?Layout,\n  oldResizeItem: ?LayoutItem,\n  resizing: boolean,\n  droppingDOMNode: ?ReactElement<any>,\n  droppingPosition?: DroppingPosition,\n  // Mirrored props\n  children: ReactChildrenArray<ReactElement<any>>,\n  compactType?: CompactType,\n  propsLayout?: Layout\n};*/\n/*:: import type { Props, DefaultProps } from \"./ReactGridLayoutPropTypes\";*/\n// End Types\nconst layoutClassName = \"react-grid-layout\";\nlet isFirefox = false;\n// Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch (e) {\n  /* Ignore */\n}\n\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\nclass ReactGridLayout extends React.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      activeDrag: null,\n      layout: (0, _utils.synchronizeLayoutWithChildren)(this.props.layout, this.props.children, this.props.cols,\n      // Legacy support for verticalCompact: false\n      (0, _utils.compactType)(this.props), this.props.allowOverlap),\n      mounted: false,\n      oldDragItem: null,\n      oldLayout: null,\n      oldResizeItem: null,\n      resizing: false,\n      droppingDOMNode: null,\n      children: []\n    });\n    _defineProperty(this, \"dragEnterCounter\", 0);\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStart\", (i /*: string*/, x /*: number*/, y /*: number*/, _ref /*:: */) => {\n      let {\n        e,\n        node\n      } /*: GridDragEvent*/ = _ref /*: GridDragEvent*/;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n      this.setState({\n        oldDragItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: layout,\n        activeDrag: placeholder\n      });\n      return this.props.onDragStart(layout, l, l, null, e, node);\n    });\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDrag\", (i, x, y, _ref2) => {\n      let {\n        e,\n        node\n      } = _ref2;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        allowOverlap,\n        preventCollision\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n\n      // Move the element to the dragged location.\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n      this.setState({\n        layout: allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStop\", (i, x, y, _ref3) => {\n      let {\n        e,\n        node\n      } = _ref3;\n      if (!this.state.activeDrag) return;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Move the element here\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onDragStop(newLayout, oldDragItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldDragItem: null,\n        oldLayout: null\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    _defineProperty(this, \"onResizeStart\", (i, w, h, _ref4) => {\n      let {\n        e,\n        node\n      } = _ref4;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldResizeItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: this.state.layout,\n        resizing: true\n      });\n      this.props.onResizeStart(layout, l, l, null, e, node);\n    });\n    _defineProperty(this, \"onResize\", (i, w, h, _ref5) => {\n      let {\n        e,\n        node,\n        size,\n        handle\n      } = _ref5;\n      const {\n        oldResizeItem\n      } = this.state;\n      const {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      let shouldMoveItem = false;\n      let finalLayout;\n      let x;\n      let y;\n      const [newLayout, l] = (0, _utils.withLayoutItem)(layout, i, l => {\n        let hasCollisions;\n        x = l.x;\n        y = l.y;\n        if ([\"sw\", \"w\", \"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n          if ([\"sw\", \"nw\", \"w\"].indexOf(handle) !== -1) {\n            x = l.x + (l.w - w);\n            w = l.x !== x && x < 0 ? l.w : w;\n            x = x < 0 ? 0 : x;\n          }\n          if ([\"ne\", \"n\", \"nw\"].indexOf(handle) !== -1) {\n            y = l.y + (l.h - h);\n            h = l.y !== y && y < 0 ? l.h : h;\n            y = y < 0 ? 0 : y;\n          }\n          shouldMoveItem = true;\n        }\n\n        // Something like quad tree should be used\n        // to find collisions faster\n        if (preventCollision && !allowOverlap) {\n          const collisions = (0, _utils.getAllCollisions)(layout, {\n            ...l,\n            w,\n            h,\n            x,\n            y\n          }).filter(layoutItem => layoutItem.i !== l.i);\n          hasCollisions = collisions.length > 0;\n\n          // If we're colliding, we need adjust the placeholder.\n          if (hasCollisions) {\n            // Reset layoutItem dimensions if there were collisions\n            y = l.y;\n            h = l.h;\n            x = l.x;\n            w = l.w;\n            shouldMoveItem = false;\n          }\n        }\n        l.w = w;\n        l.h = h;\n        return l;\n      });\n\n      // Shouldn't ever happen, but typechecking makes it necessary\n      if (!l) return;\n      finalLayout = newLayout;\n      if (shouldMoveItem) {\n        // Move the element to the new position.\n        const isUserAction = true;\n        finalLayout = (0, _utils.moveElement)(newLayout, l, x, y, isUserAction, this.props.preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      }\n\n      // Create placeholder element (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        static: true,\n        i: i\n      };\n      this.props.onResize(finalLayout, oldResizeItem, l, placeholder, e, node);\n\n      // Re-compact the newLayout and set the drag placeholder.\n      this.setState({\n        layout: allowOverlap ? finalLayout : (0, _utils.compact)(finalLayout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    _defineProperty(this, \"onResizeStop\", (i, w, h, _ref6) => {\n      let {\n        e,\n        node\n      } = _ref6;\n      const {\n        layout,\n        oldResizeItem\n      } = this.state;\n      const {\n        cols,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onResizeStop(newLayout, oldResizeItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldResizeItem: null,\n        oldLayout: null,\n        resizing: false\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    // Called while dragging an element. Part of browser native drag/drop API.\n    // Native event target might be the layout itself, or an element within the layout.\n    _defineProperty(this, \"onDragOver\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n\n      // we should ignore events from layout's children in Firefox\n      // to avoid unpredictable jumping of a dropping placeholder\n      // FIXME remove this hack\n      if (isFirefox &&\n      // $FlowIgnore can't figure this out\n      !e.nativeEvent.target?.classList.contains(layoutClassName)) {\n        return false;\n      }\n      const {\n        droppingItem,\n        onDropDragOver,\n        margin,\n        cols,\n        rowHeight,\n        maxRows,\n        width,\n        containerPadding,\n        transformScale\n      } = this.props;\n      // Allow user to customize the dropping item or short-circuit the drop based on the results\n      // of the `onDragOver(e: Event)` callback.\n      const onDragOverResult = onDropDragOver?.(e);\n      if (onDragOverResult === false) {\n        if (this.state.droppingDOMNode) {\n          this.removeDroppingPlaceholder();\n        }\n        return false;\n      }\n      const finalDroppingItem = {\n        ...droppingItem,\n        ...onDragOverResult\n      };\n      const {\n        layout\n      } = this.state;\n\n      // $FlowIgnore missing def\n      const gridRect = e.currentTarget.getBoundingClientRect(); // The grid's position in the viewport\n\n      // Calculate the mouse position relative to the grid\n      const layerX = e.clientX - gridRect.left;\n      const layerY = e.clientY - gridRect.top;\n      const droppingPosition = {\n        left: layerX / transformScale,\n        top: layerY / transformScale,\n        e\n      };\n      if (!this.state.droppingDOMNode) {\n        const positionParams /*: PositionParams*/ = {\n          cols,\n          margin,\n          maxRows,\n          rowHeight,\n          containerWidth: width,\n          containerPadding: containerPadding || margin\n        };\n        const calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);\n        this.setState({\n          droppingDOMNode: /*#__PURE__*/React.createElement(\"div\", {\n            key: finalDroppingItem.i\n          }),\n          droppingPosition,\n          layout: [...layout, {\n            ...finalDroppingItem,\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            static: false,\n            isDraggable: true\n          }]\n        });\n      } else if (this.state.droppingPosition) {\n        const {\n          left,\n          top\n        } = this.state.droppingPosition;\n        const shouldUpdatePosition = left != layerX || top != layerY;\n        if (shouldUpdatePosition) {\n          this.setState({\n            droppingPosition\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"removeDroppingPlaceholder\", () => {\n      const {\n        droppingItem,\n        cols\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const newLayout = (0, _utils.compact)(layout.filter(l => l.i !== droppingItem.i), (0, _utils.compactType)(this.props), cols, this.props.allowOverlap);\n      this.setState({\n        layout: newLayout,\n        droppingDOMNode: null,\n        activeDrag: null,\n        droppingPosition: undefined\n      });\n    });\n    _defineProperty(this, \"onDragLeave\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter--;\n\n      // onDragLeave can be triggered on each layout's child.\n      // But we know that count of dragEnter and dragLeave events\n      // will be balanced after leaving the layout's container\n      // so we can increase and decrease count of dragEnter and\n      // when it'll be equal to 0 we'll remove the placeholder\n      if (this.dragEnterCounter === 0) {\n        this.removeDroppingPlaceholder();\n      }\n    });\n    _defineProperty(this, \"onDragEnter\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter++;\n    });\n    _defineProperty(this, \"onDrop\", (e /*: Event*/) => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      const {\n        droppingItem\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const item = layout.find(l => l.i === droppingItem.i);\n\n      // reset dragEnter counter on drop\n      this.dragEnterCounter = 0;\n      this.removeDroppingPlaceholder();\n      this.props.onDrop(layout, item, e);\n    });\n  }\n  componentDidMount() {\n    this.setState({\n      mounted: true\n    });\n    // Possibly call back with layout on mount. This should be done after correcting the layout width\n    // to ensure we don't rerender with the wrong width.\n    this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n  }\n  static getDerivedStateFromProps(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State> | null*/{\n    let newLayoutBase;\n    if (prevState.activeDrag) {\n      return null;\n    }\n\n    // Legacy support for compactType\n    // Allow parent to set layout directly.\n    if (!(0, _fastEquals.deepEqual)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {\n      newLayoutBase = nextProps.layout;\n    } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {\n      // If children change, also regenerate the layout. Use our state\n      // as the base in case because it may be more up to date than\n      // what is in props.\n      newLayoutBase = prevState.layout;\n    }\n\n    // We need to regenerate the layout.\n    if (newLayoutBase) {\n      const newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);\n      return {\n        layout: newLayout,\n        // We need to save these props to state for using\n        // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n        compactType: nextProps.compactType,\n        children: nextProps.children,\n        propsLayout: nextProps.layout\n      };\n    }\n    return null;\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    return (\n      // NOTE: this is almost always unequal. Therefore the only way to get better performance\n      // from SCU is if the user intentionally memoizes children. If they do, and they can\n      // handle changes properly, performance will increase.\n      this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _fastEquals.deepEqual) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition\n    );\n  }\n  componentDidUpdate(prevProps /*: Props*/, prevState /*: State*/) {\n    if (!this.state.activeDrag) {\n      const newLayout = this.state.layout;\n      const oldLayout = prevState.layout;\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n  }\n\n  /**\n   * Calculates a pixel value for the container.\n   * @return {String} Container height in pixels.\n   */\n  containerHeight() /*: ?string*/{\n    if (!this.props.autoSize) return;\n    const nbRow = (0, _utils.bottom)(this.state.layout);\n    const containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];\n    return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + \"px\";\n  }\n  onLayoutMaybeChanged(newLayout /*: Layout*/, oldLayout /*: ?Layout*/) {\n    if (!oldLayout) oldLayout = this.state.layout;\n    if (!(0, _fastEquals.deepEqual)(oldLayout, newLayout)) {\n      this.props.onLayoutChange(newLayout);\n    }\n  }\n  /**\n   * Create a placeholder object.\n   * @return {Element} Placeholder div.\n   */\n  placeholder() /*: ?ReactElement<any>*/{\n    const {\n      activeDrag\n    } = this.state;\n    if (!activeDrag) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      useCSSTransforms,\n      transformScale\n    } = this.props;\n\n    // {...this.state.activeDrag} is pretty slow, actually\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      w: activeDrag.w,\n      h: activeDrag.h,\n      x: activeDrag.x,\n      y: activeDrag.y,\n      i: activeDrag.i,\n      className: `react-grid-placeholder ${this.state.resizing ? \"placeholder-resizing\" : \"\"}`,\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      isDraggable: false,\n      isResizable: false,\n      isBounded: false,\n      useCSSTransforms: useCSSTransforms,\n      transformScale: transformScale\n    }, /*#__PURE__*/React.createElement(\"div\", null));\n  }\n\n  /**\n   * Given a grid item, set its style attributes & surround in a <Draggable>.\n   * @param  {Element} child React element.\n   * @return {Element}       Element wrapped in draggable and properly placed.\n   */\n  processGridItem(child /*: ReactElement<any>*/, isDroppingItem /*: boolean*/) /*: ?ReactElement<any>*/{\n    if (!child || !child.key) return;\n    const l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));\n    if (!l) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      isDraggable,\n      isResizable,\n      isBounded,\n      useCSSTransforms,\n      transformScale,\n      draggableCancel,\n      draggableHandle,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const {\n      mounted,\n      droppingPosition\n    } = this.state;\n\n    // Determine user manipulations possible.\n    // If an item is static, it can't be manipulated by default.\n    // Any properties defined directly on the grid item will take precedence.\n    const draggable = typeof l.isDraggable === \"boolean\" ? l.isDraggable : !l.static && isDraggable;\n    const resizable = typeof l.isResizable === \"boolean\" ? l.isResizable : !l.static && isResizable;\n    const resizeHandlesOptions = l.resizeHandles || resizeHandles;\n\n    // isBounded set on child if set on parent, and child is not explicitly false\n    const bounded = draggable && isBounded && l.isBounded !== false;\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      cancel: draggableCancel,\n      handle: draggableHandle,\n      onDragStop: this.onDragStop,\n      onDragStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onResizeStart: this.onResizeStart,\n      onResize: this.onResize,\n      onResizeStop: this.onResizeStop,\n      isDraggable: draggable,\n      isResizable: resizable,\n      isBounded: bounded,\n      useCSSTransforms: useCSSTransforms && mounted,\n      usePercentages: !mounted,\n      transformScale: transformScale,\n      w: l.w,\n      h: l.h,\n      x: l.x,\n      y: l.y,\n      i: l.i,\n      minH: l.minH,\n      minW: l.minW,\n      maxH: l.maxH,\n      maxW: l.maxW,\n      static: l.static,\n      droppingPosition: isDroppingItem ? droppingPosition : undefined,\n      resizeHandles: resizeHandlesOptions,\n      resizeHandle: resizeHandle\n    }, child);\n  }\n  render() /*: React.Element<\"div\">*/{\n    const {\n      className,\n      style,\n      isDroppable,\n      innerRef\n    } = this.props;\n    const mergedClassName = (0, _clsx.default)(layoutClassName, className);\n    const mergedStyle = {\n      height: this.containerHeight(),\n      ...style\n    };\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: innerRef,\n      className: mergedClassName,\n      style: mergedStyle,\n      onDrop: isDroppable ? this.onDrop : _utils.noop,\n      onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,\n      onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,\n      onDragOver: isDroppable ? this.onDragOver : _utils.noop\n    }, React.Children.map(this.props.children, child => this.processGridItem(child)), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());\n  }\n}\nexports[\"default\"] = ReactGridLayout;\n// TODO publish internal ReactClass displayName transform\n_defineProperty(ReactGridLayout, \"displayName\", \"ReactGridLayout\");\n// Refactored to another module to make way for preval\n_defineProperty(ReactGridLayout, \"propTypes\", _ReactGridLayoutPropTypes.default);\n_defineProperty(ReactGridLayout, \"defaultProps\", {\n  autoSize: true,\n  cols: 12,\n  className: \"\",\n  style: {},\n  draggableHandle: \"\",\n  draggableCancel: \"\",\n  containerPadding: null,\n  rowHeight: 150,\n  maxRows: Infinity,\n  // infinite vertical growth\n  layout: [],\n  margin: [10, 10],\n  isBounded: false,\n  isDraggable: true,\n  isResizable: true,\n  allowOverlap: false,\n  isDroppable: false,\n  useCSSTransforms: true,\n  transformScale: 1,\n  verticalCompact: true,\n  compactType: \"vertical\",\n  preventCollision: false,\n  droppingItem: {\n    i: \"__dropping-elem__\",\n    h: 1,\n    w: 1\n  },\n  resizeHandles: [\"se\"],\n  onLayoutChange: _utils.noop,\n  onDragStart: _utils.noop,\n  onDrag: _utils.noop,\n  onDragStop: _utils.noop,\n  onResizeStart: _utils.noop,\n  onResize: _utils.noop,\n  onResizeStop: _utils.noop,\n  onDrop: _utils.noop,\n  onDropDragOver: _utils.noop\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVhY3RHcmlkTGF5b3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysb0NBQW9DLG1CQUFPLENBQUMsd0dBQU87QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsNkVBQWE7QUFDdkMsbUNBQW1DLG1CQUFPLENBQUMsb0RBQU07QUFDakQsYUFBYSxtQkFBTyxDQUFDLHNFQUFTO0FBQzlCLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFrQjtBQUNoRCx1Q0FBdUMsbUJBQU8sQ0FBQyw0RUFBWTtBQUMzRCx1REFBdUQsbUJBQU8sQ0FBQyw0R0FBNEI7QUFDM0YscUNBQXFDLGlDQUFpQztBQUN0RSx5Q0FBeUMsNEVBQTRFLG9EQUFvRCx1Q0FBdUMsZ0JBQWdCLCtCQUErQiw0RUFBNEUscUJBQXFCLCtCQUErQixlQUFlLHdDQUF3QywySkFBMkosV0FBVztBQUM1bEIsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxhQUFhO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZUFBZTtBQUNqQjtBQUNBLG1CQUFtQixpQkFBaUIsd0JBQXdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsbUJBQW1CLHNCQUFzQixrQ0FBa0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixRQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsa0RBQWtEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0b2NrbWFzdGVyLWltcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9SZWFjdEdyaWRMYXlvdXQuanM/ODQzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2Zhc3RFcXVhbHMgPSByZXF1aXJlKFwiZmFzdC1lcXVhbHNcIik7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBfY2FsY3VsYXRlVXRpbHMgPSByZXF1aXJlKFwiLi9jYWxjdWxhdGVVdGlsc1wiKTtcbnZhciBfR3JpZEl0ZW0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0dyaWRJdGVtXCIpKTtcbnZhciBfUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgdCkgeyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBXZWFrTWFwKSB2YXIgciA9IG5ldyBXZWFrTWFwKCksIG4gPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gZnVuY3Rpb24gKGUsIHQpIHsgaWYgKCF0ICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgdmFyIG8sIGksIGYgPSB7IF9fcHJvdG9fXzogbnVsbCwgZGVmYXVsdDogZSB9OyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBlICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIGY7IGlmIChvID0gdCA/IG4gOiByKSB7IGlmIChvLmhhcyhlKSkgcmV0dXJuIG8uZ2V0KGUpOyBvLnNldChlLCBmKTsgfSBmb3IgKGNvbnN0IHQgaW4gZSkgXCJkZWZhdWx0XCIgIT09IHQgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB0KSAmJiAoKGkgPSAobyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB0KSkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IG8oZiwgdCwgaSkgOiBmW3RdID0gZVt0XSk7IHJldHVybiBmOyB9KShlLCB0KTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLyo6OiBpbXBvcnQgdHlwZSB7XG4gIENoaWxkcmVuQXJyYXkgYXMgUmVhY3RDaGlsZHJlbkFycmF5LFxuICBFbGVtZW50IGFzIFJlYWN0RWxlbWVudFxufSBmcm9tIFwicmVhY3RcIjsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7XG4gIENvbXBhY3RUeXBlLFxuICBHcmlkUmVzaXplRXZlbnQsXG4gIEdyaWREcmFnRXZlbnQsXG4gIERyYWdPdmVyRXZlbnQsXG4gIExheW91dCxcbiAgRHJvcHBpbmdQb3NpdGlvbixcbiAgTGF5b3V0SXRlbVxufSBmcm9tIFwiLi91dGlsc1wiOyovXG4vLyBUeXBlc1xuLyo6OiBpbXBvcnQgdHlwZSB7IFBvc2l0aW9uUGFyYW1zIH0gZnJvbSBcIi4vY2FsY3VsYXRlVXRpbHNcIjsqL1xuLyo6OiB0eXBlIFN0YXRlID0ge1xuICBhY3RpdmVEcmFnOiA/TGF5b3V0SXRlbSxcbiAgbGF5b3V0OiBMYXlvdXQsXG4gIG1vdW50ZWQ6IGJvb2xlYW4sXG4gIG9sZERyYWdJdGVtOiA/TGF5b3V0SXRlbSxcbiAgb2xkTGF5b3V0OiA/TGF5b3V0LFxuICBvbGRSZXNpemVJdGVtOiA/TGF5b3V0SXRlbSxcbiAgcmVzaXppbmc6IGJvb2xlYW4sXG4gIGRyb3BwaW5nRE9NTm9kZTogP1JlYWN0RWxlbWVudDxhbnk+LFxuICBkcm9wcGluZ1Bvc2l0aW9uPzogRHJvcHBpbmdQb3NpdGlvbixcbiAgLy8gTWlycm9yZWQgcHJvcHNcbiAgY2hpbGRyZW46IFJlYWN0Q2hpbGRyZW5BcnJheTxSZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIGNvbXBhY3RUeXBlPzogQ29tcGFjdFR5cGUsXG4gIHByb3BzTGF5b3V0PzogTGF5b3V0XG59OyovXG4vKjo6IGltcG9ydCB0eXBlIHsgUHJvcHMsIERlZmF1bHRQcm9wcyB9IGZyb20gXCIuL1JlYWN0R3JpZExheW91dFByb3BUeXBlc1wiOyovXG4vLyBFbmQgVHlwZXNcbmNvbnN0IGxheW91dENsYXNzTmFtZSA9IFwicmVhY3QtZ3JpZC1sYXlvdXRcIjtcbmxldCBpc0ZpcmVmb3ggPSBmYWxzZTtcbi8vIFRyeS4uLmNhdGNoIHdpbGwgcHJvdGVjdCBmcm9tIG5hdmlnYXRvciBub3QgZXhpc3RpbmcgKGUuZy4gbm9kZSkgb3IgYSBiYWQgaW1wbGVtZW50YXRpb24gb2YgbmF2aWdhdG9yXG50cnkge1xuICBpc0ZpcmVmb3ggPSAvZmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59IGNhdGNoIChlKSB7XG4gIC8qIElnbm9yZSAqL1xufVxuXG4vKipcbiAqIEEgcmVhY3RpdmUsIGZsdWlkIGdyaWQgbGF5b3V0IHdpdGggZHJhZ2dhYmxlLCByZXNpemFibGUgY29tcG9uZW50cy5cbiAqL1xuXG5jbGFzcyBSZWFjdEdyaWRMYXlvdXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgLyo6OiA8UHJvcHMsIFN0YXRlPiove1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIGFjdGl2ZURyYWc6IG51bGwsXG4gICAgICBsYXlvdXQ6ICgwLCBfdXRpbHMuc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4pKHRoaXMucHJvcHMubGF5b3V0LCB0aGlzLnByb3BzLmNoaWxkcmVuLCB0aGlzLnByb3BzLmNvbHMsXG4gICAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdmVydGljYWxDb21wYWN0OiBmYWxzZVxuICAgICAgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIHRoaXMucHJvcHMuYWxsb3dPdmVybGFwKSxcbiAgICAgIG1vdW50ZWQ6IGZhbHNlLFxuICAgICAgb2xkRHJhZ0l0ZW06IG51bGwsXG4gICAgICBvbGRMYXlvdXQ6IG51bGwsXG4gICAgICBvbGRSZXNpemVJdGVtOiBudWxsLFxuICAgICAgcmVzaXppbmc6IGZhbHNlLFxuICAgICAgZHJvcHBpbmdET01Ob2RlOiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhZ0VudGVyQ291bnRlclwiLCAwKTtcbiAgICAvKipcbiAgICAgKiBXaGVuIGRyYWdnaW5nIHN0YXJ0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpIElkIG9mIHRoZSBjaGlsZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBjdXJyZW50IGRyYWdnaW5nIERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnU3RhcnRcIiwgKGkgLyo6IHN0cmluZyovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8sIF9yZWYgLyo6OiAqLykgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgZSxcbiAgICAgICAgbm9kZVxuICAgICAgfSAvKjogR3JpZERyYWdFdmVudCovID0gX3JlZiAvKjogR3JpZERyYWdFdmVudCovO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkobGF5b3V0LCBpKTtcbiAgICAgIGlmICghbCkgcmV0dXJuO1xuXG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgKGRpc3BsYXkgb25seSlcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0ge1xuICAgICAgICB3OiBsLncsXG4gICAgICAgIGg6IGwuaCxcbiAgICAgICAgeDogbC54LFxuICAgICAgICB5OiBsLnksXG4gICAgICAgIHBsYWNlaG9sZGVyOiB0cnVlLFxuICAgICAgICBpOiBpXG4gICAgICB9O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG9sZERyYWdJdGVtOiAoMCwgX3V0aWxzLmNsb25lTGF5b3V0SXRlbSkobCksXG4gICAgICAgIG9sZExheW91dDogbGF5b3V0LFxuICAgICAgICBhY3RpdmVEcmFnOiBwbGFjZWhvbGRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkRyYWdTdGFydChsYXlvdXQsIGwsIGwsIG51bGwsIGUsIG5vZGUpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEVhY2ggZHJhZyBtb3ZlbWVudCBjcmVhdGUgYSBuZXcgZHJhZ2VsZW1lbnQgYW5kIG1vdmUgdGhlIGVsZW1lbnQgdG8gdGhlIGRyYWdnZWQgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaSBJZCBvZiB0aGUgY2hpbGRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIG1vdXNlZG93biBldmVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgY3VycmVudCBkcmFnZ2luZyBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1wiLCAoaSwgeCwgeSwgX3JlZjIpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBfcmVmMjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2xkRHJhZ0l0ZW1cbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgbGV0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29scyxcbiAgICAgICAgYWxsb3dPdmVybGFwLFxuICAgICAgICBwcmV2ZW50Q29sbGlzaW9uXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGwgPSAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKGxheW91dCwgaSk7XG4gICAgICBpZiAoIWwpIHJldHVybjtcblxuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIChkaXNwbGF5IG9ubHkpXG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgdzogbC53LFxuICAgICAgICBoOiBsLmgsXG4gICAgICAgIHg6IGwueCxcbiAgICAgICAgeTogbC55LFxuICAgICAgICBwbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICAgICAgaTogaVxuICAgICAgfTtcblxuICAgICAgLy8gTW92ZSB0aGUgZWxlbWVudCB0byB0aGUgZHJhZ2dlZCBsb2NhdGlvbi5cbiAgICAgIGNvbnN0IGlzVXNlckFjdGlvbiA9IHRydWU7XG4gICAgICBsYXlvdXQgPSAoMCwgX3V0aWxzLm1vdmVFbGVtZW50KShsYXlvdXQsIGwsIHgsIHksIGlzVXNlckFjdGlvbiwgcHJldmVudENvbGxpc2lvbiwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMsIGFsbG93T3ZlcmxhcCk7XG4gICAgICB0aGlzLnByb3BzLm9uRHJhZyhsYXlvdXQsIG9sZERyYWdJdGVtLCBsLCBwbGFjZWhvbGRlciwgZSwgbm9kZSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbGF5b3V0OiBhbGxvd092ZXJsYXAgPyBsYXlvdXQgOiAoMCwgX3V0aWxzLmNvbXBhY3QpKGxheW91dCwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMpLFxuICAgICAgICBhY3RpdmVEcmFnOiBwbGFjZWhvbGRlclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogV2hlbiBkcmFnZ2luZyBzdG9wcywgZmlndXJlIG91dCB3aGljaCBwb3NpdGlvbiB0aGUgZWxlbWVudCBpcyBjbG9zZXN0IHRvIGFuZCB1cGRhdGUgaXRzIHggYW5kIHkuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBpIEluZGV4IG9mIHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIG1vdXNlZG93biBldmVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgY3VycmVudCBkcmFnZ2luZyBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1N0b3BcIiwgKGksIHgsIHksIF9yZWYzKSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBlLFxuICAgICAgICBub2RlXG4gICAgICB9ID0gX3JlZjM7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuYWN0aXZlRHJhZykgcmV0dXJuO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbGREcmFnSXRlbVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBsZXQge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2xzLFxuICAgICAgICBwcmV2ZW50Q29sbGlzaW9uLFxuICAgICAgICBhbGxvd092ZXJsYXBcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkobGF5b3V0LCBpKTtcbiAgICAgIGlmICghbCkgcmV0dXJuO1xuXG4gICAgICAvLyBNb3ZlIHRoZSBlbGVtZW50IGhlcmVcbiAgICAgIGNvbnN0IGlzVXNlckFjdGlvbiA9IHRydWU7XG4gICAgICBsYXlvdXQgPSAoMCwgX3V0aWxzLm1vdmVFbGVtZW50KShsYXlvdXQsIGwsIHgsIHksIGlzVXNlckFjdGlvbiwgcHJldmVudENvbGxpc2lvbiwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMsIGFsbG93T3ZlcmxhcCk7XG5cbiAgICAgIC8vIFNldCBzdGF0ZVxuICAgICAgY29uc3QgbmV3TGF5b3V0ID0gYWxsb3dPdmVybGFwID8gbGF5b3V0IDogKDAsIF91dGlscy5jb21wYWN0KShsYXlvdXQsICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzKTtcbiAgICAgIHRoaXMucHJvcHMub25EcmFnU3RvcChuZXdMYXlvdXQsIG9sZERyYWdJdGVtLCBsLCBudWxsLCBlLCBub2RlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2xkTGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBhY3RpdmVEcmFnOiBudWxsLFxuICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgb2xkRHJhZ0l0ZW06IG51bGwsXG4gICAgICAgIG9sZExheW91dDogbnVsbFxuICAgICAgfSk7XG4gICAgICB0aGlzLm9uTGF5b3V0TWF5YmVDaGFuZ2VkKG5ld0xheW91dCwgb2xkTGF5b3V0KTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVN0YXJ0XCIsIChpLCB3LCBoLCBfcmVmNCkgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgZSxcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWY0O1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkobGF5b3V0LCBpKTtcbiAgICAgIGlmICghbCkgcmV0dXJuO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG9sZFJlc2l6ZUl0ZW06ICgwLCBfdXRpbHMuY2xvbmVMYXlvdXRJdGVtKShsKSxcbiAgICAgICAgb2xkTGF5b3V0OiB0aGlzLnN0YXRlLmxheW91dCxcbiAgICAgICAgcmVzaXppbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZVN0YXJ0KGxheW91dCwgbCwgbCwgbnVsbCwgZSwgbm9kZSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25SZXNpemVcIiwgKGksIHcsIGgsIF9yZWY1KSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBlLFxuICAgICAgICBub2RlLFxuICAgICAgICBzaXplLFxuICAgICAgICBoYW5kbGVcbiAgICAgIH0gPSBfcmVmNTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2xkUmVzaXplSXRlbVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbHMsXG4gICAgICAgIHByZXZlbnRDb2xsaXNpb24sXG4gICAgICAgIGFsbG93T3ZlcmxhcFxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBsZXQgc2hvdWxkTW92ZUl0ZW0gPSBmYWxzZTtcbiAgICAgIGxldCBmaW5hbExheW91dDtcbiAgICAgIGxldCB4O1xuICAgICAgbGV0IHk7XG4gICAgICBjb25zdCBbbmV3TGF5b3V0LCBsXSA9ICgwLCBfdXRpbHMud2l0aExheW91dEl0ZW0pKGxheW91dCwgaSwgbCA9PiB7XG4gICAgICAgIGxldCBoYXNDb2xsaXNpb25zO1xuICAgICAgICB4ID0gbC54O1xuICAgICAgICB5ID0gbC55O1xuICAgICAgICBpZiAoW1wic3dcIiwgXCJ3XCIsIFwibndcIiwgXCJuXCIsIFwibmVcIl0uaW5kZXhPZihoYW5kbGUpICE9PSAtMSkge1xuICAgICAgICAgIGlmIChbXCJzd1wiLCBcIm53XCIsIFwid1wiXS5pbmRleE9mKGhhbmRsZSkgIT09IC0xKSB7XG4gICAgICAgICAgICB4ID0gbC54ICsgKGwudyAtIHcpO1xuICAgICAgICAgICAgdyA9IGwueCAhPT0geCAmJiB4IDwgMCA/IGwudyA6IHc7XG4gICAgICAgICAgICB4ID0geCA8IDAgPyAwIDogeDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFtcIm5lXCIsIFwiblwiLCBcIm53XCJdLmluZGV4T2YoaGFuZGxlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHkgPSBsLnkgKyAobC5oIC0gaCk7XG4gICAgICAgICAgICBoID0gbC55ICE9PSB5ICYmIHkgPCAwID8gbC5oIDogaDtcbiAgICAgICAgICAgIHkgPSB5IDwgMCA/IDAgOiB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaG91bGRNb3ZlSXRlbSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGhpbmcgbGlrZSBxdWFkIHRyZWUgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgLy8gdG8gZmluZCBjb2xsaXNpb25zIGZhc3RlclxuICAgICAgICBpZiAocHJldmVudENvbGxpc2lvbiAmJiAhYWxsb3dPdmVybGFwKSB7XG4gICAgICAgICAgY29uc3QgY29sbGlzaW9ucyA9ICgwLCBfdXRpbHMuZ2V0QWxsQ29sbGlzaW9ucykobGF5b3V0LCB7XG4gICAgICAgICAgICAuLi5sLFxuICAgICAgICAgICAgdyxcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgIH0pLmZpbHRlcihsYXlvdXRJdGVtID0+IGxheW91dEl0ZW0uaSAhPT0gbC5pKTtcbiAgICAgICAgICBoYXNDb2xsaXNpb25zID0gY29sbGlzaW9ucy5sZW5ndGggPiAwO1xuXG4gICAgICAgICAgLy8gSWYgd2UncmUgY29sbGlkaW5nLCB3ZSBuZWVkIGFkanVzdCB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgaWYgKGhhc0NvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGxheW91dEl0ZW0gZGltZW5zaW9ucyBpZiB0aGVyZSB3ZXJlIGNvbGxpc2lvbnNcbiAgICAgICAgICAgIHkgPSBsLnk7XG4gICAgICAgICAgICBoID0gbC5oO1xuICAgICAgICAgICAgeCA9IGwueDtcbiAgICAgICAgICAgIHcgPSBsLnc7XG4gICAgICAgICAgICBzaG91bGRNb3ZlSXRlbSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsLncgPSB3O1xuICAgICAgICBsLmggPSBoO1xuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG91bGRuJ3QgZXZlciBoYXBwZW4sIGJ1dCB0eXBlY2hlY2tpbmcgbWFrZXMgaXQgbmVjZXNzYXJ5XG4gICAgICBpZiAoIWwpIHJldHVybjtcbiAgICAgIGZpbmFsTGF5b3V0ID0gbmV3TGF5b3V0O1xuICAgICAgaWYgKHNob3VsZE1vdmVJdGVtKSB7XG4gICAgICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgdG8gdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgY29uc3QgaXNVc2VyQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgZmluYWxMYXlvdXQgPSAoMCwgX3V0aWxzLm1vdmVFbGVtZW50KShuZXdMYXlvdXQsIGwsIHgsIHksIGlzVXNlckFjdGlvbiwgdGhpcy5wcm9wcy5wcmV2ZW50Q29sbGlzaW9uLCAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSwgY29scywgYWxsb3dPdmVybGFwKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIGVsZW1lbnQgKGRpc3BsYXkgb25seSlcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0ge1xuICAgICAgICB3OiBsLncsXG4gICAgICAgIGg6IGwuaCxcbiAgICAgICAgeDogbC54LFxuICAgICAgICB5OiBsLnksXG4gICAgICAgIHN0YXRpYzogdHJ1ZSxcbiAgICAgICAgaTogaVxuICAgICAgfTtcbiAgICAgIHRoaXMucHJvcHMub25SZXNpemUoZmluYWxMYXlvdXQsIG9sZFJlc2l6ZUl0ZW0sIGwsIHBsYWNlaG9sZGVyLCBlLCBub2RlKTtcblxuICAgICAgLy8gUmUtY29tcGFjdCB0aGUgbmV3TGF5b3V0IGFuZCBzZXQgdGhlIGRyYWcgcGxhY2Vob2xkZXIuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbGF5b3V0OiBhbGxvd092ZXJsYXAgPyBmaW5hbExheW91dCA6ICgwLCBfdXRpbHMuY29tcGFjdCkoZmluYWxMYXlvdXQsICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzKSxcbiAgICAgICAgYWN0aXZlRHJhZzogcGxhY2Vob2xkZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uUmVzaXplU3RvcFwiLCAoaSwgdywgaCwgX3JlZjYpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBfcmVmNjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBvbGRSZXNpemVJdGVtXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29scyxcbiAgICAgICAgYWxsb3dPdmVybGFwXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGwgPSAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKGxheW91dCwgaSk7XG5cbiAgICAgIC8vIFNldCBzdGF0ZVxuICAgICAgY29uc3QgbmV3TGF5b3V0ID0gYWxsb3dPdmVybGFwID8gbGF5b3V0IDogKDAsIF91dGlscy5jb21wYWN0KShsYXlvdXQsICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzKTtcbiAgICAgIHRoaXMucHJvcHMub25SZXNpemVTdG9wKG5ld0xheW91dCwgb2xkUmVzaXplSXRlbSwgbCwgbnVsbCwgZSwgbm9kZSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9sZExheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlRHJhZzogbnVsbCxcbiAgICAgICAgbGF5b3V0OiBuZXdMYXlvdXQsXG4gICAgICAgIG9sZFJlc2l6ZUl0ZW06IG51bGwsXG4gICAgICAgIG9sZExheW91dDogbnVsbCxcbiAgICAgICAgcmVzaXppbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMub25MYXlvdXRNYXliZUNoYW5nZWQobmV3TGF5b3V0LCBvbGRMYXlvdXQpO1xuICAgIH0pO1xuICAgIC8vIENhbGxlZCB3aGlsZSBkcmFnZ2luZyBhbiBlbGVtZW50LiBQYXJ0IG9mIGJyb3dzZXIgbmF0aXZlIGRyYWcvZHJvcCBBUEkuXG4gICAgLy8gTmF0aXZlIGV2ZW50IHRhcmdldCBtaWdodCBiZSB0aGUgbGF5b3V0IGl0c2VsZiwgb3IgYW4gZWxlbWVudCB3aXRoaW4gdGhlIGxheW91dC5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdPdmVyXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGFueSBicm93c2VyIG5hdGl2ZSBhY3Rpb25cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIC8vIHdlIHNob3VsZCBpZ25vcmUgZXZlbnRzIGZyb20gbGF5b3V0J3MgY2hpbGRyZW4gaW4gRmlyZWZveFxuICAgICAgLy8gdG8gYXZvaWQgdW5wcmVkaWN0YWJsZSBqdW1waW5nIG9mIGEgZHJvcHBpbmcgcGxhY2Vob2xkZXJcbiAgICAgIC8vIEZJWE1FIHJlbW92ZSB0aGlzIGhhY2tcbiAgICAgIGlmIChpc0ZpcmVmb3ggJiZcbiAgICAgIC8vICRGbG93SWdub3JlIGNhbid0IGZpZ3VyZSB0aGlzIG91dFxuICAgICAgIWUubmF0aXZlRXZlbnQudGFyZ2V0Py5jbGFzc0xpc3QuY29udGFpbnMobGF5b3V0Q2xhc3NOYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRyb3BwaW5nSXRlbSxcbiAgICAgICAgb25Ecm9wRHJhZ092ZXIsXG4gICAgICAgIG1hcmdpbixcbiAgICAgICAgY29scyxcbiAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICBtYXhSb3dzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgY29udGFpbmVyUGFkZGluZyxcbiAgICAgICAgdHJhbnNmb3JtU2NhbGVcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgLy8gQWxsb3cgdXNlciB0byBjdXN0b21pemUgdGhlIGRyb3BwaW5nIGl0ZW0gb3Igc2hvcnQtY2lyY3VpdCB0aGUgZHJvcCBiYXNlZCBvbiB0aGUgcmVzdWx0c1xuICAgICAgLy8gb2YgdGhlIGBvbkRyYWdPdmVyKGU6IEV2ZW50KWAgY2FsbGJhY2suXG4gICAgICBjb25zdCBvbkRyYWdPdmVyUmVzdWx0ID0gb25Ecm9wRHJhZ092ZXI/LihlKTtcbiAgICAgIGlmIChvbkRyYWdPdmVyUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kcm9wcGluZ0RPTU5vZGUpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBmaW5hbERyb3BwaW5nSXRlbSA9IHtcbiAgICAgICAgLi4uZHJvcHBpbmdJdGVtLFxuICAgICAgICAuLi5vbkRyYWdPdmVyUmVzdWx0XG4gICAgICB9O1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAvLyAkRmxvd0lnbm9yZSBtaXNzaW5nIGRlZlxuICAgICAgY29uc3QgZ3JpZFJlY3QgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFRoZSBncmlkJ3MgcG9zaXRpb24gaW4gdGhlIHZpZXdwb3J0XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGdyaWRcbiAgICAgIGNvbnN0IGxheWVyWCA9IGUuY2xpZW50WCAtIGdyaWRSZWN0LmxlZnQ7XG4gICAgICBjb25zdCBsYXllclkgPSBlLmNsaWVudFkgLSBncmlkUmVjdC50b3A7XG4gICAgICBjb25zdCBkcm9wcGluZ1Bvc2l0aW9uID0ge1xuICAgICAgICBsZWZ0OiBsYXllclggLyB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgICAgdG9wOiBsYXllclkgLyB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgICAgZVxuICAgICAgfTtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5kcm9wcGluZ0RPTU5vZGUpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25QYXJhbXMgLyo6IFBvc2l0aW9uUGFyYW1zKi8gPSB7XG4gICAgICAgICAgY29scyxcbiAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgbWF4Um93cyxcbiAgICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lclBhZGRpbmc6IGNvbnRhaW5lclBhZGRpbmcgfHwgbWFyZ2luXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRQb3NpdGlvbiA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY1hZKShwb3NpdGlvblBhcmFtcywgbGF5ZXJZLCBsYXllclgsIGZpbmFsRHJvcHBpbmdJdGVtLncsIGZpbmFsRHJvcHBpbmdJdGVtLmgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBkcm9wcGluZ0RPTU5vZGU6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGtleTogZmluYWxEcm9wcGluZ0l0ZW0uaVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGRyb3BwaW5nUG9zaXRpb24sXG4gICAgICAgICAgbGF5b3V0OiBbLi4ubGF5b3V0LCB7XG4gICAgICAgICAgICAuLi5maW5hbERyb3BwaW5nSXRlbSxcbiAgICAgICAgICAgIHg6IGNhbGN1bGF0ZWRQb3NpdGlvbi54LFxuICAgICAgICAgICAgeTogY2FsY3VsYXRlZFBvc2l0aW9uLnksXG4gICAgICAgICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgICAgICAgaXNEcmFnZ2FibGU6IHRydWVcbiAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5kcm9wcGluZ1Bvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcFxuICAgICAgICB9ID0gdGhpcy5zdGF0ZS5kcm9wcGluZ1Bvc2l0aW9uO1xuICAgICAgICBjb25zdCBzaG91bGRVcGRhdGVQb3NpdGlvbiA9IGxlZnQgIT0gbGF5ZXJYIHx8IHRvcCAhPSBsYXllclk7XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVQb3NpdGlvbikge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZHJvcHBpbmdQb3NpdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVtb3ZlRHJvcHBpbmdQbGFjZWhvbGRlclwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRyb3BwaW5nSXRlbSxcbiAgICAgICAgY29sc1xuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBuZXdMYXlvdXQgPSAoMCwgX3V0aWxzLmNvbXBhY3QpKGxheW91dC5maWx0ZXIobCA9PiBsLmkgIT09IGRyb3BwaW5nSXRlbS5pKSwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMsIHRoaXMucHJvcHMuYWxsb3dPdmVybGFwKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgZHJvcHBpbmdET01Ob2RlOiBudWxsLFxuICAgICAgICBhY3RpdmVEcmFnOiBudWxsLFxuICAgICAgICBkcm9wcGluZ1Bvc2l0aW9uOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ0xlYXZlXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGFueSBicm93c2VyIG5hdGl2ZSBhY3Rpb25cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmRyYWdFbnRlckNvdW50ZXItLTtcblxuICAgICAgLy8gb25EcmFnTGVhdmUgY2FuIGJlIHRyaWdnZXJlZCBvbiBlYWNoIGxheW91dCdzIGNoaWxkLlxuICAgICAgLy8gQnV0IHdlIGtub3cgdGhhdCBjb3VudCBvZiBkcmFnRW50ZXIgYW5kIGRyYWdMZWF2ZSBldmVudHNcbiAgICAgIC8vIHdpbGwgYmUgYmFsYW5jZWQgYWZ0ZXIgbGVhdmluZyB0aGUgbGF5b3V0J3MgY29udGFpbmVyXG4gICAgICAvLyBzbyB3ZSBjYW4gaW5jcmVhc2UgYW5kIGRlY3JlYXNlIGNvdW50IG9mIGRyYWdFbnRlciBhbmRcbiAgICAgIC8vIHdoZW4gaXQnbGwgYmUgZXF1YWwgdG8gMCB3ZSdsbCByZW1vdmUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICBpZiAodGhpcy5kcmFnRW50ZXJDb3VudGVyID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRHJvcHBpbmdQbGFjZWhvbGRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ0VudGVyXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGFueSBicm93c2VyIG5hdGl2ZSBhY3Rpb25cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmRyYWdFbnRlckNvdW50ZXIrKztcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyb3BcIiwgKGUgLyo6IEV2ZW50Ki8pID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBhbnkgYnJvd3NlciBuYXRpdmUgYWN0aW9uXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBkcm9wcGluZ0l0ZW1cbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgaXRlbSA9IGxheW91dC5maW5kKGwgPT4gbC5pID09PSBkcm9wcGluZ0l0ZW0uaSk7XG5cbiAgICAgIC8vIHJlc2V0IGRyYWdFbnRlciBjb3VudGVyIG9uIGRyb3BcbiAgICAgIHRoaXMuZHJhZ0VudGVyQ291bnRlciA9IDA7XG4gICAgICB0aGlzLnJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXIoKTtcbiAgICAgIHRoaXMucHJvcHMub25Ecm9wKGxheW91dCwgaXRlbSwgZSk7XG4gICAgfSk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtb3VudGVkOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gUG9zc2libHkgY2FsbCBiYWNrIHdpdGggbGF5b3V0IG9uIG1vdW50LiBUaGlzIHNob3VsZCBiZSBkb25lIGFmdGVyIGNvcnJlY3RpbmcgdGhlIGxheW91dCB3aWR0aFxuICAgIC8vIHRvIGVuc3VyZSB3ZSBkb24ndCByZXJlbmRlciB3aXRoIHRoZSB3cm9uZyB3aWR0aC5cbiAgICB0aGlzLm9uTGF5b3V0TWF5YmVDaGFuZ2VkKHRoaXMuc3RhdGUubGF5b3V0LCB0aGlzLnByb3BzLmxheW91dCk7XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMgLyo6IFByb3BzKi8sIHByZXZTdGF0ZSAvKjogU3RhdGUqLykgLyo6ICRTaGFwZTxTdGF0ZT4gfCBudWxsKi97XG4gICAgbGV0IG5ld0xheW91dEJhc2U7XG4gICAgaWYgKHByZXZTdGF0ZS5hY3RpdmVEcmFnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgY29tcGFjdFR5cGVcbiAgICAvLyBBbGxvdyBwYXJlbnQgdG8gc2V0IGxheW91dCBkaXJlY3RseS5cbiAgICBpZiAoISgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKG5leHRQcm9wcy5sYXlvdXQsIHByZXZTdGF0ZS5wcm9wc0xheW91dCkgfHwgbmV4dFByb3BzLmNvbXBhY3RUeXBlICE9PSBwcmV2U3RhdGUuY29tcGFjdFR5cGUpIHtcbiAgICAgIG5ld0xheW91dEJhc2UgPSBuZXh0UHJvcHMubGF5b3V0O1xuICAgIH0gZWxzZSBpZiAoISgwLCBfdXRpbHMuY2hpbGRyZW5FcXVhbCkobmV4dFByb3BzLmNoaWxkcmVuLCBwcmV2U3RhdGUuY2hpbGRyZW4pKSB7XG4gICAgICAvLyBJZiBjaGlsZHJlbiBjaGFuZ2UsIGFsc28gcmVnZW5lcmF0ZSB0aGUgbGF5b3V0LiBVc2Ugb3VyIHN0YXRlXG4gICAgICAvLyBhcyB0aGUgYmFzZSBpbiBjYXNlIGJlY2F1c2UgaXQgbWF5IGJlIG1vcmUgdXAgdG8gZGF0ZSB0aGFuXG4gICAgICAvLyB3aGF0IGlzIGluIHByb3BzLlxuICAgICAgbmV3TGF5b3V0QmFzZSA9IHByZXZTdGF0ZS5sYXlvdXQ7XG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byByZWdlbmVyYXRlIHRoZSBsYXlvdXQuXG4gICAgaWYgKG5ld0xheW91dEJhc2UpIHtcbiAgICAgIGNvbnN0IG5ld0xheW91dCA9ICgwLCBfdXRpbHMuc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4pKG5ld0xheW91dEJhc2UsIG5leHRQcm9wcy5jaGlsZHJlbiwgbmV4dFByb3BzLmNvbHMsICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKG5leHRQcm9wcyksIG5leHRQcm9wcy5hbGxvd092ZXJsYXApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGF5b3V0OiBuZXdMYXlvdXQsXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc2F2ZSB0aGVzZSBwcm9wcyB0byBzdGF0ZSBmb3IgdXNpbmdcbiAgICAgICAgLy8gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIGluc3RlYWQgb2YgY29tcG9uZW50RGlkTW91bnQgKGluIHdoaWNoIHdlIHdvdWxkIGdldCBleHRyYSByZXJlbmRlcilcbiAgICAgICAgY29tcGFjdFR5cGU6IG5leHRQcm9wcy5jb21wYWN0VHlwZSxcbiAgICAgICAgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgcHJvcHNMYXlvdXQ6IG5leHRQcm9wcy5sYXlvdXRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMgLyo6IFByb3BzKi8sIG5leHRTdGF0ZSAvKjogU3RhdGUqLykgLyo6IGJvb2xlYW4qL3tcbiAgICByZXR1cm4gKFxuICAgICAgLy8gTk9URTogdGhpcyBpcyBhbG1vc3QgYWx3YXlzIHVuZXF1YWwuIFRoZXJlZm9yZSB0aGUgb25seSB3YXkgdG8gZ2V0IGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAgLy8gZnJvbSBTQ1UgaXMgaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSBtZW1vaXplcyBjaGlsZHJlbi4gSWYgdGhleSBkbywgYW5kIHRoZXkgY2FuXG4gICAgICAvLyBoYW5kbGUgY2hhbmdlcyBwcm9wZXJseSwgcGVyZm9ybWFuY2Ugd2lsbCBpbmNyZWFzZS5cbiAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4gIT09IG5leHRQcm9wcy5jaGlsZHJlbiB8fCAhKDAsIF91dGlscy5mYXN0UkdMUHJvcHNFcXVhbCkodGhpcy5wcm9wcywgbmV4dFByb3BzLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpIHx8IHRoaXMuc3RhdGUuYWN0aXZlRHJhZyAhPT0gbmV4dFN0YXRlLmFjdGl2ZURyYWcgfHwgdGhpcy5zdGF0ZS5tb3VudGVkICE9PSBuZXh0U3RhdGUubW91bnRlZCB8fCB0aGlzLnN0YXRlLmRyb3BwaW5nUG9zaXRpb24gIT09IG5leHRTdGF0ZS5kcm9wcGluZ1Bvc2l0aW9uXG4gICAgKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzIC8qOiBQcm9wcyovLCBwcmV2U3RhdGUgLyo6IFN0YXRlKi8pIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuYWN0aXZlRHJhZykge1xuICAgICAgY29uc3QgbmV3TGF5b3V0ID0gdGhpcy5zdGF0ZS5sYXlvdXQ7XG4gICAgICBjb25zdCBvbGRMYXlvdXQgPSBwcmV2U3RhdGUubGF5b3V0O1xuICAgICAgdGhpcy5vbkxheW91dE1heWJlQ2hhbmdlZChuZXdMYXlvdXQsIG9sZExheW91dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgYSBwaXhlbCB2YWx1ZSBmb3IgdGhlIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7U3RyaW5nfSBDb250YWluZXIgaGVpZ2h0IGluIHBpeGVscy5cbiAgICovXG4gIGNvbnRhaW5lckhlaWdodCgpIC8qOiA/c3RyaW5nKi97XG4gICAgaWYgKCF0aGlzLnByb3BzLmF1dG9TaXplKSByZXR1cm47XG4gICAgY29uc3QgbmJSb3cgPSAoMCwgX3V0aWxzLmJvdHRvbSkodGhpcy5zdGF0ZS5sYXlvdXQpO1xuICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmdZID0gdGhpcy5wcm9wcy5jb250YWluZXJQYWRkaW5nID8gdGhpcy5wcm9wcy5jb250YWluZXJQYWRkaW5nWzFdIDogdGhpcy5wcm9wcy5tYXJnaW5bMV07XG4gICAgcmV0dXJuIG5iUm93ICogdGhpcy5wcm9wcy5yb3dIZWlnaHQgKyAobmJSb3cgLSAxKSAqIHRoaXMucHJvcHMubWFyZ2luWzFdICsgY29udGFpbmVyUGFkZGluZ1kgKiAyICsgXCJweFwiO1xuICB9XG4gIG9uTGF5b3V0TWF5YmVDaGFuZ2VkKG5ld0xheW91dCAvKjogTGF5b3V0Ki8sIG9sZExheW91dCAvKjogP0xheW91dCovKSB7XG4gICAgaWYgKCFvbGRMYXlvdXQpIG9sZExheW91dCA9IHRoaXMuc3RhdGUubGF5b3V0O1xuICAgIGlmICghKDAsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkob2xkTGF5b3V0LCBuZXdMYXlvdXQpKSB7XG4gICAgICB0aGlzLnByb3BzLm9uTGF5b3V0Q2hhbmdlKG5ld0xheW91dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwbGFjZWhvbGRlciBvYmplY3QuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFBsYWNlaG9sZGVyIGRpdi5cbiAgICovXG4gIHBsYWNlaG9sZGVyKCkgLyo6ID9SZWFjdEVsZW1lbnQ8YW55Piove1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZURyYWdcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIWFjdGl2ZURyYWcpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgY29scyxcbiAgICAgIG1hcmdpbixcbiAgICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgICByb3dIZWlnaHQsXG4gICAgICBtYXhSb3dzLFxuICAgICAgdXNlQ1NTVHJhbnNmb3JtcyxcbiAgICAgIHRyYW5zZm9ybVNjYWxlXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyB7Li4udGhpcy5zdGF0ZS5hY3RpdmVEcmFnfSBpcyBwcmV0dHkgc2xvdywgYWN0dWFsbHlcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX0dyaWRJdGVtLmRlZmF1bHQsIHtcbiAgICAgIHc6IGFjdGl2ZURyYWcudyxcbiAgICAgIGg6IGFjdGl2ZURyYWcuaCxcbiAgICAgIHg6IGFjdGl2ZURyYWcueCxcbiAgICAgIHk6IGFjdGl2ZURyYWcueSxcbiAgICAgIGk6IGFjdGl2ZURyYWcuaSxcbiAgICAgIGNsYXNzTmFtZTogYHJlYWN0LWdyaWQtcGxhY2Vob2xkZXIgJHt0aGlzLnN0YXRlLnJlc2l6aW5nID8gXCJwbGFjZWhvbGRlci1yZXNpemluZ1wiIDogXCJcIn1gLFxuICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgY29sczogY29scyxcbiAgICAgIG1hcmdpbjogbWFyZ2luLFxuICAgICAgY29udGFpbmVyUGFkZGluZzogY29udGFpbmVyUGFkZGluZyB8fCBtYXJnaW4sXG4gICAgICBtYXhSb3dzOiBtYXhSb3dzLFxuICAgICAgcm93SGVpZ2h0OiByb3dIZWlnaHQsXG4gICAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgICBpc1Jlc2l6YWJsZTogZmFsc2UsXG4gICAgICBpc0JvdW5kZWQ6IGZhbHNlLFxuICAgICAgdXNlQ1NTVHJhbnNmb3JtczogdXNlQ1NTVHJhbnNmb3JtcyxcbiAgICAgIHRyYW5zZm9ybVNjYWxlOiB0cmFuc2Zvcm1TY2FsZVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGdyaWQgaXRlbSwgc2V0IGl0cyBzdHlsZSBhdHRyaWJ1dGVzICYgc3Vycm91bmQgaW4gYSA8RHJhZ2dhYmxlPi5cbiAgICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgUmVhY3QgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gICAgICAgRWxlbWVudCB3cmFwcGVkIGluIGRyYWdnYWJsZSBhbmQgcHJvcGVybHkgcGxhY2VkLlxuICAgKi9cbiAgcHJvY2Vzc0dyaWRJdGVtKGNoaWxkIC8qOiBSZWFjdEVsZW1lbnQ8YW55PiovLCBpc0Ryb3BwaW5nSXRlbSAvKjogYm9vbGVhbiovKSAvKjogP1JlYWN0RWxlbWVudDxhbnk+Ki97XG4gICAgaWYgKCFjaGlsZCB8fCAhY2hpbGQua2V5KSByZXR1cm47XG4gICAgY29uc3QgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkodGhpcy5zdGF0ZS5sYXlvdXQsIFN0cmluZyhjaGlsZC5rZXkpKTtcbiAgICBpZiAoIWwpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgY29scyxcbiAgICAgIG1hcmdpbixcbiAgICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgICByb3dIZWlnaHQsXG4gICAgICBtYXhSb3dzLFxuICAgICAgaXNEcmFnZ2FibGUsXG4gICAgICBpc1Jlc2l6YWJsZSxcbiAgICAgIGlzQm91bmRlZCxcbiAgICAgIHVzZUNTU1RyYW5zZm9ybXMsXG4gICAgICB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgIGRyYWdnYWJsZUNhbmNlbCxcbiAgICAgIGRyYWdnYWJsZUhhbmRsZSxcbiAgICAgIHJlc2l6ZUhhbmRsZXMsXG4gICAgICByZXNpemVIYW5kbGVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBtb3VudGVkLFxuICAgICAgZHJvcHBpbmdQb3NpdGlvblxuICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHVzZXIgbWFuaXB1bGF0aW9ucyBwb3NzaWJsZS5cbiAgICAvLyBJZiBhbiBpdGVtIGlzIHN0YXRpYywgaXQgY2FuJ3QgYmUgbWFuaXB1bGF0ZWQgYnkgZGVmYXVsdC5cbiAgICAvLyBBbnkgcHJvcGVydGllcyBkZWZpbmVkIGRpcmVjdGx5IG9uIHRoZSBncmlkIGl0ZW0gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgY29uc3QgZHJhZ2dhYmxlID0gdHlwZW9mIGwuaXNEcmFnZ2FibGUgPT09IFwiYm9vbGVhblwiID8gbC5pc0RyYWdnYWJsZSA6ICFsLnN0YXRpYyAmJiBpc0RyYWdnYWJsZTtcbiAgICBjb25zdCByZXNpemFibGUgPSB0eXBlb2YgbC5pc1Jlc2l6YWJsZSA9PT0gXCJib29sZWFuXCIgPyBsLmlzUmVzaXphYmxlIDogIWwuc3RhdGljICYmIGlzUmVzaXphYmxlO1xuICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXNPcHRpb25zID0gbC5yZXNpemVIYW5kbGVzIHx8IHJlc2l6ZUhhbmRsZXM7XG5cbiAgICAvLyBpc0JvdW5kZWQgc2V0IG9uIGNoaWxkIGlmIHNldCBvbiBwYXJlbnQsIGFuZCBjaGlsZCBpcyBub3QgZXhwbGljaXRseSBmYWxzZVxuICAgIGNvbnN0IGJvdW5kZWQgPSBkcmFnZ2FibGUgJiYgaXNCb3VuZGVkICYmIGwuaXNCb3VuZGVkICE9PSBmYWxzZTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX0dyaWRJdGVtLmRlZmF1bHQsIHtcbiAgICAgIGNvbnRhaW5lcldpZHRoOiB3aWR0aCxcbiAgICAgIGNvbHM6IGNvbHMsXG4gICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgIGNvbnRhaW5lclBhZGRpbmc6IGNvbnRhaW5lclBhZGRpbmcgfHwgbWFyZ2luLFxuICAgICAgbWF4Um93czogbWF4Um93cyxcbiAgICAgIHJvd0hlaWdodDogcm93SGVpZ2h0LFxuICAgICAgY2FuY2VsOiBkcmFnZ2FibGVDYW5jZWwsXG4gICAgICBoYW5kbGU6IGRyYWdnYWJsZUhhbmRsZSxcbiAgICAgIG9uRHJhZ1N0b3A6IHRoaXMub25EcmFnU3RvcCxcbiAgICAgIG9uRHJhZ1N0YXJ0OiB0aGlzLm9uRHJhZ1N0YXJ0LFxuICAgICAgb25EcmFnOiB0aGlzLm9uRHJhZyxcbiAgICAgIG9uUmVzaXplU3RhcnQ6IHRoaXMub25SZXNpemVTdGFydCxcbiAgICAgIG9uUmVzaXplOiB0aGlzLm9uUmVzaXplLFxuICAgICAgb25SZXNpemVTdG9wOiB0aGlzLm9uUmVzaXplU3RvcCxcbiAgICAgIGlzRHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICBpc1Jlc2l6YWJsZTogcmVzaXphYmxlLFxuICAgICAgaXNCb3VuZGVkOiBib3VuZGVkLFxuICAgICAgdXNlQ1NTVHJhbnNmb3JtczogdXNlQ1NTVHJhbnNmb3JtcyAmJiBtb3VudGVkLFxuICAgICAgdXNlUGVyY2VudGFnZXM6ICFtb3VudGVkLFxuICAgICAgdHJhbnNmb3JtU2NhbGU6IHRyYW5zZm9ybVNjYWxlLFxuICAgICAgdzogbC53LFxuICAgICAgaDogbC5oLFxuICAgICAgeDogbC54LFxuICAgICAgeTogbC55LFxuICAgICAgaTogbC5pLFxuICAgICAgbWluSDogbC5taW5ILFxuICAgICAgbWluVzogbC5taW5XLFxuICAgICAgbWF4SDogbC5tYXhILFxuICAgICAgbWF4VzogbC5tYXhXLFxuICAgICAgc3RhdGljOiBsLnN0YXRpYyxcbiAgICAgIGRyb3BwaW5nUG9zaXRpb246IGlzRHJvcHBpbmdJdGVtID8gZHJvcHBpbmdQb3NpdGlvbiA6IHVuZGVmaW5lZCxcbiAgICAgIHJlc2l6ZUhhbmRsZXM6IHJlc2l6ZUhhbmRsZXNPcHRpb25zLFxuICAgICAgcmVzaXplSGFuZGxlOiByZXNpemVIYW5kbGVcbiAgICB9LCBjaGlsZCk7XG4gIH1cbiAgcmVuZGVyKCkgLyo6IFJlYWN0LkVsZW1lbnQ8XCJkaXZcIj4qL3tcbiAgICBjb25zdCB7XG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZSxcbiAgICAgIGlzRHJvcHBhYmxlLFxuICAgICAgaW5uZXJSZWZcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBtZXJnZWRDbGFzc05hbWUgPSAoMCwgX2Nsc3guZGVmYXVsdCkobGF5b3V0Q2xhc3NOYW1lLCBjbGFzc05hbWUpO1xuICAgIGNvbnN0IG1lcmdlZFN0eWxlID0ge1xuICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lckhlaWdodCgpLFxuICAgICAgLi4uc3R5bGVcbiAgICB9O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBtZXJnZWRDbGFzc05hbWUsXG4gICAgICBzdHlsZTogbWVyZ2VkU3R5bGUsXG4gICAgICBvbkRyb3A6IGlzRHJvcHBhYmxlID8gdGhpcy5vbkRyb3AgOiBfdXRpbHMubm9vcCxcbiAgICAgIG9uRHJhZ0xlYXZlOiBpc0Ryb3BwYWJsZSA/IHRoaXMub25EcmFnTGVhdmUgOiBfdXRpbHMubm9vcCxcbiAgICAgIG9uRHJhZ0VudGVyOiBpc0Ryb3BwYWJsZSA/IHRoaXMub25EcmFnRW50ZXIgOiBfdXRpbHMubm9vcCxcbiAgICAgIG9uRHJhZ092ZXI6IGlzRHJvcHBhYmxlID8gdGhpcy5vbkRyYWdPdmVyIDogX3V0aWxzLm5vb3BcbiAgICB9LCBSZWFjdC5DaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlbiwgY2hpbGQgPT4gdGhpcy5wcm9jZXNzR3JpZEl0ZW0oY2hpbGQpKSwgaXNEcm9wcGFibGUgJiYgdGhpcy5zdGF0ZS5kcm9wcGluZ0RPTU5vZGUgJiYgdGhpcy5wcm9jZXNzR3JpZEl0ZW0odGhpcy5zdGF0ZS5kcm9wcGluZ0RPTU5vZGUsIHRydWUpLCB0aGlzLnBsYWNlaG9sZGVyKCkpO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSZWFjdEdyaWRMYXlvdXQ7XG4vLyBUT0RPIHB1Ymxpc2ggaW50ZXJuYWwgUmVhY3RDbGFzcyBkaXNwbGF5TmFtZSB0cmFuc2Zvcm1cbl9kZWZpbmVQcm9wZXJ0eShSZWFjdEdyaWRMYXlvdXQsIFwiZGlzcGxheU5hbWVcIiwgXCJSZWFjdEdyaWRMYXlvdXRcIik7XG4vLyBSZWZhY3RvcmVkIHRvIGFub3RoZXIgbW9kdWxlIHRvIG1ha2Ugd2F5IGZvciBwcmV2YWxcbl9kZWZpbmVQcm9wZXJ0eShSZWFjdEdyaWRMYXlvdXQsIFwicHJvcFR5cGVzXCIsIF9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXMuZGVmYXVsdCk7XG5fZGVmaW5lUHJvcGVydHkoUmVhY3RHcmlkTGF5b3V0LCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGF1dG9TaXplOiB0cnVlLFxuICBjb2xzOiAxMixcbiAgY2xhc3NOYW1lOiBcIlwiLFxuICBzdHlsZToge30sXG4gIGRyYWdnYWJsZUhhbmRsZTogXCJcIixcbiAgZHJhZ2dhYmxlQ2FuY2VsOiBcIlwiLFxuICBjb250YWluZXJQYWRkaW5nOiBudWxsLFxuICByb3dIZWlnaHQ6IDE1MCxcbiAgbWF4Um93czogSW5maW5pdHksXG4gIC8vIGluZmluaXRlIHZlcnRpY2FsIGdyb3d0aFxuICBsYXlvdXQ6IFtdLFxuICBtYXJnaW46IFsxMCwgMTBdLFxuICBpc0JvdW5kZWQ6IGZhbHNlLFxuICBpc0RyYWdnYWJsZTogdHJ1ZSxcbiAgaXNSZXNpemFibGU6IHRydWUsXG4gIGFsbG93T3ZlcmxhcDogZmFsc2UsXG4gIGlzRHJvcHBhYmxlOiBmYWxzZSxcbiAgdXNlQ1NTVHJhbnNmb3JtczogdHJ1ZSxcbiAgdHJhbnNmb3JtU2NhbGU6IDEsXG4gIHZlcnRpY2FsQ29tcGFjdDogdHJ1ZSxcbiAgY29tcGFjdFR5cGU6IFwidmVydGljYWxcIixcbiAgcHJldmVudENvbGxpc2lvbjogZmFsc2UsXG4gIGRyb3BwaW5nSXRlbToge1xuICAgIGk6IFwiX19kcm9wcGluZy1lbGVtX19cIixcbiAgICBoOiAxLFxuICAgIHc6IDFcbiAgfSxcbiAgcmVzaXplSGFuZGxlczogW1wic2VcIl0sXG4gIG9uTGF5b3V0Q2hhbmdlOiBfdXRpbHMubm9vcCxcbiAgb25EcmFnU3RhcnQ6IF91dGlscy5ub29wLFxuICBvbkRyYWc6IF91dGlscy5ub29wLFxuICBvbkRyYWdTdG9wOiBfdXRpbHMubm9vcCxcbiAgb25SZXNpemVTdGFydDogX3V0aWxzLm5vb3AsXG4gIG9uUmVzaXplOiBfdXRpbHMubm9vcCxcbiAgb25SZXNpemVTdG9wOiBfdXRpbHMubm9vcCxcbiAgb25Ecm9wOiBfdXRpbHMubm9vcCxcbiAgb25Ecm9wRHJhZ092ZXI6IF91dGlscy5ub29wXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.resizeHandleType = exports.resizeHandleAxesType = exports[\"default\"] = void 0;\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/*:: import type {\n  Ref,\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  DragOverEvent,\n  EventCallback,\n  CompactType,\n  Layout,\n  LayoutItem,\n  ResizeHandleAxis\n} from \"./utils\";*/\n/*:: export type ReactRef<T: HTMLElement> = {|\n  +current: T | null\n|};*/\n// util\n/*:: export type ResizeHandle =\n  | ReactElement<any>\n  | ((\n      resizeHandleAxis: ResizeHandleAxis,\n      ref: ReactRef<HTMLElement>\n    ) => ReactElement<any>);*/\n// Defines which resize handles should be rendered (default: 'se')\n// Allows for any combination of:\n// 's' - South handle (bottom-center)\n// 'w' - West handle (left-center)\n// 'e' - East handle (right-center)\n// 'n' - North handle (top-center)\n// 'sw' - Southwest handle (bottom-left)\n// 'nw' - Northwest handle (top-left)\n// 'se' - Southeast handle (bottom-right)\n// 'ne' - Northeast handle (top-right)\nconst resizeHandleAxesType /*: ReactPropsChainableTypeChecker*/ = exports.resizeHandleAxesType = _propTypes.default.arrayOf(_propTypes.default.oneOf([\"s\", \"w\", \"e\", \"n\", \"sw\", \"nw\", \"se\", \"ne\"]));\n// Custom component for resize handles\nconst resizeHandleType /*: ReactPropsChainableTypeChecker*/ = exports.resizeHandleType = _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]);\n/*:: export type Props = {|\n  className: string,\n  style: Object,\n  width: number,\n  autoSize: boolean,\n  cols: number,\n  draggableCancel: string,\n  draggableHandle: string,\n  verticalCompact: boolean,\n  compactType: CompactType,\n  layout: Layout,\n  margin: [number, number],\n  containerPadding: ?[number, number],\n  rowHeight: number,\n  maxRows: number,\n  isBounded: boolean,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isDroppable: boolean,\n  preventCollision: boolean,\n  useCSSTransforms: boolean,\n  transformScale: number,\n  droppingItem: $Shape<LayoutItem>,\n  resizeHandles: ResizeHandleAxis[],\n  resizeHandle?: ResizeHandle,\n  allowOverlap: boolean,\n\n  // Callbacks\n  onLayoutChange: Layout => void,\n  onDrag: EventCallback,\n  onDragStart: EventCallback,\n  onDragStop: EventCallback,\n  onResize: EventCallback,\n  onResizeStart: EventCallback,\n  onResizeStop: EventCallback,\n  onDropDragOver: (e: DragOverEvent) => ?({| w?: number, h?: number |} | false),\n  onDrop: (layout: Layout, item: ?LayoutItem, e: Event) => void,\n  children: ReactChildrenArray<ReactElement<any>>,\n  innerRef?: Ref<\"div\">\n|};*/\n/*:: export type DefaultProps = $Diff<\n  Props,\n  {\n    children: ReactChildrenArray<ReactElement<any>>,\n    width: number\n  }\n>;*/\nvar _default = exports[\"default\"] = {\n  //\n  // Basic props\n  //\n  className: _propTypes.default.string,\n  style: _propTypes.default.object,\n  // This can be set explicitly. If it is not set, it will automatically\n  // be set to the container width. Note that resizes will *not* cause this to adjust.\n  // If you need that behavior, use WidthProvider.\n  width: _propTypes.default.number,\n  // If true, the container height swells and contracts to fit contents\n  autoSize: _propTypes.default.bool,\n  // # of cols.\n  cols: _propTypes.default.number,\n  // A selector that will not be draggable.\n  draggableCancel: _propTypes.default.string,\n  // A selector for the draggable handler\n  draggableHandle: _propTypes.default.string,\n  // Deprecated\n  verticalCompact: function (props /*: Props*/) {\n    if (props.verticalCompact === false && \"development\" !== \"production\") {\n      console.warn(\n      // eslint-disable-line no-console\n      \"`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. \" + 'Use `compactType`: \"horizontal\" | \"vertical\" | null.');\n    }\n  },\n  // Choose vertical or hotizontal compaction\n  compactType: (_propTypes.default.oneOf([\"vertical\", \"horizontal\"]) /*: ReactPropsChainableTypeChecker*/),\n  // layout is an array of object with the format:\n  // {x: Number, y: Number, w: Number, h: Number, i: String}\n  layout: function (props /*: Props*/) {\n    var layout = props.layout;\n    // I hope you're setting the data-grid property on the grid items\n    if (layout === undefined) return;\n    (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\").validateLayout)(layout, \"layout\");\n  },\n  //\n  // Grid Dimensions\n  //\n\n  // Margin between items [x, y] in px\n  margin: (_propTypes.default.arrayOf(_propTypes.default.number) /*: ReactPropsChainableTypeChecker*/),\n  // Padding inside the container [x, y] in px\n  containerPadding: (_propTypes.default.arrayOf(_propTypes.default.number) /*: ReactPropsChainableTypeChecker*/),\n  // Rows have a static height, but you can change this based on breakpoints if you like\n  rowHeight: _propTypes.default.number,\n  // Default Infinity, but you can specify a max here if you like.\n  // Note that this isn't fully fleshed out and won't error if you specify a layout that\n  // extends beyond the row capacity. It will, however, not allow users to drag/resize\n  // an item past the barrier. They can push items beyond the barrier, though.\n  // Intentionally not documented for this reason.\n  maxRows: _propTypes.default.number,\n  //\n  // Flags\n  //\n  isBounded: _propTypes.default.bool,\n  isDraggable: _propTypes.default.bool,\n  isResizable: _propTypes.default.bool,\n  // If true, grid can be placed one over the other.\n  allowOverlap: _propTypes.default.bool,\n  // If true, grid items won't change position when being dragged over.\n  preventCollision: _propTypes.default.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: _propTypes.default.bool,\n  // parent layout transform scale\n  transformScale: _propTypes.default.number,\n  // If true, an external element can trigger onDrop callback with a specific grid position as a parameter\n  isDroppable: _propTypes.default.bool,\n  // Resize handle options\n  resizeHandles: resizeHandleAxesType,\n  resizeHandle: resizeHandleType,\n  //\n  // Callbacks\n  //\n\n  // Callback so you can save the layout. Calls after each drag & resize stops.\n  onLayoutChange: _propTypes.default.func,\n  // Calls when drag starts. Callback is of the signature (layout, oldItem, newItem, placeholder, e, ?node).\n  // All callbacks below have the same signature. 'start' and 'stop' callbacks omit the 'placeholder'.\n  onDragStart: _propTypes.default.func,\n  // Calls on each drag movement.\n  onDrag: _propTypes.default.func,\n  // Calls when drag is complete.\n  onDragStop: _propTypes.default.func,\n  //Calls when resize starts.\n  onResizeStart: _propTypes.default.func,\n  // Calls when resize movement happens.\n  onResize: _propTypes.default.func,\n  // Calls when resize is complete.\n  onResizeStop: _propTypes.default.func,\n  // Calls when some element is dropped.\n  onDrop: _propTypes.default.func,\n  //\n  // Other validations\n  //\n\n  droppingItem: (_propTypes.default.shape({\n    i: _propTypes.default.string.isRequired,\n    w: _propTypes.default.number.isRequired,\n    h: _propTypes.default.number.isRequired\n  }) /*: ReactPropsChainableTypeChecker*/),\n  // Children must not have duplicate keys.\n  children: function (props /*: Props*/, propName /*: string*/) {\n    const children = props[propName];\n\n    // Check children keys for duplicates. Throw if found.\n    const keys = {};\n    _react.default.Children.forEach(children, function (child) {\n      if (child?.key == null) return;\n      if (keys[child.key]) {\n        throw new Error('Duplicate child key \"' + child.key + '\" found! This will cause problems in ReactGridLayout.');\n      }\n      keys[child.key] = true;\n    });\n  },\n  // Optional ref for getting a reference for the wrapping div.\n  innerRef: _propTypes.default.any\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHdCQUF3QixHQUFHLDRCQUE0QixHQUFHLGtCQUFlO0FBQ3pFLHdDQUF3QyxtQkFBTyxDQUFDLDREQUFZO0FBQzVELG9DQUFvQyxtQkFBTyxDQUFDLHdHQUFPO0FBQ25ELHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGFBQWE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZUFBZTtBQUNqQiw2Q0FBNkM7QUFDN0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDRCQUE0QjtBQUM5RjtBQUNBLDhEQUE4RCx3QkFBd0I7QUFDdEYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRHQUFpQztBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0b2NrbWFzdGVyLWltcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXMuanM/N2ZmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVzaXplSGFuZGxlVHlwZSA9IGV4cG9ydHMucmVzaXplSGFuZGxlQXhlc1R5cGUgPSBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cbi8qOjogaW1wb3J0IHR5cGUge1xuICBSZWYsXG4gIENoaWxkcmVuQXJyYXkgYXMgUmVhY3RDaGlsZHJlbkFycmF5LFxuICBFbGVtZW50IGFzIFJlYWN0RWxlbWVudFxufSBmcm9tIFwicmVhY3RcIjsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7XG4gIERyYWdPdmVyRXZlbnQsXG4gIEV2ZW50Q2FsbGJhY2ssXG4gIENvbXBhY3RUeXBlLFxuICBMYXlvdXQsXG4gIExheW91dEl0ZW0sXG4gIFJlc2l6ZUhhbmRsZUF4aXNcbn0gZnJvbSBcIi4vdXRpbHNcIjsqL1xuLyo6OiBleHBvcnQgdHlwZSBSZWFjdFJlZjxUOiBIVE1MRWxlbWVudD4gPSB7fFxuICArY3VycmVudDogVCB8IG51bGxcbnx9OyovXG4vLyB1dGlsXG4vKjo6IGV4cG9ydCB0eXBlIFJlc2l6ZUhhbmRsZSA9XG4gIHwgUmVhY3RFbGVtZW50PGFueT5cbiAgfCAoKFxuICAgICAgcmVzaXplSGFuZGxlQXhpczogUmVzaXplSGFuZGxlQXhpcyxcbiAgICAgIHJlZjogUmVhY3RSZWY8SFRNTEVsZW1lbnQ+XG4gICAgKSA9PiBSZWFjdEVsZW1lbnQ8YW55Pik7Ki9cbi8vIERlZmluZXMgd2hpY2ggcmVzaXplIGhhbmRsZXMgc2hvdWxkIGJlIHJlbmRlcmVkIChkZWZhdWx0OiAnc2UnKVxuLy8gQWxsb3dzIGZvciBhbnkgY29tYmluYXRpb24gb2Y6XG4vLyAncycgLSBTb3V0aCBoYW5kbGUgKGJvdHRvbS1jZW50ZXIpXG4vLyAndycgLSBXZXN0IGhhbmRsZSAobGVmdC1jZW50ZXIpXG4vLyAnZScgLSBFYXN0IGhhbmRsZSAocmlnaHQtY2VudGVyKVxuLy8gJ24nIC0gTm9ydGggaGFuZGxlICh0b3AtY2VudGVyKVxuLy8gJ3N3JyAtIFNvdXRod2VzdCBoYW5kbGUgKGJvdHRvbS1sZWZ0KVxuLy8gJ253JyAtIE5vcnRod2VzdCBoYW5kbGUgKHRvcC1sZWZ0KVxuLy8gJ3NlJyAtIFNvdXRoZWFzdCBoYW5kbGUgKGJvdHRvbS1yaWdodClcbi8vICduZScgLSBOb3J0aGVhc3QgaGFuZGxlICh0b3AtcmlnaHQpXG5jb25zdCByZXNpemVIYW5kbGVBeGVzVHlwZSAvKjogUmVhY3RQcm9wc0NoYWluYWJsZVR5cGVDaGVja2VyKi8gPSBleHBvcnRzLnJlc2l6ZUhhbmRsZUF4ZXNUeXBlID0gX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFtcInNcIiwgXCJ3XCIsIFwiZVwiLCBcIm5cIiwgXCJzd1wiLCBcIm53XCIsIFwic2VcIiwgXCJuZVwiXSkpO1xuLy8gQ3VzdG9tIGNvbXBvbmVudCBmb3IgcmVzaXplIGhhbmRsZXNcbmNvbnN0IHJlc2l6ZUhhbmRsZVR5cGUgLyo6IFJlYWN0UHJvcHNDaGFpbmFibGVUeXBlQ2hlY2tlciovID0gZXhwb3J0cy5yZXNpemVIYW5kbGVUeXBlID0gX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUsIF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jXSk7XG4vKjo6IGV4cG9ydCB0eXBlIFByb3BzID0ge3xcbiAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gIHN0eWxlOiBPYmplY3QsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGF1dG9TaXplOiBib29sZWFuLFxuICBjb2xzOiBudW1iZXIsXG4gIGRyYWdnYWJsZUNhbmNlbDogc3RyaW5nLFxuICBkcmFnZ2FibGVIYW5kbGU6IHN0cmluZyxcbiAgdmVydGljYWxDb21wYWN0OiBib29sZWFuLFxuICBjb21wYWN0VHlwZTogQ29tcGFjdFR5cGUsXG4gIGxheW91dDogTGF5b3V0LFxuICBtYXJnaW46IFtudW1iZXIsIG51bWJlcl0sXG4gIGNvbnRhaW5lclBhZGRpbmc6ID9bbnVtYmVyLCBudW1iZXJdLFxuICByb3dIZWlnaHQ6IG51bWJlcixcbiAgbWF4Um93czogbnVtYmVyLFxuICBpc0JvdW5kZWQ6IGJvb2xlYW4sXG4gIGlzRHJhZ2dhYmxlOiBib29sZWFuLFxuICBpc1Jlc2l6YWJsZTogYm9vbGVhbixcbiAgaXNEcm9wcGFibGU6IGJvb2xlYW4sXG4gIHByZXZlbnRDb2xsaXNpb246IGJvb2xlYW4sXG4gIHVzZUNTU1RyYW5zZm9ybXM6IGJvb2xlYW4sXG4gIHRyYW5zZm9ybVNjYWxlOiBudW1iZXIsXG4gIGRyb3BwaW5nSXRlbTogJFNoYXBlPExheW91dEl0ZW0+LFxuICByZXNpemVIYW5kbGVzOiBSZXNpemVIYW5kbGVBeGlzW10sXG4gIHJlc2l6ZUhhbmRsZT86IFJlc2l6ZUhhbmRsZSxcbiAgYWxsb3dPdmVybGFwOiBib29sZWFuLFxuXG4gIC8vIENhbGxiYWNrc1xuICBvbkxheW91dENoYW5nZTogTGF5b3V0ID0+IHZvaWQsXG4gIG9uRHJhZzogRXZlbnRDYWxsYmFjayxcbiAgb25EcmFnU3RhcnQ6IEV2ZW50Q2FsbGJhY2ssXG4gIG9uRHJhZ1N0b3A6IEV2ZW50Q2FsbGJhY2ssXG4gIG9uUmVzaXplOiBFdmVudENhbGxiYWNrLFxuICBvblJlc2l6ZVN0YXJ0OiBFdmVudENhbGxiYWNrLFxuICBvblJlc2l6ZVN0b3A6IEV2ZW50Q2FsbGJhY2ssXG4gIG9uRHJvcERyYWdPdmVyOiAoZTogRHJhZ092ZXJFdmVudCkgPT4gPyh7fCB3PzogbnVtYmVyLCBoPzogbnVtYmVyIHx9IHwgZmFsc2UpLFxuICBvbkRyb3A6IChsYXlvdXQ6IExheW91dCwgaXRlbTogP0xheW91dEl0ZW0sIGU6IEV2ZW50KSA9PiB2b2lkLFxuICBjaGlsZHJlbjogUmVhY3RDaGlsZHJlbkFycmF5PFJlYWN0RWxlbWVudDxhbnk+PixcbiAgaW5uZXJSZWY/OiBSZWY8XCJkaXZcIj5cbnx9OyovXG4vKjo6IGV4cG9ydCB0eXBlIERlZmF1bHRQcm9wcyA9ICREaWZmPFxuICBQcm9wcyxcbiAge1xuICAgIGNoaWxkcmVuOiBSZWFjdENoaWxkcmVuQXJyYXk8UmVhY3RFbGVtZW50PGFueT4+LFxuICAgIHdpZHRoOiBudW1iZXJcbiAgfVxuPjsqL1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAvL1xuICAvLyBCYXNpYyBwcm9wc1xuICAvL1xuICBjbGFzc05hbWU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIHN0eWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LFxuICAvLyBUaGlzIGNhbiBiZSBzZXQgZXhwbGljaXRseS4gSWYgaXQgaXMgbm90IHNldCwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5XG4gIC8vIGJlIHNldCB0byB0aGUgY29udGFpbmVyIHdpZHRoLiBOb3RlIHRoYXQgcmVzaXplcyB3aWxsICpub3QqIGNhdXNlIHRoaXMgdG8gYWRqdXN0LlxuICAvLyBJZiB5b3UgbmVlZCB0aGF0IGJlaGF2aW9yLCB1c2UgV2lkdGhQcm92aWRlci5cbiAgd2lkdGg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8vIElmIHRydWUsIHRoZSBjb250YWluZXIgaGVpZ2h0IHN3ZWxscyBhbmQgY29udHJhY3RzIHRvIGZpdCBjb250ZW50c1xuICBhdXRvU2l6ZTogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8vICMgb2YgY29scy5cbiAgY29sczogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLy8gQSBzZWxlY3RvciB0aGF0IHdpbGwgbm90IGJlIGRyYWdnYWJsZS5cbiAgZHJhZ2dhYmxlQ2FuY2VsOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICAvLyBBIHNlbGVjdG9yIGZvciB0aGUgZHJhZ2dhYmxlIGhhbmRsZXJcbiAgZHJhZ2dhYmxlSGFuZGxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICAvLyBEZXByZWNhdGVkXG4gIHZlcnRpY2FsQ29tcGFjdDogZnVuY3Rpb24gKHByb3BzIC8qOiBQcm9wcyovKSB7XG4gICAgaWYgKHByb3BzLnZlcnRpY2FsQ29tcGFjdCA9PT0gZmFsc2UgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgIFwiYHZlcnRpY2FsQ29tcGFjdGAgb24gPFJlYWN0R3JpZExheW91dD4gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24uIFwiICsgJ1VzZSBgY29tcGFjdFR5cGVgOiBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIiB8IG51bGwuJyk7XG4gICAgfVxuICB9LFxuICAvLyBDaG9vc2UgdmVydGljYWwgb3IgaG90aXpvbnRhbCBjb21wYWN0aW9uXG4gIGNvbXBhY3RUeXBlOiAoX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFtcInZlcnRpY2FsXCIsIFwiaG9yaXpvbnRhbFwiXSkgLyo6IFJlYWN0UHJvcHNDaGFpbmFibGVUeXBlQ2hlY2tlciovKSxcbiAgLy8gbGF5b3V0IGlzIGFuIGFycmF5IG9mIG9iamVjdCB3aXRoIHRoZSBmb3JtYXQ6XG4gIC8vIHt4OiBOdW1iZXIsIHk6IE51bWJlciwgdzogTnVtYmVyLCBoOiBOdW1iZXIsIGk6IFN0cmluZ31cbiAgbGF5b3V0OiBmdW5jdGlvbiAocHJvcHMgLyo6IFByb3BzKi8pIHtcbiAgICB2YXIgbGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgIC8vIEkgaG9wZSB5b3UncmUgc2V0dGluZyB0aGUgZGF0YS1ncmlkIHByb3BlcnR5IG9uIHRoZSBncmlkIGl0ZW1zXG4gICAgaWYgKGxheW91dCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgcmVxdWlyZShcIi4vdXRpbHNcIikudmFsaWRhdGVMYXlvdXQobGF5b3V0LCBcImxheW91dFwiKTtcbiAgfSxcbiAgLy9cbiAgLy8gR3JpZCBEaW1lbnNpb25zXG4gIC8vXG5cbiAgLy8gTWFyZ2luIGJldHdlZW4gaXRlbXMgW3gsIHldIGluIHB4XG4gIG1hcmdpbjogKF9wcm9wVHlwZXMuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIpIC8qOiBSZWFjdFByb3BzQ2hhaW5hYmxlVHlwZUNoZWNrZXIqLyksXG4gIC8vIFBhZGRpbmcgaW5zaWRlIHRoZSBjb250YWluZXIgW3gsIHldIGluIHB4XG4gIGNvbnRhaW5lclBhZGRpbmc6IChfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSAvKjogUmVhY3RQcm9wc0NoYWluYWJsZVR5cGVDaGVja2VyKi8pLFxuICAvLyBSb3dzIGhhdmUgYSBzdGF0aWMgaGVpZ2h0LCBidXQgeW91IGNhbiBjaGFuZ2UgdGhpcyBiYXNlZCBvbiBicmVha3BvaW50cyBpZiB5b3UgbGlrZVxuICByb3dIZWlnaHQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8vIERlZmF1bHQgSW5maW5pdHksIGJ1dCB5b3UgY2FuIHNwZWNpZnkgYSBtYXggaGVyZSBpZiB5b3UgbGlrZS5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXNuJ3QgZnVsbHkgZmxlc2hlZCBvdXQgYW5kIHdvbid0IGVycm9yIGlmIHlvdSBzcGVjaWZ5IGEgbGF5b3V0IHRoYXRcbiAgLy8gZXh0ZW5kcyBiZXlvbmQgdGhlIHJvdyBjYXBhY2l0eS4gSXQgd2lsbCwgaG93ZXZlciwgbm90IGFsbG93IHVzZXJzIHRvIGRyYWcvcmVzaXplXG4gIC8vIGFuIGl0ZW0gcGFzdCB0aGUgYmFycmllci4gVGhleSBjYW4gcHVzaCBpdGVtcyBiZXlvbmQgdGhlIGJhcnJpZXIsIHRob3VnaC5cbiAgLy8gSW50ZW50aW9uYWxseSBub3QgZG9jdW1lbnRlZCBmb3IgdGhpcyByZWFzb24uXG4gIG1heFJvd3M6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8vXG4gIC8vIEZsYWdzXG4gIC8vXG4gIGlzQm91bmRlZDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIGlzRHJhZ2dhYmxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgaXNSZXNpemFibGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyBJZiB0cnVlLCBncmlkIGNhbiBiZSBwbGFjZWQgb25lIG92ZXIgdGhlIG90aGVyLlxuICBhbGxvd092ZXJsYXA6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyBJZiB0cnVlLCBncmlkIGl0ZW1zIHdvbid0IGNoYW5nZSBwb3NpdGlvbiB3aGVuIGJlaW5nIGRyYWdnZWQgb3Zlci5cbiAgcHJldmVudENvbGxpc2lvbjogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8vIFVzZSBDU1MgdHJhbnNmb3JtcyBpbnN0ZWFkIG9mIHRvcC9sZWZ0XG4gIHVzZUNTU1RyYW5zZm9ybXM6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyBwYXJlbnQgbGF5b3V0IHRyYW5zZm9ybSBzY2FsZVxuICB0cmFuc2Zvcm1TY2FsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLy8gSWYgdHJ1ZSwgYW4gZXh0ZXJuYWwgZWxlbWVudCBjYW4gdHJpZ2dlciBvbkRyb3AgY2FsbGJhY2sgd2l0aCBhIHNwZWNpZmljIGdyaWQgcG9zaXRpb24gYXMgYSBwYXJhbWV0ZXJcbiAgaXNEcm9wcGFibGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyBSZXNpemUgaGFuZGxlIG9wdGlvbnNcbiAgcmVzaXplSGFuZGxlczogcmVzaXplSGFuZGxlQXhlc1R5cGUsXG4gIHJlc2l6ZUhhbmRsZTogcmVzaXplSGFuZGxlVHlwZSxcbiAgLy9cbiAgLy8gQ2FsbGJhY2tzXG4gIC8vXG5cbiAgLy8gQ2FsbGJhY2sgc28geW91IGNhbiBzYXZlIHRoZSBsYXlvdXQuIENhbGxzIGFmdGVyIGVhY2ggZHJhZyAmIHJlc2l6ZSBzdG9wcy5cbiAgb25MYXlvdXRDaGFuZ2U6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvLyBDYWxscyB3aGVuIGRyYWcgc3RhcnRzLiBDYWxsYmFjayBpcyBvZiB0aGUgc2lnbmF0dXJlIChsYXlvdXQsIG9sZEl0ZW0sIG5ld0l0ZW0sIHBsYWNlaG9sZGVyLCBlLCA/bm9kZSkuXG4gIC8vIEFsbCBjYWxsYmFja3MgYmVsb3cgaGF2ZSB0aGUgc2FtZSBzaWduYXR1cmUuICdzdGFydCcgYW5kICdzdG9wJyBjYWxsYmFja3Mgb21pdCB0aGUgJ3BsYWNlaG9sZGVyJy5cbiAgb25EcmFnU3RhcnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvLyBDYWxscyBvbiBlYWNoIGRyYWcgbW92ZW1lbnQuXG4gIG9uRHJhZzogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIHdoZW4gZHJhZyBpcyBjb21wbGV0ZS5cbiAgb25EcmFnU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vQ2FsbHMgd2hlbiByZXNpemUgc3RhcnRzLlxuICBvblJlc2l6ZVN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbHMgd2hlbiByZXNpemUgbW92ZW1lbnQgaGFwcGVucy5cbiAgb25SZXNpemU6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvLyBDYWxscyB3aGVuIHJlc2l6ZSBpcyBjb21wbGV0ZS5cbiAgb25SZXNpemVTdG9wOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbHMgd2hlbiBzb21lIGVsZW1lbnQgaXMgZHJvcHBlZC5cbiAgb25Ecm9wOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy9cbiAgLy8gT3RoZXIgdmFsaWRhdGlvbnNcbiAgLy9cblxuICBkcm9wcGluZ0l0ZW06IChfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIGk6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICB3OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgaDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkXG4gIH0pIC8qOiBSZWFjdFByb3BzQ2hhaW5hYmxlVHlwZUNoZWNrZXIqLyksXG4gIC8vIENoaWxkcmVuIG11c3Qgbm90IGhhdmUgZHVwbGljYXRlIGtleXMuXG4gIGNoaWxkcmVuOiBmdW5jdGlvbiAocHJvcHMgLyo6IFByb3BzKi8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLykge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcHJvcHNbcHJvcE5hbWVdO1xuXG4gICAgLy8gQ2hlY2sgY2hpbGRyZW4ga2V5cyBmb3IgZHVwbGljYXRlcy4gVGhyb3cgaWYgZm91bmQuXG4gICAgY29uc3Qga2V5cyA9IHt9O1xuICAgIF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkPy5rZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKGtleXNbY2hpbGQua2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZSBjaGlsZCBrZXkgXCInICsgY2hpbGQua2V5ICsgJ1wiIGZvdW5kISBUaGlzIHdpbGwgY2F1c2UgcHJvYmxlbXMgaW4gUmVhY3RHcmlkTGF5b3V0LicpO1xuICAgICAgfVxuICAgICAga2V5c1tjaGlsZC5rZXldID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gT3B0aW9uYWwgcmVmIGZvciBnZXR0aW5nIGEgcmVmZXJlbmNlIGZvciB0aGUgd3JhcHBpbmcgZGl2LlxuICBpbm5lclJlZjogX3Byb3BUeXBlcy5kZWZhdWx0LmFueVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nvar _responsiveUtils = __webpack_require__(/*! ./responsiveUtils */ \"(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js\");\nvar _ReactGridLayout = _interopRequireDefault(__webpack_require__(/*! ./ReactGridLayout */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); } /*:: import { type Layout, type Pick } from \"./utils\";*/ /*:: import { type ResponsiveLayout, type OnLayoutChangeCallback, type Breakpoints } from \"./responsiveUtils\";*/\n// $FlowFixMe[method-unbinding]\nconst type = obj => Object.prototype.toString.call(obj);\n\n/**\n * Get a value of margin or containerPadding.\n *\n * @param  {Array | Object} param Margin | containerPadding, e.g. [10, 10] | {lg: [10, 10], ...}.\n * @param  {String} breakpoint   Breakpoint: lg, md, sm, xs and etc.\n * @return {Array}\n */\nfunction getIndentationValue /*:: <T: ?[number, number]>*/(param /*: { [key: string]: T } | T*/, breakpoint /*: string*/) /*: T*/{\n  // $FlowIgnore TODO fix this typedef\n  if (param == null) return null;\n  // $FlowIgnore TODO fix this typedef\n  return Array.isArray(param) ? param : param[breakpoint];\n}\n/*:: type State = {\n  layout: Layout,\n  breakpoint: string,\n  cols: number,\n  layouts?: ResponsiveLayout<string>\n};*/\n/*:: type Props<Breakpoint: string = string> = {|\n  ...React.ElementConfig<typeof ReactGridLayout>,\n\n  // Responsive config\n  breakpoint?: ?Breakpoint,\n  breakpoints: Breakpoints<Breakpoint>,\n  cols: { [key: Breakpoint]: number },\n  layouts: ResponsiveLayout<Breakpoint>,\n  width: number,\n  margin: { [key: Breakpoint]: [number, number] } | [number, number],\n  /* prettier-ignore *-/\n  containerPadding: { [key: Breakpoint]: ?[number, number] } | ?[number, number],\n\n  // Callbacks\n  onBreakpointChange: (Breakpoint, cols: number) => void,\n  onLayoutChange: OnLayoutChangeCallback,\n  onWidthChange: (\n    containerWidth: number,\n    margin: [number, number],\n    cols: number,\n    containerPadding: ?[number, number]\n  ) => void\n|};*/\n/*:: type DefaultProps = Pick<\n  Props<>,\n  {|\n    allowOverlap: 0,\n    breakpoints: 0,\n    cols: 0,\n    containerPadding: 0,\n    layouts: 0,\n    margin: 0,\n    onBreakpointChange: 0,\n    onLayoutChange: 0,\n    onWidthChange: 0\n  |}\n>;*/\nclass ResponsiveReactGridLayout extends React.Component\n/*:: <\n  Props<>,\n  State\n>*/\n{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", this.generateInitialState());\n    // wrap layouts so we do not need to pass layouts to child\n    _defineProperty(this, \"onLayoutChange\", (layout /*: Layout*/) => {\n      this.props.onLayoutChange(layout, {\n        ...this.props.layouts,\n        [this.state.breakpoint]: layout\n      });\n    });\n  }\n  generateInitialState() /*: State*/{\n    const {\n      width,\n      breakpoints,\n      layouts,\n      cols\n    } = this.props;\n    const breakpoint = (0, _responsiveUtils.getBreakpointFromWidth)(breakpoints, width);\n    const colNo = (0, _responsiveUtils.getColsFromBreakpoint)(breakpoint, cols);\n    // verticalCompact compatibility, now deprecated\n    const compactType = this.props.verticalCompact === false ? null : this.props.compactType;\n    // Get the initial layout. This can tricky; we try to generate one however possible if one doesn't exist\n    // for this layout.\n    const initialLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, breakpoint, breakpoint, colNo, compactType);\n    return {\n      layout: initialLayout,\n      breakpoint: breakpoint,\n      cols: colNo\n    };\n  }\n  static getDerivedStateFromProps(nextProps /*: Props<*>*/, prevState /*: State*/) /*: ?$Shape<State>*/{\n    if (!(0, _fastEquals.deepEqual)(nextProps.layouts, prevState.layouts)) {\n      // Allow parent to set layouts directly.\n      const {\n        breakpoint,\n        cols\n      } = prevState;\n\n      // Since we're setting an entirely new layout object, we must generate a new responsive layout\n      // if one does not exist.\n      const newLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(nextProps.layouts, nextProps.breakpoints, breakpoint, breakpoint, cols, nextProps.compactType);\n      return {\n        layout: newLayout,\n        layouts: nextProps.layouts\n      };\n    }\n    return null;\n  }\n  componentDidUpdate(prevProps /*: Props<*>*/) {\n    // Allow parent to set width or breakpoint directly.\n    if (this.props.width != prevProps.width || this.props.breakpoint !== prevProps.breakpoint || !(0, _fastEquals.deepEqual)(this.props.breakpoints, prevProps.breakpoints) || !(0, _fastEquals.deepEqual)(this.props.cols, prevProps.cols)) {\n      this.onWidthChange(prevProps);\n    }\n  }\n  /**\n   * When the width changes work through breakpoints and reset state with the new width & breakpoint.\n   * Width changes are necessary to figure out the widget widths.\n   */\n  onWidthChange(prevProps /*: Props<*>*/) {\n    const {\n      breakpoints,\n      cols,\n      layouts,\n      compactType\n    } = this.props;\n    const newBreakpoint = this.props.breakpoint || (0, _responsiveUtils.getBreakpointFromWidth)(this.props.breakpoints, this.props.width);\n    const lastBreakpoint = this.state.breakpoint;\n    const newCols /*: number*/ = (0, _responsiveUtils.getColsFromBreakpoint)(newBreakpoint, cols);\n    const newLayouts = {\n      ...layouts\n    };\n\n    // Breakpoint change\n    if (lastBreakpoint !== newBreakpoint || prevProps.breakpoints !== breakpoints || prevProps.cols !== cols) {\n      // Preserve the current layout if the current breakpoint is not present in the next layouts.\n      if (!(lastBreakpoint in newLayouts)) newLayouts[lastBreakpoint] = (0, _utils.cloneLayout)(this.state.layout);\n\n      // Find or generate a new layout.\n      let layout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(newLayouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactType);\n\n      // This adds missing items.\n      layout = (0, _utils.synchronizeLayoutWithChildren)(layout, this.props.children, newCols, compactType, this.props.allowOverlap);\n\n      // Store the new layout.\n      newLayouts[newBreakpoint] = layout;\n\n      // callbacks\n      this.props.onBreakpointChange(newBreakpoint, newCols);\n      this.props.onLayoutChange(layout, newLayouts);\n      this.setState({\n        breakpoint: newBreakpoint,\n        layout: layout,\n        cols: newCols\n      });\n    }\n    const margin = getIndentationValue(this.props.margin, newBreakpoint);\n    const containerPadding = getIndentationValue(this.props.containerPadding, newBreakpoint);\n\n    //call onWidthChange on every change of width, not only on breakpoint changes\n    this.props.onWidthChange(this.props.width, margin, newCols, containerPadding);\n  }\n  render() /*: React.Element<typeof ReactGridLayout>*/{\n    /* eslint-disable no-unused-vars */\n    const {\n      breakpoint,\n      breakpoints,\n      cols,\n      layouts,\n      margin,\n      containerPadding,\n      onBreakpointChange,\n      onLayoutChange,\n      onWidthChange,\n      ...other\n    } = this.props;\n    /* eslint-enable no-unused-vars */\n\n    return /*#__PURE__*/React.createElement(_ReactGridLayout.default, _extends({}, other, {\n      // $FlowIgnore should allow nullable here due to DefaultProps\n      margin: getIndentationValue(margin, this.state.breakpoint),\n      containerPadding: getIndentationValue(containerPadding, this.state.breakpoint),\n      onLayoutChange: this.onLayoutChange,\n      layout: this.state.layout,\n      cols: this.state.cols\n    }));\n  }\n}\nexports[\"default\"] = ResponsiveReactGridLayout;\n// This should only include propTypes needed in this code; RGL itself\n// will do validation of the rest props passed to it.\n_defineProperty(ResponsiveReactGridLayout, \"propTypes\", {\n  //\n  // Basic props\n  //\n\n  // Optional, but if you are managing width yourself you may want to set the breakpoint\n  // yourself as well.\n  breakpoint: _propTypes.default.string,\n  // {name: pxVal}, e.g. {lg: 1200, md: 996, sm: 768, xs: 480}\n  breakpoints: _propTypes.default.object,\n  allowOverlap: _propTypes.default.bool,\n  // # of cols. This is a breakpoint -> cols map\n  cols: _propTypes.default.object,\n  // # of margin. This is a breakpoint -> margin map\n  // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }\n  // Margin between items [x, y] in px\n  // e.g. [10, 10]\n  margin: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),\n  // # of containerPadding. This is a breakpoint -> containerPadding map\n  // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }\n  // Padding inside the container [x, y] in px\n  // e.g. [10, 10]\n  containerPadding: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),\n  // layouts is an object mapping breakpoints to layouts.\n  // e.g. {lg: Layout, md: Layout, ...}\n  layouts(props /*: Props<>*/, propName /*: string*/) {\n    if (type(props[propName]) !== \"[object Object]\") {\n      throw new Error(\"Layout property must be an object. Received: \" + type(props[propName]));\n    }\n    Object.keys(props[propName]).forEach(key => {\n      if (!(key in props.breakpoints)) {\n        throw new Error(\"Each key in layouts must align with a key in breakpoints.\");\n      }\n      (0, _utils.validateLayout)(props.layouts[key], \"layouts.\" + key);\n    });\n  },\n  // The width of this component.\n  // Required in this propTypes stanza because generateInitialState() will fail without it.\n  width: _propTypes.default.number.isRequired,\n  //\n  // Callbacks\n  //\n\n  // Calls back with breakpoint and new # cols\n  onBreakpointChange: _propTypes.default.func,\n  // Callback so you can save the layout.\n  // Calls back with (currentLayout, allLayouts). allLayouts are keyed by breakpoint.\n  onLayoutChange: _propTypes.default.func,\n  // Calls back with (containerWidth, margin, cols, containerPadding)\n  onWidthChange: _propTypes.default.func\n});\n_defineProperty(ResponsiveReactGridLayout, \"defaultProps\", {\n  breakpoints: {\n    lg: 1200,\n    md: 996,\n    sm: 768,\n    xs: 480,\n    xxs: 0\n  },\n  cols: {\n    lg: 12,\n    md: 10,\n    sm: 6,\n    xs: 4,\n    xxs: 2\n  },\n  containerPadding: {\n    lg: null,\n    md: null,\n    sm: null,\n    xs: null,\n    xxs: null\n  },\n  layouts: {},\n  margin: [10, 10],\n  allowOverlap: false,\n  onBreakpointChange: _utils.noop,\n  onLayoutChange: _utils.noop,\n  onWidthChange: _utils.noop\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLG9DQUFvQyxtQkFBTyxDQUFDLHdHQUFPO0FBQ25ELHdDQUF3QyxtQkFBTyxDQUFDLDREQUFZO0FBQzVELGtCQUFrQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxzRUFBUztBQUM5Qix1QkFBdUIsbUJBQU8sQ0FBQywwRkFBbUI7QUFDbEQsOENBQThDLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3pFLHFDQUFxQyxpQ0FBaUM7QUFDdEUseUNBQXlDLDRFQUE0RSxvREFBb0QsdUNBQXVDLGdCQUFnQiwrQkFBK0IsNEVBQTRFLHFCQUFxQiwrQkFBK0IsZUFBZSx3Q0FBd0MsMkpBQTJKLFdBQVc7QUFDNWxCLHNCQUFzQix3RUFBd0UsZ0JBQWdCLHNCQUFzQixPQUFPLHNCQUFzQixvQkFBb0IsZ0RBQWdELFdBQVc7QUFDaFAsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUUsZ0RBQWdELGNBQWMseUJBQXlCLGVBQWUsaUJBQWlCLHVFQUF1RSx5QkFBeUI7QUFDaGU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQixrREFBa0Qsa0JBQWtCO0FBQ2hHLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQSx1RUFBdUUsbUJBQW1CO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0EsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQSxzQkFBc0IsdUNBQXVDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWU7QUFDZiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVksUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RvY2ttYXN0ZXItaW1zLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL1Jlc3BvbnNpdmVSZWFjdEdyaWRMYXlvdXQuanM/ZjRhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIF9mYXN0RXF1YWxzID0gcmVxdWlyZShcImZhc3QtZXF1YWxzXCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIF9yZXNwb25zaXZlVXRpbHMgPSByZXF1aXJlKFwiLi9yZXNwb25zaXZlVXRpbHNcIik7XG52YXIgX1JlYWN0R3JpZExheW91dCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUmVhY3RHcmlkTGF5b3V0XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHQpIHsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgV2Vha01hcCkgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCBuID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIChlLCB0KSB7IGlmICghdCAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IHZhciBvLCBpLCBmID0geyBfX3Byb3RvX186IG51bGwsIGRlZmF1bHQ6IGUgfTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiBmOyBpZiAobyA9IHQgPyBuIDogcikgeyBpZiAoby5oYXMoZSkpIHJldHVybiBvLmdldChlKTsgby5zZXQoZSwgZik7IH0gZm9yIChjb25zdCB0IGluIGUpIFwiZGVmYXVsdFwiICE9PSB0ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdCkgJiYgKChpID0gKG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdCkpICYmIChpLmdldCB8fCBpLnNldCkgPyBvKGYsIHQsIGkpIDogZlt0XSA9IGVbdF0pOyByZXR1cm4gZjsgfSkoZSwgdCk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAobikgeyBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykgeyB2YXIgdCA9IGFyZ3VtZW50c1tlXTsgZm9yICh2YXIgciBpbiB0KSAoe30pLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgJiYgKG5bcl0gPSB0W3JdKTsgfSByZXR1cm4gbjsgfSwgX2V4dGVuZHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKjo6IGltcG9ydCB7IHR5cGUgTGF5b3V0LCB0eXBlIFBpY2sgfSBmcm9tIFwiLi91dGlsc1wiOyovIC8qOjogaW1wb3J0IHsgdHlwZSBSZXNwb25zaXZlTGF5b3V0LCB0eXBlIE9uTGF5b3V0Q2hhbmdlQ2FsbGJhY2ssIHR5cGUgQnJlYWtwb2ludHMgfSBmcm9tIFwiLi9yZXNwb25zaXZlVXRpbHNcIjsqL1xuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuY29uc3QgdHlwZSA9IG9iaiA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcblxuLyoqXG4gKiBHZXQgYSB2YWx1ZSBvZiBtYXJnaW4gb3IgY29udGFpbmVyUGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheSB8IE9iamVjdH0gcGFyYW0gTWFyZ2luIHwgY29udGFpbmVyUGFkZGluZywgZS5nLiBbMTAsIDEwXSB8IHtsZzogWzEwLCAxMF0sIC4uLn0uXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJyZWFrcG9pbnQgICBCcmVha3BvaW50OiBsZywgbWQsIHNtLCB4cyBhbmQgZXRjLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uVmFsdWUgLyo6OiA8VDogP1tudW1iZXIsIG51bWJlcl0+Ki8ocGFyYW0gLyo6IHsgW2tleTogc3RyaW5nXTogVCB9IHwgVCovLCBicmVha3BvaW50IC8qOiBzdHJpbmcqLykgLyo6IFQqL3tcbiAgLy8gJEZsb3dJZ25vcmUgVE9ETyBmaXggdGhpcyB0eXBlZGVmXG4gIGlmIChwYXJhbSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgLy8gJEZsb3dJZ25vcmUgVE9ETyBmaXggdGhpcyB0eXBlZGVmXG4gIHJldHVybiBBcnJheS5pc0FycmF5KHBhcmFtKSA/IHBhcmFtIDogcGFyYW1bYnJlYWtwb2ludF07XG59XG4vKjo6IHR5cGUgU3RhdGUgPSB7XG4gIGxheW91dDogTGF5b3V0LFxuICBicmVha3BvaW50OiBzdHJpbmcsXG4gIGNvbHM6IG51bWJlcixcbiAgbGF5b3V0cz86IFJlc3BvbnNpdmVMYXlvdXQ8c3RyaW5nPlxufTsqL1xuLyo6OiB0eXBlIFByb3BzPEJyZWFrcG9pbnQ6IHN0cmluZyA9IHN0cmluZz4gPSB7fFxuICAuLi5SZWFjdC5FbGVtZW50Q29uZmlnPHR5cGVvZiBSZWFjdEdyaWRMYXlvdXQ+LFxuXG4gIC8vIFJlc3BvbnNpdmUgY29uZmlnXG4gIGJyZWFrcG9pbnQ/OiA/QnJlYWtwb2ludCxcbiAgYnJlYWtwb2ludHM6IEJyZWFrcG9pbnRzPEJyZWFrcG9pbnQ+LFxuICBjb2xzOiB7IFtrZXk6IEJyZWFrcG9pbnRdOiBudW1iZXIgfSxcbiAgbGF5b3V0czogUmVzcG9uc2l2ZUxheW91dDxCcmVha3BvaW50PixcbiAgd2lkdGg6IG51bWJlcixcbiAgbWFyZ2luOiB7IFtrZXk6IEJyZWFrcG9pbnRdOiBbbnVtYmVyLCBudW1iZXJdIH0gfCBbbnVtYmVyLCBudW1iZXJdLFxuICAvKiBwcmV0dGllci1pZ25vcmUgKi0vXG4gIGNvbnRhaW5lclBhZGRpbmc6IHsgW2tleTogQnJlYWtwb2ludF06ID9bbnVtYmVyLCBudW1iZXJdIH0gfCA/W251bWJlciwgbnVtYmVyXSxcblxuICAvLyBDYWxsYmFja3NcbiAgb25CcmVha3BvaW50Q2hhbmdlOiAoQnJlYWtwb2ludCwgY29sczogbnVtYmVyKSA9PiB2b2lkLFxuICBvbkxheW91dENoYW5nZTogT25MYXlvdXRDaGFuZ2VDYWxsYmFjayxcbiAgb25XaWR0aENoYW5nZTogKFxuICAgIGNvbnRhaW5lcldpZHRoOiBudW1iZXIsXG4gICAgbWFyZ2luOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgIGNvbHM6IG51bWJlcixcbiAgICBjb250YWluZXJQYWRkaW5nOiA/W251bWJlciwgbnVtYmVyXVxuICApID0+IHZvaWRcbnx9OyovXG4vKjo6IHR5cGUgRGVmYXVsdFByb3BzID0gUGljazxcbiAgUHJvcHM8PixcbiAge3xcbiAgICBhbGxvd092ZXJsYXA6IDAsXG4gICAgYnJlYWtwb2ludHM6IDAsXG4gICAgY29sczogMCxcbiAgICBjb250YWluZXJQYWRkaW5nOiAwLFxuICAgIGxheW91dHM6IDAsXG4gICAgbWFyZ2luOiAwLFxuICAgIG9uQnJlYWtwb2ludENoYW5nZTogMCxcbiAgICBvbkxheW91dENoYW5nZTogMCxcbiAgICBvbldpZHRoQ2hhbmdlOiAwXG4gIHx9XG4+OyovXG5jbGFzcyBSZXNwb25zaXZlUmVhY3RHcmlkTGF5b3V0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50XG4vKjo6IDxcbiAgUHJvcHM8PixcbiAgU3RhdGVcbj4qL1xue1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHRoaXMuZ2VuZXJhdGVJbml0aWFsU3RhdGUoKSk7XG4gICAgLy8gd3JhcCBsYXlvdXRzIHNvIHdlIGRvIG5vdCBuZWVkIHRvIHBhc3MgbGF5b3V0cyB0byBjaGlsZFxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uTGF5b3V0Q2hhbmdlXCIsIChsYXlvdXQgLyo6IExheW91dCovKSA9PiB7XG4gICAgICB0aGlzLnByb3BzLm9uTGF5b3V0Q2hhbmdlKGxheW91dCwge1xuICAgICAgICAuLi50aGlzLnByb3BzLmxheW91dHMsXG4gICAgICAgIFt0aGlzLnN0YXRlLmJyZWFrcG9pbnRdOiBsYXlvdXRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGdlbmVyYXRlSW5pdGlhbFN0YXRlKCkgLyo6IFN0YXRlKi97XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBicmVha3BvaW50cyxcbiAgICAgIGxheW91dHMsXG4gICAgICBjb2xzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgYnJlYWtwb2ludCA9ICgwLCBfcmVzcG9uc2l2ZVV0aWxzLmdldEJyZWFrcG9pbnRGcm9tV2lkdGgpKGJyZWFrcG9pbnRzLCB3aWR0aCk7XG4gICAgY29uc3QgY29sTm8gPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5nZXRDb2xzRnJvbUJyZWFrcG9pbnQpKGJyZWFrcG9pbnQsIGNvbHMpO1xuICAgIC8vIHZlcnRpY2FsQ29tcGFjdCBjb21wYXRpYmlsaXR5LCBub3cgZGVwcmVjYXRlZFxuICAgIGNvbnN0IGNvbXBhY3RUeXBlID0gdGhpcy5wcm9wcy52ZXJ0aWNhbENvbXBhY3QgPT09IGZhbHNlID8gbnVsbCA6IHRoaXMucHJvcHMuY29tcGFjdFR5cGU7XG4gICAgLy8gR2V0IHRoZSBpbml0aWFsIGxheW91dC4gVGhpcyBjYW4gdHJpY2t5OyB3ZSB0cnkgdG8gZ2VuZXJhdGUgb25lIGhvd2V2ZXIgcG9zc2libGUgaWYgb25lIGRvZXNuJ3QgZXhpc3RcbiAgICAvLyBmb3IgdGhpcyBsYXlvdXQuXG4gICAgY29uc3QgaW5pdGlhbExheW91dCA9ICgwLCBfcmVzcG9uc2l2ZVV0aWxzLmZpbmRPckdlbmVyYXRlUmVzcG9uc2l2ZUxheW91dCkobGF5b3V0cywgYnJlYWtwb2ludHMsIGJyZWFrcG9pbnQsIGJyZWFrcG9pbnQsIGNvbE5vLCBjb21wYWN0VHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxheW91dDogaW5pdGlhbExheW91dCxcbiAgICAgIGJyZWFrcG9pbnQ6IGJyZWFrcG9pbnQsXG4gICAgICBjb2xzOiBjb2xOb1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMgLyo6IFByb3BzPCo+Ki8sIHByZXZTdGF0ZSAvKjogU3RhdGUqLykgLyo6ID8kU2hhcGU8U3RhdGU+Ki97XG4gICAgaWYgKCEoMCwgX2Zhc3RFcXVhbHMuZGVlcEVxdWFsKShuZXh0UHJvcHMubGF5b3V0cywgcHJldlN0YXRlLmxheW91dHMpKSB7XG4gICAgICAvLyBBbGxvdyBwYXJlbnQgdG8gc2V0IGxheW91dHMgZGlyZWN0bHkuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGJyZWFrcG9pbnQsXG4gICAgICAgIGNvbHNcbiAgICAgIH0gPSBwcmV2U3RhdGU7XG5cbiAgICAgIC8vIFNpbmNlIHdlJ3JlIHNldHRpbmcgYW4gZW50aXJlbHkgbmV3IGxheW91dCBvYmplY3QsIHdlIG11c3QgZ2VuZXJhdGUgYSBuZXcgcmVzcG9uc2l2ZSBsYXlvdXRcbiAgICAgIC8vIGlmIG9uZSBkb2VzIG5vdCBleGlzdC5cbiAgICAgIGNvbnN0IG5ld0xheW91dCA9ICgwLCBfcmVzcG9uc2l2ZVV0aWxzLmZpbmRPckdlbmVyYXRlUmVzcG9uc2l2ZUxheW91dCkobmV4dFByb3BzLmxheW91dHMsIG5leHRQcm9wcy5icmVha3BvaW50cywgYnJlYWtwb2ludCwgYnJlYWtwb2ludCwgY29scywgbmV4dFByb3BzLmNvbXBhY3RUeXBlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxheW91dDogbmV3TGF5b3V0LFxuICAgICAgICBsYXlvdXRzOiBuZXh0UHJvcHMubGF5b3V0c1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcyAvKjogUHJvcHM8Kj4qLykge1xuICAgIC8vIEFsbG93IHBhcmVudCB0byBzZXQgd2lkdGggb3IgYnJlYWtwb2ludCBkaXJlY3RseS5cbiAgICBpZiAodGhpcy5wcm9wcy53aWR0aCAhPSBwcmV2UHJvcHMud2lkdGggfHwgdGhpcy5wcm9wcy5icmVha3BvaW50ICE9PSBwcmV2UHJvcHMuYnJlYWtwb2ludCB8fCAhKDAsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkodGhpcy5wcm9wcy5icmVha3BvaW50cywgcHJldlByb3BzLmJyZWFrcG9pbnRzKSB8fCAhKDAsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkodGhpcy5wcm9wcy5jb2xzLCBwcmV2UHJvcHMuY29scykpIHtcbiAgICAgIHRoaXMub25XaWR0aENoYW5nZShwcmV2UHJvcHMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogV2hlbiB0aGUgd2lkdGggY2hhbmdlcyB3b3JrIHRocm91Z2ggYnJlYWtwb2ludHMgYW5kIHJlc2V0IHN0YXRlIHdpdGggdGhlIG5ldyB3aWR0aCAmIGJyZWFrcG9pbnQuXG4gICAqIFdpZHRoIGNoYW5nZXMgYXJlIG5lY2Vzc2FyeSB0byBmaWd1cmUgb3V0IHRoZSB3aWRnZXQgd2lkdGhzLlxuICAgKi9cbiAgb25XaWR0aENoYW5nZShwcmV2UHJvcHMgLyo6IFByb3BzPCo+Ki8pIHtcbiAgICBjb25zdCB7XG4gICAgICBicmVha3BvaW50cyxcbiAgICAgIGNvbHMsXG4gICAgICBsYXlvdXRzLFxuICAgICAgY29tcGFjdFR5cGVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBuZXdCcmVha3BvaW50ID0gdGhpcy5wcm9wcy5icmVha3BvaW50IHx8ICgwLCBfcmVzcG9uc2l2ZVV0aWxzLmdldEJyZWFrcG9pbnRGcm9tV2lkdGgpKHRoaXMucHJvcHMuYnJlYWtwb2ludHMsIHRoaXMucHJvcHMud2lkdGgpO1xuICAgIGNvbnN0IGxhc3RCcmVha3BvaW50ID0gdGhpcy5zdGF0ZS5icmVha3BvaW50O1xuICAgIGNvbnN0IG5ld0NvbHMgLyo6IG51bWJlciovID0gKDAsIF9yZXNwb25zaXZlVXRpbHMuZ2V0Q29sc0Zyb21CcmVha3BvaW50KShuZXdCcmVha3BvaW50LCBjb2xzKTtcbiAgICBjb25zdCBuZXdMYXlvdXRzID0ge1xuICAgICAgLi4ubGF5b3V0c1xuICAgIH07XG5cbiAgICAvLyBCcmVha3BvaW50IGNoYW5nZVxuICAgIGlmIChsYXN0QnJlYWtwb2ludCAhPT0gbmV3QnJlYWtwb2ludCB8fCBwcmV2UHJvcHMuYnJlYWtwb2ludHMgIT09IGJyZWFrcG9pbnRzIHx8IHByZXZQcm9wcy5jb2xzICE9PSBjb2xzKSB7XG4gICAgICAvLyBQcmVzZXJ2ZSB0aGUgY3VycmVudCBsYXlvdXQgaWYgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCBpcyBub3QgcHJlc2VudCBpbiB0aGUgbmV4dCBsYXlvdXRzLlxuICAgICAgaWYgKCEobGFzdEJyZWFrcG9pbnQgaW4gbmV3TGF5b3V0cykpIG5ld0xheW91dHNbbGFzdEJyZWFrcG9pbnRdID0gKDAsIF91dGlscy5jbG9uZUxheW91dCkodGhpcy5zdGF0ZS5sYXlvdXQpO1xuXG4gICAgICAvLyBGaW5kIG9yIGdlbmVyYXRlIGEgbmV3IGxheW91dC5cbiAgICAgIGxldCBsYXlvdXQgPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5maW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQpKG5ld0xheW91dHMsIGJyZWFrcG9pbnRzLCBuZXdCcmVha3BvaW50LCBsYXN0QnJlYWtwb2ludCwgbmV3Q29scywgY29tcGFjdFR5cGUpO1xuXG4gICAgICAvLyBUaGlzIGFkZHMgbWlzc2luZyBpdGVtcy5cbiAgICAgIGxheW91dCA9ICgwLCBfdXRpbHMuc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4pKGxheW91dCwgdGhpcy5wcm9wcy5jaGlsZHJlbiwgbmV3Q29scywgY29tcGFjdFR5cGUsIHRoaXMucHJvcHMuYWxsb3dPdmVybGFwKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIG5ldyBsYXlvdXQuXG4gICAgICBuZXdMYXlvdXRzW25ld0JyZWFrcG9pbnRdID0gbGF5b3V0O1xuXG4gICAgICAvLyBjYWxsYmFja3NcbiAgICAgIHRoaXMucHJvcHMub25CcmVha3BvaW50Q2hhbmdlKG5ld0JyZWFrcG9pbnQsIG5ld0NvbHMpO1xuICAgICAgdGhpcy5wcm9wcy5vbkxheW91dENoYW5nZShsYXlvdXQsIG5ld0xheW91dHMpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGJyZWFrcG9pbnQ6IG5ld0JyZWFrcG9pbnQsXG4gICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICBjb2xzOiBuZXdDb2xzXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWFyZ2luID0gZ2V0SW5kZW50YXRpb25WYWx1ZSh0aGlzLnByb3BzLm1hcmdpbiwgbmV3QnJlYWtwb2ludCk7XG4gICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldEluZGVudGF0aW9uVmFsdWUodGhpcy5wcm9wcy5jb250YWluZXJQYWRkaW5nLCBuZXdCcmVha3BvaW50KTtcblxuICAgIC8vY2FsbCBvbldpZHRoQ2hhbmdlIG9uIGV2ZXJ5IGNoYW5nZSBvZiB3aWR0aCwgbm90IG9ubHkgb24gYnJlYWtwb2ludCBjaGFuZ2VzXG4gICAgdGhpcy5wcm9wcy5vbldpZHRoQ2hhbmdlKHRoaXMucHJvcHMud2lkdGgsIG1hcmdpbiwgbmV3Q29scywgY29udGFpbmVyUGFkZGluZyk7XG4gIH1cbiAgcmVuZGVyKCkgLyo6IFJlYWN0LkVsZW1lbnQ8dHlwZW9mIFJlYWN0R3JpZExheW91dD4qL3tcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGNvbnN0IHtcbiAgICAgIGJyZWFrcG9pbnQsXG4gICAgICBicmVha3BvaW50cyxcbiAgICAgIGNvbHMsXG4gICAgICBsYXlvdXRzLFxuICAgICAgbWFyZ2luLFxuICAgICAgY29udGFpbmVyUGFkZGluZyxcbiAgICAgIG9uQnJlYWtwb2ludENoYW5nZSxcbiAgICAgIG9uTGF5b3V0Q2hhbmdlLFxuICAgICAgb25XaWR0aENoYW5nZSxcbiAgICAgIC4uLm90aGVyXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9SZWFjdEdyaWRMYXlvdXQuZGVmYXVsdCwgX2V4dGVuZHMoe30sIG90aGVyLCB7XG4gICAgICAvLyAkRmxvd0lnbm9yZSBzaG91bGQgYWxsb3cgbnVsbGFibGUgaGVyZSBkdWUgdG8gRGVmYXVsdFByb3BzXG4gICAgICBtYXJnaW46IGdldEluZGVudGF0aW9uVmFsdWUobWFyZ2luLCB0aGlzLnN0YXRlLmJyZWFrcG9pbnQpLFxuICAgICAgY29udGFpbmVyUGFkZGluZzogZ2V0SW5kZW50YXRpb25WYWx1ZShjb250YWluZXJQYWRkaW5nLCB0aGlzLnN0YXRlLmJyZWFrcG9pbnQpLFxuICAgICAgb25MYXlvdXRDaGFuZ2U6IHRoaXMub25MYXlvdXRDaGFuZ2UsXG4gICAgICBsYXlvdXQ6IHRoaXMuc3RhdGUubGF5b3V0LFxuICAgICAgY29sczogdGhpcy5zdGF0ZS5jb2xzXG4gICAgfSkpO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSZXNwb25zaXZlUmVhY3RHcmlkTGF5b3V0O1xuLy8gVGhpcyBzaG91bGQgb25seSBpbmNsdWRlIHByb3BUeXBlcyBuZWVkZWQgaW4gdGhpcyBjb2RlOyBSR0wgaXRzZWxmXG4vLyB3aWxsIGRvIHZhbGlkYXRpb24gb2YgdGhlIHJlc3QgcHJvcHMgcGFzc2VkIHRvIGl0LlxuX2RlZmluZVByb3BlcnR5KFJlc3BvbnNpdmVSZWFjdEdyaWRMYXlvdXQsIFwicHJvcFR5cGVzXCIsIHtcbiAgLy9cbiAgLy8gQmFzaWMgcHJvcHNcbiAgLy9cblxuICAvLyBPcHRpb25hbCwgYnV0IGlmIHlvdSBhcmUgbWFuYWdpbmcgd2lkdGggeW91cnNlbGYgeW91IG1heSB3YW50IHRvIHNldCB0aGUgYnJlYWtwb2ludFxuICAvLyB5b3Vyc2VsZiBhcyB3ZWxsLlxuICBicmVha3BvaW50OiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICAvLyB7bmFtZTogcHhWYWx9LCBlLmcuIHtsZzogMTIwMCwgbWQ6IDk5Niwgc206IDc2OCwgeHM6IDQ4MH1cbiAgYnJlYWtwb2ludHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3QsXG4gIGFsbG93T3ZlcmxhcDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8vICMgb2YgY29scy4gVGhpcyBpcyBhIGJyZWFrcG9pbnQgLT4gY29scyBtYXBcbiAgY29sczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdCxcbiAgLy8gIyBvZiBtYXJnaW4uIFRoaXMgaXMgYSBicmVha3BvaW50IC0+IG1hcmdpbiBtYXBcbiAgLy8gZS5nLiB7IGxnOiBbNSwgNV0sIG1kOiBbMTAsIDEwXSwgc206IFsxNSwgMTVdIH1cbiAgLy8gTWFyZ2luIGJldHdlZW4gaXRlbXMgW3gsIHldIGluIHB4XG4gIC8vIGUuZy4gWzEwLCAxMF1cbiAgbWFyZ2luOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXksIF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3RdKSxcbiAgLy8gIyBvZiBjb250YWluZXJQYWRkaW5nLiBUaGlzIGlzIGEgYnJlYWtwb2ludCAtPiBjb250YWluZXJQYWRkaW5nIG1hcFxuICAvLyBlLmcuIHsgbGc6IFs1LCA1XSwgbWQ6IFsxMCwgMTBdLCBzbTogWzE1LCAxNV0gfVxuICAvLyBQYWRkaW5nIGluc2lkZSB0aGUgY29udGFpbmVyIFt4LCB5XSBpbiBweFxuICAvLyBlLmcuIFsxMCwgMTBdXG4gIGNvbnRhaW5lclBhZGRpbmc6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5hcnJheSwgX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdF0pLFxuICAvLyBsYXlvdXRzIGlzIGFuIG9iamVjdCBtYXBwaW5nIGJyZWFrcG9pbnRzIHRvIGxheW91dHMuXG4gIC8vIGUuZy4ge2xnOiBMYXlvdXQsIG1kOiBMYXlvdXQsIC4uLn1cbiAgbGF5b3V0cyhwcm9wcyAvKjogUHJvcHM8PiovLCBwcm9wTmFtZSAvKjogc3RyaW5nKi8pIHtcbiAgICBpZiAodHlwZShwcm9wc1twcm9wTmFtZV0pICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXlvdXQgcHJvcGVydHkgbXVzdCBiZSBhbiBvYmplY3QuIFJlY2VpdmVkOiBcIiArIHR5cGUocHJvcHNbcHJvcE5hbWVdKSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHByb3BzW3Byb3BOYW1lXSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3BzLmJyZWFrcG9pbnRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFYWNoIGtleSBpbiBsYXlvdXRzIG11c3QgYWxpZ24gd2l0aCBhIGtleSBpbiBicmVha3BvaW50cy5cIik7XG4gICAgICB9XG4gICAgICAoMCwgX3V0aWxzLnZhbGlkYXRlTGF5b3V0KShwcm9wcy5sYXlvdXRzW2tleV0sIFwibGF5b3V0cy5cIiArIGtleSk7XG4gICAgfSk7XG4gIH0sXG4gIC8vIFRoZSB3aWR0aCBvZiB0aGlzIGNvbXBvbmVudC5cbiAgLy8gUmVxdWlyZWQgaW4gdGhpcyBwcm9wVHlwZXMgc3RhbnphIGJlY2F1c2UgZ2VuZXJhdGVJbml0aWFsU3RhdGUoKSB3aWxsIGZhaWwgd2l0aG91dCBpdC5cbiAgd2lkdGg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLy9cbiAgLy8gQ2FsbGJhY2tzXG4gIC8vXG5cbiAgLy8gQ2FsbHMgYmFjayB3aXRoIGJyZWFrcG9pbnQgYW5kIG5ldyAjIGNvbHNcbiAgb25CcmVha3BvaW50Q2hhbmdlOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbGJhY2sgc28geW91IGNhbiBzYXZlIHRoZSBsYXlvdXQuXG4gIC8vIENhbGxzIGJhY2sgd2l0aCAoY3VycmVudExheW91dCwgYWxsTGF5b3V0cykuIGFsbExheW91dHMgYXJlIGtleWVkIGJ5IGJyZWFrcG9pbnQuXG4gIG9uTGF5b3V0Q2hhbmdlOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbHMgYmFjayB3aXRoIChjb250YWluZXJXaWR0aCwgbWFyZ2luLCBjb2xzLCBjb250YWluZXJQYWRkaW5nKVxuICBvbldpZHRoQ2hhbmdlOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuY1xufSk7XG5fZGVmaW5lUHJvcGVydHkoUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dCwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBicmVha3BvaW50czoge1xuICAgIGxnOiAxMjAwLFxuICAgIG1kOiA5OTYsXG4gICAgc206IDc2OCxcbiAgICB4czogNDgwLFxuICAgIHh4czogMFxuICB9LFxuICBjb2xzOiB7XG4gICAgbGc6IDEyLFxuICAgIG1kOiAxMCxcbiAgICBzbTogNixcbiAgICB4czogNCxcbiAgICB4eHM6IDJcbiAgfSxcbiAgY29udGFpbmVyUGFkZGluZzoge1xuICAgIGxnOiBudWxsLFxuICAgIG1kOiBudWxsLFxuICAgIHNtOiBudWxsLFxuICAgIHhzOiBudWxsLFxuICAgIHh4czogbnVsbFxuICB9LFxuICBsYXlvdXRzOiB7fSxcbiAgbWFyZ2luOiBbMTAsIDEwXSxcbiAgYWxsb3dPdmVybGFwOiBmYWxzZSxcbiAgb25CcmVha3BvaW50Q2hhbmdlOiBfdXRpbHMubm9vcCxcbiAgb25MYXlvdXRDaGFuZ2U6IF91dGlscy5ub29wLFxuICBvbldpZHRoQ2hhbmdlOiBfdXRpbHMubm9vcFxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/calculateUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcGridItemWHPx = calcGridItemWHPx;\nexports.calcWH = calcWH;\nexports.calcXY = calcXY;\nexports.clamp = clamp;\n/*:: import type { Position } from \"./utils\";*/\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\nfunction calcGridColWidth(positionParams /*: PositionParams*/) /*: number*/{\n  const {\n    margin,\n    containerPadding,\n    containerWidth,\n    cols\n  } = positionParams;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n}\n\n// This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\nfunction calcGridItemWHPx(gridUnits /*: number*/, colOrRowSize /*: number*/, marginPx /*: number*/) /*: number*/{\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\n\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\nfunction calcGridItemPosition(positionParams /*: PositionParams*/, x /*: number*/, y /*: number*/, w /*: number*/, h /*: number*/, state /*: ?Object*/) /*: Position*/{\n  const {\n    margin,\n    containerPadding,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n  const out = {};\n\n  // If resizing, use the exact width and height as returned from resizing callbacks.\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n    out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n  }\n\n  // If dragging, use the exact width and height as returned from dragging callbacks.\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } else if (state && state.resizing && typeof state.resizing.top === \"number\" && typeof state.resizing.left === \"number\") {\n    out.top = Math.round(state.resizing.top);\n    out.left = Math.round(state.resizing.left);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n    out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n  }\n  return out;\n}\n\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\nfunction calcXY(positionParams /*: PositionParams*/, top /*: number*/, left /*: number*/, w /*: number*/, h /*: number*/) /*: { x: number, y: number }*/{\n  const {\n    margin,\n    containerPadding,\n    cols,\n    rowHeight,\n    maxRows\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // left = containerPaddingX + x * (colWidth + marginX)\n  // x * (colWidth + marginX) = left - containerPaddingX\n  // x = (left - containerPaddingX) / (colWidth + marginX)\n  let x = Math.round((left - containerPadding[0]) / (colWidth + margin[0]));\n  let y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n  return {\n    x,\n    y\n  };\n}\n\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @param {String} handle Resize Handle.\n * @return {Object}                         w, h as grid units.\n */\nfunction calcWH(positionParams /*: PositionParams*/, width /*: number*/, height /*: number*/, x /*: number*/, y /*: number*/, handle /*: string*/) /*: { w: number, h: number }*/{\n  const {\n    margin,\n    maxRows,\n    cols,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n  let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  let h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  let _w = clamp(w, 0, cols - x);\n  let _h = clamp(h, 0, maxRows - y);\n  if ([\"sw\", \"w\", \"nw\"].indexOf(handle) !== -1) {\n    _w = clamp(w, 0, cols);\n  }\n  if ([\"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n    _h = clamp(h, 0, maxRows);\n  }\n  return {\n    w: _w,\n    h: _h\n  };\n}\n\n// Similar to _.clamp\nfunction clamp(num /*: number*/, lowerBound /*: number*/, upperBound /*: number*/) /*: number*/{\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvY2FsY3VsYXRlVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsY0FBYztBQUNkLGNBQWM7QUFDZCxhQUFhO0FBQ2IsbUJBQW1CLFdBQVcsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLGdDQUFnQztBQUM1QztBQUNBLGdJQUFnSSxzQkFBc0I7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGdDQUFnQztBQUM1QztBQUNBLHlKQUF5SixzQkFBc0I7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdG9ja21hc3Rlci1pbXMvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvY2FsY3VsYXRlVXRpbHMuanM/ODUwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2FsY0dyaWRDb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGg7XG5leHBvcnRzLmNhbGNHcmlkSXRlbVBvc2l0aW9uID0gY2FsY0dyaWRJdGVtUG9zaXRpb247XG5leHBvcnRzLmNhbGNHcmlkSXRlbVdIUHggPSBjYWxjR3JpZEl0ZW1XSFB4O1xuZXhwb3J0cy5jYWxjV0ggPSBjYWxjV0g7XG5leHBvcnRzLmNhbGNYWSA9IGNhbGNYWTtcbmV4cG9ydHMuY2xhbXAgPSBjbGFtcDtcbi8qOjogaW1wb3J0IHR5cGUgeyBQb3NpdGlvbiB9IGZyb20gXCIuL3V0aWxzXCI7Ki9cbi8qOjogZXhwb3J0IHR5cGUgUG9zaXRpb25QYXJhbXMgPSB7XG4gIG1hcmdpbjogW251bWJlciwgbnVtYmVyXSxcbiAgY29udGFpbmVyUGFkZGluZzogW251bWJlciwgbnVtYmVyXSxcbiAgY29udGFpbmVyV2lkdGg6IG51bWJlcixcbiAgY29sczogbnVtYmVyLFxuICByb3dIZWlnaHQ6IG51bWJlcixcbiAgbWF4Um93czogbnVtYmVyXG59OyovXG4vLyBIZWxwZXIgZm9yIGdlbmVyYXRpbmcgY29sdW1uIHdpZHRoXG5mdW5jdGlvbiBjYWxjR3JpZENvbFdpZHRoKHBvc2l0aW9uUGFyYW1zIC8qOiBQb3NpdGlvblBhcmFtcyovKSAvKjogbnVtYmVyKi97XG4gIGNvbnN0IHtcbiAgICBtYXJnaW4sXG4gICAgY29udGFpbmVyUGFkZGluZyxcbiAgICBjb250YWluZXJXaWR0aCxcbiAgICBjb2xzXG4gIH0gPSBwb3NpdGlvblBhcmFtcztcbiAgcmV0dXJuIChjb250YWluZXJXaWR0aCAtIG1hcmdpblswXSAqIChjb2xzIC0gMSkgLSBjb250YWluZXJQYWRkaW5nWzBdICogMikgLyBjb2xzO1xufVxuXG4vLyBUaGlzIGNhbiBlaXRoZXIgYmUgY2FsbGVkOlxuLy8gY2FsY0dyaWRJdGVtV0hQeCh3LCBjb2xXaWR0aCwgbWFyZ2luWzBdKVxuLy8gb3Jcbi8vIGNhbGNHcmlkSXRlbVdIUHgoaCwgcm93SGVpZ2h0LCBtYXJnaW5bMV0pXG5mdW5jdGlvbiBjYWxjR3JpZEl0ZW1XSFB4KGdyaWRVbml0cyAvKjogbnVtYmVyKi8sIGNvbE9yUm93U2l6ZSAvKjogbnVtYmVyKi8sIG1hcmdpblB4IC8qOiBudW1iZXIqLykgLyo6IG51bWJlciove1xuICAvLyAwICogSW5maW5pdHkgPT09IE5hTiwgd2hpY2ggY2F1c2VzIHByb2JsZW1zIHdpdGggcmVzaXplIGNvbnRyYWludHNcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZ3JpZFVuaXRzKSkgcmV0dXJuIGdyaWRVbml0cztcbiAgcmV0dXJuIE1hdGgucm91bmQoY29sT3JSb3dTaXplICogZ3JpZFVuaXRzICsgTWF0aC5tYXgoMCwgZ3JpZFVuaXRzIC0gMSkgKiBtYXJnaW5QeCk7XG59XG5cbi8qKlxuICogUmV0dXJuIHBvc2l0aW9uIG9uIHRoZSBwYWdlIGdpdmVuIGFuIHgsIHksIHcsIGguXG4gKiBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgYXJlIGFsbCBpbiBwaXhlbHMuXG4gKiBAcGFyYW0gIHtQb3NpdGlvblBhcmFtc30gcG9zaXRpb25QYXJhbXMgIFBhcmFtZXRlcnMgb2YgZ3JpZCBuZWVkZWQgZm9yIGNvb3JkaW5hdGVzIGNhbGN1bGF0aW9ucy5cbiAqIEBwYXJhbSAge051bWJlcn0gIHggICAgICAgICAgICAgICAgICAgICAgWCBjb29yZGluYXRlIGluIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICB5ICAgICAgICAgICAgICAgICAgICAgIFkgY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHBhcmFtICB7TnVtYmVyfSAgdyAgICAgICAgICAgICAgICAgICAgICBXIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge051bWJlcn0gIGggICAgICAgICAgICAgICAgICAgICAgSCBjb29yZGluYXRlIGluIGdyaWQgdW5pdHMuXG4gKiBAcmV0dXJuIHtQb3NpdGlvbn0gICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIGNvb3Jkcy5cbiAqL1xuZnVuY3Rpb24gY2FsY0dyaWRJdGVtUG9zaXRpb24ocG9zaXRpb25QYXJhbXMgLyo6IFBvc2l0aW9uUGFyYW1zKi8sIHggLyo6IG51bWJlciovLCB5IC8qOiBudW1iZXIqLywgdyAvKjogbnVtYmVyKi8sIGggLyo6IG51bWJlciovLCBzdGF0ZSAvKjogP09iamVjdCovKSAvKjogUG9zaXRpb24qL3tcbiAgY29uc3Qge1xuICAgIG1hcmdpbixcbiAgICBjb250YWluZXJQYWRkaW5nLFxuICAgIHJvd0hlaWdodFxuICB9ID0gcG9zaXRpb25QYXJhbXM7XG4gIGNvbnN0IGNvbFdpZHRoID0gY2FsY0dyaWRDb2xXaWR0aChwb3NpdGlvblBhcmFtcyk7XG4gIGNvbnN0IG91dCA9IHt9O1xuXG4gIC8vIElmIHJlc2l6aW5nLCB1c2UgdGhlIGV4YWN0IHdpZHRoIGFuZCBoZWlnaHQgYXMgcmV0dXJuZWQgZnJvbSByZXNpemluZyBjYWxsYmFja3MuXG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5yZXNpemluZykge1xuICAgIG91dC53aWR0aCA9IE1hdGgucm91bmQoc3RhdGUucmVzaXppbmcud2lkdGgpO1xuICAgIG91dC5oZWlnaHQgPSBNYXRoLnJvdW5kKHN0YXRlLnJlc2l6aW5nLmhlaWdodCk7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCBjYWxjdWxhdGUgZnJvbSBncmlkIHVuaXRzLlxuICBlbHNlIHtcbiAgICBvdXQud2lkdGggPSBjYWxjR3JpZEl0ZW1XSFB4KHcsIGNvbFdpZHRoLCBtYXJnaW5bMF0pO1xuICAgIG91dC5oZWlnaHQgPSBjYWxjR3JpZEl0ZW1XSFB4KGgsIHJvd0hlaWdodCwgbWFyZ2luWzFdKTtcbiAgfVxuXG4gIC8vIElmIGRyYWdnaW5nLCB1c2UgdGhlIGV4YWN0IHdpZHRoIGFuZCBoZWlnaHQgYXMgcmV0dXJuZWQgZnJvbSBkcmFnZ2luZyBjYWxsYmFja3MuXG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5kcmFnZ2luZykge1xuICAgIG91dC50b3AgPSBNYXRoLnJvdW5kKHN0YXRlLmRyYWdnaW5nLnRvcCk7XG4gICAgb3V0LmxlZnQgPSBNYXRoLnJvdW5kKHN0YXRlLmRyYWdnaW5nLmxlZnQpO1xuICB9IGVsc2UgaWYgKHN0YXRlICYmIHN0YXRlLnJlc2l6aW5nICYmIHR5cGVvZiBzdGF0ZS5yZXNpemluZy50b3AgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHN0YXRlLnJlc2l6aW5nLmxlZnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICBvdXQudG9wID0gTWF0aC5yb3VuZChzdGF0ZS5yZXNpemluZy50b3ApO1xuICAgIG91dC5sZWZ0ID0gTWF0aC5yb3VuZChzdGF0ZS5yZXNpemluZy5sZWZ0KTtcbiAgfVxuICAvLyBPdGhlcndpc2UsIGNhbGN1bGF0ZSBmcm9tIGdyaWQgdW5pdHMuXG4gIGVsc2Uge1xuICAgIG91dC50b3AgPSBNYXRoLnJvdW5kKChyb3dIZWlnaHQgKyBtYXJnaW5bMV0pICogeSArIGNvbnRhaW5lclBhZGRpbmdbMV0pO1xuICAgIG91dC5sZWZ0ID0gTWF0aC5yb3VuZCgoY29sV2lkdGggKyBtYXJnaW5bMF0pICogeCArIGNvbnRhaW5lclBhZGRpbmdbMF0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIHggYW5kIHkgY29vcmRpbmF0ZXMgZnJvbSBwaXhlbHMgdG8gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge1Bvc2l0aW9uUGFyYW1zfSBwb3NpdGlvblBhcmFtcyAgUGFyYW1ldGVycyBvZiBncmlkIG5lZWRlZCBmb3IgY29vcmRpbmF0ZXMgY2FsY3VsYXRpb25zLlxuICogQHBhcmFtICB7TnVtYmVyfSB0b3AgICAgICAgICAgICAgICAgICAgICBUb3AgcG9zaXRpb24gKHJlbGF0aXZlIHRvIHBhcmVudCkgaW4gcGl4ZWxzLlxuICogQHBhcmFtICB7TnVtYmVyfSBsZWZ0ICAgICAgICAgICAgICAgICAgICBMZWZ0IHBvc2l0aW9uIChyZWxhdGl2ZSB0byBwYXJlbnQpIGluIHBpeGVscy5cbiAqIEBwYXJhbSAge051bWJlcn0gdyAgICAgICAgICAgICAgICAgICAgICAgVyBjb29yZGluYXRlIGluIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGggICAgICAgICAgICAgICAgICAgICAgIEggY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICB4IGFuZCB5IGluIGdyaWQgdW5pdHMuXG4gKi9cbmZ1bmN0aW9uIGNhbGNYWShwb3NpdGlvblBhcmFtcyAvKjogUG9zaXRpb25QYXJhbXMqLywgdG9wIC8qOiBudW1iZXIqLywgbGVmdCAvKjogbnVtYmVyKi8sIHcgLyo6IG51bWJlciovLCBoIC8qOiBudW1iZXIqLykgLyo6IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSove1xuICBjb25zdCB7XG4gICAgbWFyZ2luLFxuICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgY29scyxcbiAgICByb3dIZWlnaHQsXG4gICAgbWF4Um93c1xuICB9ID0gcG9zaXRpb25QYXJhbXM7XG4gIGNvbnN0IGNvbFdpZHRoID0gY2FsY0dyaWRDb2xXaWR0aChwb3NpdGlvblBhcmFtcyk7XG5cbiAgLy8gbGVmdCA9IGNvbnRhaW5lclBhZGRpbmdYICsgeCAqIChjb2xXaWR0aCArIG1hcmdpblgpXG4gIC8vIHggKiAoY29sV2lkdGggKyBtYXJnaW5YKSA9IGxlZnQgLSBjb250YWluZXJQYWRkaW5nWFxuICAvLyB4ID0gKGxlZnQgLSBjb250YWluZXJQYWRkaW5nWCkgLyAoY29sV2lkdGggKyBtYXJnaW5YKVxuICBsZXQgeCA9IE1hdGgucm91bmQoKGxlZnQgLSBjb250YWluZXJQYWRkaW5nWzBdKSAvIChjb2xXaWR0aCArIG1hcmdpblswXSkpO1xuICBsZXQgeSA9IE1hdGgucm91bmQoKHRvcCAtIGNvbnRhaW5lclBhZGRpbmdbMV0pIC8gKHJvd0hlaWdodCArIG1hcmdpblsxXSkpO1xuXG4gIC8vIENhcHBpbmdcbiAgeCA9IGNsYW1wKHgsIDAsIGNvbHMgLSB3KTtcbiAgeSA9IGNsYW1wKHksIDAsIG1heFJvd3MgLSBoKTtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIGhlaWdodCBhbmQgd2lkdGggaW4gcGl4ZWwgdmFsdWVzLCBjYWxjdWxhdGUgZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge1Bvc2l0aW9uUGFyYW1zfSBwb3NpdGlvblBhcmFtcyAgUGFyYW1ldGVycyBvZiBncmlkIG5lZWRlZCBmb3IgY29vcmRpbmF0ZXMgY2FsY2x1YXRpb25zLlxuICogQHBhcmFtICB7TnVtYmVyfSBoZWlnaHQgICAgICAgICAgICAgICAgICBIZWlnaHQgaW4gcGl4ZWxzLlxuICogQHBhcmFtICB7TnVtYmVyfSB3aWR0aCAgICAgICAgICAgICAgICAgICBXaWR0aCBpbiBwaXhlbHMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHggICAgICAgICAgICAgICAgICAgICAgIFggY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHBhcmFtICB7TnVtYmVyfSB5ICAgICAgICAgICAgICAgICAgICAgICBZIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBoYW5kbGUgUmVzaXplIEhhbmRsZS5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgdywgaCBhcyBncmlkIHVuaXRzLlxuICovXG5mdW5jdGlvbiBjYWxjV0gocG9zaXRpb25QYXJhbXMgLyo6IFBvc2l0aW9uUGFyYW1zKi8sIHdpZHRoIC8qOiBudW1iZXIqLywgaGVpZ2h0IC8qOiBudW1iZXIqLywgeCAvKjogbnVtYmVyKi8sIHkgLyo6IG51bWJlciovLCBoYW5kbGUgLyo6IHN0cmluZyovKSAvKjogeyB3OiBudW1iZXIsIGg6IG51bWJlciB9Ki97XG4gIGNvbnN0IHtcbiAgICBtYXJnaW4sXG4gICAgbWF4Um93cyxcbiAgICBjb2xzLFxuICAgIHJvd0hlaWdodFxuICB9ID0gcG9zaXRpb25QYXJhbXM7XG4gIGNvbnN0IGNvbFdpZHRoID0gY2FsY0dyaWRDb2xXaWR0aChwb3NpdGlvblBhcmFtcyk7XG5cbiAgLy8gd2lkdGggPSBjb2xXaWR0aCAqIHcgLSAobWFyZ2luICogKHcgLSAxKSlcbiAgLy8gLi4uXG4gIC8vIHcgPSAod2lkdGggKyBtYXJnaW4pIC8gKGNvbFdpZHRoICsgbWFyZ2luKVxuICBsZXQgdyA9IE1hdGgucm91bmQoKHdpZHRoICsgbWFyZ2luWzBdKSAvIChjb2xXaWR0aCArIG1hcmdpblswXSkpO1xuICBsZXQgaCA9IE1hdGgucm91bmQoKGhlaWdodCArIG1hcmdpblsxXSkgLyAocm93SGVpZ2h0ICsgbWFyZ2luWzFdKSk7XG5cbiAgLy8gQ2FwcGluZ1xuICBsZXQgX3cgPSBjbGFtcCh3LCAwLCBjb2xzIC0geCk7XG4gIGxldCBfaCA9IGNsYW1wKGgsIDAsIG1heFJvd3MgLSB5KTtcbiAgaWYgKFtcInN3XCIsIFwid1wiLCBcIm53XCJdLmluZGV4T2YoaGFuZGxlKSAhPT0gLTEpIHtcbiAgICBfdyA9IGNsYW1wKHcsIDAsIGNvbHMpO1xuICB9XG4gIGlmIChbXCJud1wiLCBcIm5cIiwgXCJuZVwiXS5pbmRleE9mKGhhbmRsZSkgIT09IC0xKSB7XG4gICAgX2ggPSBjbGFtcChoLCAwLCBtYXhSb3dzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHc6IF93LFxuICAgIGg6IF9oXG4gIH07XG59XG5cbi8vIFNpbWlsYXIgdG8gXy5jbGFtcFxuZnVuY3Rpb24gY2xhbXAobnVtIC8qOiBudW1iZXIqLywgbG93ZXJCb3VuZCAvKjogbnVtYmVyKi8sIHVwcGVyQm91bmQgLyo6IG51bWJlciovKSAvKjogbnVtYmVyKi97XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihudW0sIHVwcGVyQm91bmQpLCBsb3dlckJvdW5kKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/components/WidthProvider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/components/WidthProvider.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = WidthProvideRGL;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _resizeObserverPolyfill = _interopRequireDefault(__webpack_require__(/*! resize-observer-polyfill */ \"(ssr)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/*:: import type { ReactRef } from \"../ReactGridLayoutPropTypes\";*/\n/*:: type WPDefaultProps = {|\n  measureBeforeMount: boolean\n|};*/\n/*:: type WPProps = {|\n  className?: string,\n  style?: Object,\n  ...WPDefaultProps\n|};*/\n// eslint-disable-next-line no-unused-vars\n/*:: type WPState = {|\n  width: number\n|};*/\n/*:: type ComposedProps<Config> = {|\n  ...Config,\n  measureBeforeMount?: boolean,\n  className?: string,\n  style?: Object,\n  width?: number\n|};*/\nconst layoutClassName = \"react-grid-layout\";\n\n/*\n * A simple HOC that provides facility for listening to container resizes.\n *\n * The Flow type is pretty janky here. I can't just spread `WPProps` into this returned object - I wish I could - but it triggers\n * a flow bug of some sort that causes it to stop typechecking.\n */\nfunction WidthProvideRGL /*:: <Config>*/(ComposedComponent /*: React.AbstractComponent<Config>*/) /*: React.AbstractComponent<ComposedProps<Config>>*/{\n  var _WidthProvider;\n  return _WidthProvider = class WidthProvider extends React.Component\n  /*:: <\n      ComposedProps<Config>,\n      WPState\n    >*/\n  {\n    constructor() {\n      super(...arguments);\n      _defineProperty(this, \"state\", {\n        width: 1280\n      });\n      _defineProperty(this, \"elementRef\", /*#__PURE__*/React.createRef());\n      _defineProperty(this, \"mounted\", false);\n      _defineProperty(this, \"resizeObserver\", void 0);\n    }\n    componentDidMount() {\n      this.mounted = true;\n      this.resizeObserver = new _resizeObserverPolyfill.default(entries => {\n        const node = this.elementRef.current;\n        if (node instanceof HTMLElement) {\n          const width = entries[0].contentRect.width;\n          this.setState({\n            width\n          });\n        }\n      });\n      const node = this.elementRef.current;\n      if (node instanceof HTMLElement) {\n        this.resizeObserver.observe(node);\n      }\n    }\n    componentWillUnmount() {\n      this.mounted = false;\n      const node = this.elementRef.current;\n      if (node instanceof HTMLElement) {\n        this.resizeObserver.unobserve(node);\n      }\n      this.resizeObserver.disconnect();\n    }\n    render() {\n      const {\n        measureBeforeMount,\n        ...rest\n      } = this.props;\n      if (measureBeforeMount && !this.mounted) {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          className: (0, _clsx.default)(this.props.className, layoutClassName),\n          style: this.props.style\n          // $FlowIgnore ref types\n          ,\n          ref: this.elementRef\n        });\n      }\n      return /*#__PURE__*/React.createElement(ComposedComponent, _extends({\n        innerRef: this.elementRef\n      }, rest, this.state));\n    }\n  }, _defineProperty(_WidthProvider, \"defaultProps\", {\n    measureBeforeMount: false\n  }), _defineProperty(_WidthProvider, \"propTypes\", {\n    // If true, will not render children until mounted. Useful for getting the exact width before\n    // rendering, to prevent any unsightly resizing.\n    measureBeforeMount: _propTypes.default.bool\n  }), _WidthProvider;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvY29tcG9uZW50cy9XaWR0aFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysb0NBQW9DLG1CQUFPLENBQUMsd0dBQU87QUFDbkQsd0NBQXdDLG1CQUFPLENBQUMsNERBQVk7QUFDNUQscURBQXFELG1CQUFPLENBQUMseUdBQTBCO0FBQ3ZGLG1DQUFtQyxtQkFBTyxDQUFDLG9EQUFNO0FBQ2pELHFDQUFxQyxpQ0FBaUM7QUFDdEUseUNBQXlDLDRFQUE0RSxvREFBb0QsdUNBQXVDLGdCQUFnQiwrQkFBK0IsNEVBQTRFLHFCQUFxQiwrQkFBK0IsZUFBZSx3Q0FBd0MsMkpBQTJKLFdBQVc7QUFDNWxCLHNCQUFzQix3RUFBd0UsZ0JBQWdCLHNCQUFzQixPQUFPLHNCQUFzQixvQkFBb0IsZ0RBQWdELFdBQVc7QUFDaFAsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsbUJBQW1CLFdBQVcsbUNBQW1DO0FBQ2pFLDRCQUE0QjtBQUM1QjtBQUNBLEdBQUc7QUFDSCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsR0FBRztBQUNILG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RvY2ttYXN0ZXItaW1zLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL2NvbXBvbmVudHMvV2lkdGhQcm92aWRlci5qcz80YjY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gV2lkdGhQcm92aWRlUkdMO1xudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG52YXIgX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGxcIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCB0KSB7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFdlYWtNYXApIHZhciByID0gbmV3IFdlYWtNYXAoKSwgbiA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBmdW5jdGlvbiAoZSwgdCkgeyBpZiAoIXQgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyB2YXIgbywgaSwgZiA9IHsgX19wcm90b19fOiBudWxsLCBkZWZhdWx0OiBlIH07IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4gZjsgaWYgKG8gPSB0ID8gbiA6IHIpIHsgaWYgKG8uaGFzKGUpKSByZXR1cm4gby5nZXQoZSk7IG8uc2V0KGUsIGYpOyB9IGZvciAoY29uc3QgdCBpbiBlKSBcImRlZmF1bHRcIiAhPT0gdCAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHQpICYmICgoaSA9IChvID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHQpKSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gbyhmLCB0LCBpKSA6IGZbdF0gPSBlW3RdKTsgcmV0dXJuIGY7IH0pKGUsIHQpOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKG4pIHsgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHsgdmFyIHQgPSBhcmd1bWVudHNbZV07IGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7IH0gcmV0dXJuIG47IH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbi8qOjogaW1wb3J0IHR5cGUgeyBSZWFjdFJlZiB9IGZyb20gXCIuLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIjsqL1xuLyo6OiB0eXBlIFdQRGVmYXVsdFByb3BzID0ge3xcbiAgbWVhc3VyZUJlZm9yZU1vdW50OiBib29sZWFuXG58fTsqL1xuLyo6OiB0eXBlIFdQUHJvcHMgPSB7fFxuICBjbGFzc05hbWU/OiBzdHJpbmcsXG4gIHN0eWxlPzogT2JqZWN0LFxuICAuLi5XUERlZmF1bHRQcm9wc1xufH07Ki9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuLyo6OiB0eXBlIFdQU3RhdGUgPSB7fFxuICB3aWR0aDogbnVtYmVyXG58fTsqL1xuLyo6OiB0eXBlIENvbXBvc2VkUHJvcHM8Q29uZmlnPiA9IHt8XG4gIC4uLkNvbmZpZyxcbiAgbWVhc3VyZUJlZm9yZU1vdW50PzogYm9vbGVhbixcbiAgY2xhc3NOYW1lPzogc3RyaW5nLFxuICBzdHlsZT86IE9iamVjdCxcbiAgd2lkdGg/OiBudW1iZXJcbnx9OyovXG5jb25zdCBsYXlvdXRDbGFzc05hbWUgPSBcInJlYWN0LWdyaWQtbGF5b3V0XCI7XG5cbi8qXG4gKiBBIHNpbXBsZSBIT0MgdGhhdCBwcm92aWRlcyBmYWNpbGl0eSBmb3IgbGlzdGVuaW5nIHRvIGNvbnRhaW5lciByZXNpemVzLlxuICpcbiAqIFRoZSBGbG93IHR5cGUgaXMgcHJldHR5IGphbmt5IGhlcmUuIEkgY2FuJ3QganVzdCBzcHJlYWQgYFdQUHJvcHNgIGludG8gdGhpcyByZXR1cm5lZCBvYmplY3QgLSBJIHdpc2ggSSBjb3VsZCAtIGJ1dCBpdCB0cmlnZ2Vyc1xuICogYSBmbG93IGJ1ZyBvZiBzb21lIHNvcnQgdGhhdCBjYXVzZXMgaXQgdG8gc3RvcCB0eXBlY2hlY2tpbmcuXG4gKi9cbmZ1bmN0aW9uIFdpZHRoUHJvdmlkZVJHTCAvKjo6IDxDb25maWc+Ki8oQ29tcG9zZWRDb21wb25lbnQgLyo6IFJlYWN0LkFic3RyYWN0Q29tcG9uZW50PENvbmZpZz4qLykgLyo6IFJlYWN0LkFic3RyYWN0Q29tcG9uZW50PENvbXBvc2VkUHJvcHM8Q29uZmlnPj4qL3tcbiAgdmFyIF9XaWR0aFByb3ZpZGVyO1xuICByZXR1cm4gX1dpZHRoUHJvdmlkZXIgPSBjbGFzcyBXaWR0aFByb3ZpZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50XG4gIC8qOjogPFxuICAgICAgQ29tcG9zZWRQcm9wczxDb25maWc+LFxuICAgICAgV1BTdGF0ZVxuICAgID4qL1xuICB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgICB3aWR0aDogMTI4MFxuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbGVtZW50UmVmXCIsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVSZWYoKSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb3VudGVkXCIsIGZhbHNlKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc2l6ZU9ic2VydmVyXCIsIHZvaWQgMCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGwuZGVmYXVsdChlbnRyaWVzID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0LndpZHRoO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgd2lkdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5lbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUobm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZWFzdXJlQmVmb3JlTW91bnQsXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKG1lYXN1cmVCZWZvcmVNb3VudCAmJiAhdGhpcy5tb3VudGVkKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3guZGVmYXVsdCkodGhpcy5wcm9wcy5jbGFzc05hbWUsIGxheW91dENsYXNzTmFtZSksXG4gICAgICAgICAgc3R5bGU6IHRoaXMucHJvcHMuc3R5bGVcbiAgICAgICAgICAvLyAkRmxvd0lnbm9yZSByZWYgdHlwZXNcbiAgICAgICAgICAsXG4gICAgICAgICAgcmVmOiB0aGlzLmVsZW1lbnRSZWZcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9zZWRDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICAgICAgaW5uZXJSZWY6IHRoaXMuZWxlbWVudFJlZlxuICAgICAgfSwgcmVzdCwgdGhpcy5zdGF0ZSkpO1xuICAgIH1cbiAgfSwgX2RlZmluZVByb3BlcnR5KF9XaWR0aFByb3ZpZGVyLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gICAgbWVhc3VyZUJlZm9yZU1vdW50OiBmYWxzZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9XaWR0aFByb3ZpZGVyLCBcInByb3BUeXBlc1wiLCB7XG4gICAgLy8gSWYgdHJ1ZSwgd2lsbCBub3QgcmVuZGVyIGNoaWxkcmVuIHVudGlsIG1vdW50ZWQuIFVzZWZ1bCBmb3IgZ2V0dGluZyB0aGUgZXhhY3Qgd2lkdGggYmVmb3JlXG4gICAgLy8gcmVuZGVyaW5nLCB0byBwcmV2ZW50IGFueSB1bnNpZ2h0bHkgcmVzaXppbmcuXG4gICAgbWVhc3VyZUJlZm9yZU1vdW50OiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbFxuICB9KSwgX1dpZHRoUHJvdmlkZXI7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/components/WidthProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/fastRGLPropsEqual.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/fastRGLPropsEqual.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("// this file was prevaled\nmodule.exports = function fastRGLPropsEqual(a, b, isEqualImpl) {\n  if (a === b) return true;\n  return a.className === b.className && isEqualImpl(a.style, b.style) && a.width === b.width && a.autoSize === b.autoSize && a.cols === b.cols && a.draggableCancel === b.draggableCancel && a.draggableHandle === b.draggableHandle && isEqualImpl(a.verticalCompact, b.verticalCompact) && isEqualImpl(a.compactType, b.compactType) && isEqualImpl(a.layout, b.layout) && isEqualImpl(a.margin, b.margin) && isEqualImpl(a.containerPadding, b.containerPadding) && a.rowHeight === b.rowHeight && a.maxRows === b.maxRows && a.isBounded === b.isBounded && a.isDraggable === b.isDraggable && a.isResizable === b.isResizable && a.allowOverlap === b.allowOverlap && a.preventCollision === b.preventCollision && a.useCSSTransforms === b.useCSSTransforms && a.transformScale === b.transformScale && a.isDroppable === b.isDroppable && isEqualImpl(a.resizeHandles, b.resizeHandles) && isEqualImpl(a.resizeHandle, b.resizeHandle) && a.onLayoutChange === b.onLayoutChange && a.onDragStart === b.onDragStart && a.onDrag === b.onDrag && a.onDragStop === b.onDragStop && a.onResizeStart === b.onResizeStart && a.onResize === b.onResize && a.onResizeStop === b.onResizeStop && a.onDrop === b.onDrop && isEqualImpl(a.droppingItem, b.droppingItem) && isEqualImpl(a.innerRef, b.innerRef);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvZmFzdFJHTFByb3BzRXF1YWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0b2NrbWFzdGVyLWltcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9mYXN0UkdMUHJvcHNFcXVhbC5qcz84NjUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoaXMgZmlsZSB3YXMgcHJldmFsZWRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmFzdFJHTFByb3BzRXF1YWwoYSwgYiwgaXNFcXVhbEltcGwpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICByZXR1cm4gYS5jbGFzc05hbWUgPT09IGIuY2xhc3NOYW1lICYmIGlzRXF1YWxJbXBsKGEuc3R5bGUsIGIuc3R5bGUpICYmIGEud2lkdGggPT09IGIud2lkdGggJiYgYS5hdXRvU2l6ZSA9PT0gYi5hdXRvU2l6ZSAmJiBhLmNvbHMgPT09IGIuY29scyAmJiBhLmRyYWdnYWJsZUNhbmNlbCA9PT0gYi5kcmFnZ2FibGVDYW5jZWwgJiYgYS5kcmFnZ2FibGVIYW5kbGUgPT09IGIuZHJhZ2dhYmxlSGFuZGxlICYmIGlzRXF1YWxJbXBsKGEudmVydGljYWxDb21wYWN0LCBiLnZlcnRpY2FsQ29tcGFjdCkgJiYgaXNFcXVhbEltcGwoYS5jb21wYWN0VHlwZSwgYi5jb21wYWN0VHlwZSkgJiYgaXNFcXVhbEltcGwoYS5sYXlvdXQsIGIubGF5b3V0KSAmJiBpc0VxdWFsSW1wbChhLm1hcmdpbiwgYi5tYXJnaW4pICYmIGlzRXF1YWxJbXBsKGEuY29udGFpbmVyUGFkZGluZywgYi5jb250YWluZXJQYWRkaW5nKSAmJiBhLnJvd0hlaWdodCA9PT0gYi5yb3dIZWlnaHQgJiYgYS5tYXhSb3dzID09PSBiLm1heFJvd3MgJiYgYS5pc0JvdW5kZWQgPT09IGIuaXNCb3VuZGVkICYmIGEuaXNEcmFnZ2FibGUgPT09IGIuaXNEcmFnZ2FibGUgJiYgYS5pc1Jlc2l6YWJsZSA9PT0gYi5pc1Jlc2l6YWJsZSAmJiBhLmFsbG93T3ZlcmxhcCA9PT0gYi5hbGxvd092ZXJsYXAgJiYgYS5wcmV2ZW50Q29sbGlzaW9uID09PSBiLnByZXZlbnRDb2xsaXNpb24gJiYgYS51c2VDU1NUcmFuc2Zvcm1zID09PSBiLnVzZUNTU1RyYW5zZm9ybXMgJiYgYS50cmFuc2Zvcm1TY2FsZSA9PT0gYi50cmFuc2Zvcm1TY2FsZSAmJiBhLmlzRHJvcHBhYmxlID09PSBiLmlzRHJvcHBhYmxlICYmIGlzRXF1YWxJbXBsKGEucmVzaXplSGFuZGxlcywgYi5yZXNpemVIYW5kbGVzKSAmJiBpc0VxdWFsSW1wbChhLnJlc2l6ZUhhbmRsZSwgYi5yZXNpemVIYW5kbGUpICYmIGEub25MYXlvdXRDaGFuZ2UgPT09IGIub25MYXlvdXRDaGFuZ2UgJiYgYS5vbkRyYWdTdGFydCA9PT0gYi5vbkRyYWdTdGFydCAmJiBhLm9uRHJhZyA9PT0gYi5vbkRyYWcgJiYgYS5vbkRyYWdTdG9wID09PSBiLm9uRHJhZ1N0b3AgJiYgYS5vblJlc2l6ZVN0YXJ0ID09PSBiLm9uUmVzaXplU3RhcnQgJiYgYS5vblJlc2l6ZSA9PT0gYi5vblJlc2l6ZSAmJiBhLm9uUmVzaXplU3RvcCA9PT0gYi5vblJlc2l6ZVN0b3AgJiYgYS5vbkRyb3AgPT09IGIub25Ecm9wICYmIGlzRXF1YWxJbXBsKGEuZHJvcHBpbmdJdGVtLCBiLmRyb3BwaW5nSXRlbSkgJiYgaXNFcXVhbEltcGwoYS5pbm5lclJlZiwgYi5pbm5lclJlZik7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/fastRGLPropsEqual.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/responsiveUtils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\nexports.getBreakpointFromWidth = getBreakpointFromWidth;\nexports.getColsFromBreakpoint = getColsFromBreakpoint;\nexports.sortBreakpoints = sortBreakpoints;\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\n/*:: import type { CompactType, Layout } from \"./utils\";*/\n/*:: export type Breakpoint = string;*/\n/*:: export type DefaultBreakpoints = \"lg\" | \"md\" | \"sm\" | \"xs\" | \"xxs\";*/\n/*:: export type ResponsiveLayout<T: Breakpoint> = {\n  +[breakpoint: T]: Layout\n};*/\n// + indicates read-only\n/*:: export type Breakpoints<T: Breakpoint> = {\n  +[breakpoint: T]: number\n};*/\n/*:: export type OnLayoutChangeCallback = (\n  Layout,\n  { [key: Breakpoint]: Layout }\n) => void;*/\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nfunction getBreakpointFromWidth(breakpoints /*: Breakpoints<Breakpoint>*/, width /*: number*/) /*: Breakpoint*/{\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n  for (let i = 1, len = sorted.length; i < len; i++) {\n    const breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n  return matching;\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\nfunction getColsFromBreakpoint(breakpoint /*: Breakpoint*/, cols /*: Breakpoints<Breakpoint>*/) /*: number*/{\n  if (!cols[breakpoint]) {\n    throw new Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n  }\n  return cols[breakpoint];\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nfunction findOrGenerateResponsiveLayout(layouts /*: ResponsiveLayout<Breakpoint>*/, breakpoints /*: Breakpoints<Breakpoint>*/, breakpoint /*: Breakpoint*/, lastBreakpoint /*: Breakpoint*/, cols /*: number*/, compactType /*: CompactType*/) /*: Layout*/{\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]);\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i];\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items\n  return (0, _utils.compact)((0, _utils.correctBounds)(layout, {\n    cols: cols\n  }), compactType, cols);\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nfunction sortBreakpoints(breakpoints /*: Breakpoints<Breakpoint>*/) /*: Array<Breakpoint>*/{\n  const keys /*: Array<string>*/ = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvcmVzcG9uc2l2ZVV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHNDQUFzQztBQUN0Qyw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2QixhQUFhLG1CQUFPLENBQUMsc0VBQVM7QUFDOUIsbUJBQW1CLHNCQUFzQixlQUFlO0FBQ3hELHFDQUFxQztBQUNyQyx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRLHNDQUFzQyx1QkFBdUI7QUFDakYsWUFBWSxRQUFRO0FBQ3BCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdG9ja21hc3Rlci1pbXMvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvcmVzcG9uc2l2ZVV0aWxzLmpzP2I2YjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZpbmRPckdlbmVyYXRlUmVzcG9uc2l2ZUxheW91dCA9IGZpbmRPckdlbmVyYXRlUmVzcG9uc2l2ZUxheW91dDtcbmV4cG9ydHMuZ2V0QnJlYWtwb2ludEZyb21XaWR0aCA9IGdldEJyZWFrcG9pbnRGcm9tV2lkdGg7XG5leHBvcnRzLmdldENvbHNGcm9tQnJlYWtwb2ludCA9IGdldENvbHNGcm9tQnJlYWtwb2ludDtcbmV4cG9ydHMuc29ydEJyZWFrcG9pbnRzID0gc29ydEJyZWFrcG9pbnRzO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyo6OiBpbXBvcnQgdHlwZSB7IENvbXBhY3RUeXBlLCBMYXlvdXQgfSBmcm9tIFwiLi91dGlsc1wiOyovXG4vKjo6IGV4cG9ydCB0eXBlIEJyZWFrcG9pbnQgPSBzdHJpbmc7Ki9cbi8qOjogZXhwb3J0IHR5cGUgRGVmYXVsdEJyZWFrcG9pbnRzID0gXCJsZ1wiIHwgXCJtZFwiIHwgXCJzbVwiIHwgXCJ4c1wiIHwgXCJ4eHNcIjsqL1xuLyo6OiBleHBvcnQgdHlwZSBSZXNwb25zaXZlTGF5b3V0PFQ6IEJyZWFrcG9pbnQ+ID0ge1xuICArW2JyZWFrcG9pbnQ6IFRdOiBMYXlvdXRcbn07Ki9cbi8vICsgaW5kaWNhdGVzIHJlYWQtb25seVxuLyo6OiBleHBvcnQgdHlwZSBCcmVha3BvaW50czxUOiBCcmVha3BvaW50PiA9IHtcbiAgK1ticmVha3BvaW50OiBUXTogbnVtYmVyXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIE9uTGF5b3V0Q2hhbmdlQ2FsbGJhY2sgPSAoXG4gIExheW91dCxcbiAgeyBba2V5OiBCcmVha3BvaW50XTogTGF5b3V0IH1cbikgPT4gdm9pZDsqL1xuLyoqXG4gKiBHaXZlbiBhIHdpZHRoLCBmaW5kIHRoZSBoaWdoZXN0IGJyZWFrcG9pbnQgdGhhdCBtYXRjaGVzIGlzIHZhbGlkIGZvciBpdCAod2lkdGggPiBicmVha3BvaW50KS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGJyZWFrcG9pbnRzIEJyZWFrcG9pbnRzIG9iamVjdCAoZS5nLiB7bGc6IDEyMDAsIG1kOiA5NjAsIC4uLn0pXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHdpZHRoIFNjcmVlbiB3aWR0aC5cbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgSGlnaGVzdCBicmVha3BvaW50IHRoYXQgaXMgbGVzcyB0aGFuIHdpZHRoLlxuICovXG5mdW5jdGlvbiBnZXRCcmVha3BvaW50RnJvbVdpZHRoKGJyZWFrcG9pbnRzIC8qOiBCcmVha3BvaW50czxCcmVha3BvaW50PiovLCB3aWR0aCAvKjogbnVtYmVyKi8pIC8qOiBCcmVha3BvaW50Ki97XG4gIGNvbnN0IHNvcnRlZCA9IHNvcnRCcmVha3BvaW50cyhicmVha3BvaW50cyk7XG4gIGxldCBtYXRjaGluZyA9IHNvcnRlZFswXTtcbiAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNvcnRlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGJyZWFrcG9pbnROYW1lID0gc29ydGVkW2ldO1xuICAgIGlmICh3aWR0aCA+IGJyZWFrcG9pbnRzW2JyZWFrcG9pbnROYW1lXSkgbWF0Y2hpbmcgPSBicmVha3BvaW50TmFtZTtcbiAgfVxuICByZXR1cm4gbWF0Y2hpbmc7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBicmVha3BvaW50LCBnZXQgdGhlICMgb2YgY29scyBzZXQgZm9yIGl0LlxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50IEJyZWFrcG9pbnQgbmFtZS5cbiAqIEBwYXJhbSAge09iamVjdH0gY29scyAgICAgICBNYXAgb2YgYnJlYWtwb2ludHMgdG8gY29scy5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICBOdW1iZXIgb2YgY29scy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29sc0Zyb21CcmVha3BvaW50KGJyZWFrcG9pbnQgLyo6IEJyZWFrcG9pbnQqLywgY29scyAvKjogQnJlYWtwb2ludHM8QnJlYWtwb2ludD4qLykgLyo6IG51bWJlciove1xuICBpZiAoIWNvbHNbYnJlYWtwb2ludF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zaXZlUmVhY3RHcmlkTGF5b3V0OiBgY29sc2AgZW50cnkgZm9yIGJyZWFrcG9pbnQgXCIgKyBicmVha3BvaW50ICsgXCIgaXMgbWlzc2luZyFcIik7XG4gIH1cbiAgcmV0dXJuIGNvbHNbYnJlYWtwb2ludF07XG59XG5cbi8qKlxuICogR2l2ZW4gZXhpc3RpbmcgbGF5b3V0cyBhbmQgYSBuZXcgYnJlYWtwb2ludCwgZmluZCBvciBnZW5lcmF0ZSBhIG5ldyBsYXlvdXQuXG4gKlxuICogVGhpcyBmaW5kcyB0aGUgbGF5b3V0IGFib3ZlIHRoZSBuZXcgb25lIGFuZCBnZW5lcmF0ZXMgZnJvbSBpdCwgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gbGF5b3V0cyAgICAgRXhpc3RpbmcgbGF5b3V0cy5cbiAqIEBwYXJhbSAge0FycmF5fSBicmVha3BvaW50cyBBbGwgYnJlYWtwb2ludHMuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJyZWFrcG9pbnQgTmV3IGJyZWFrcG9pbnQuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJyZWFrcG9pbnQgTGFzdCBicmVha3BvaW50IChmb3IgZmFsbGJhY2spLlxuICogQHBhcmFtICB7TnVtYmVyfSBjb2xzICAgICAgIENvbHVtbiBjb3VudCBhdCBuZXcgYnJlYWtwb2ludC5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IHZlcnRpY2FsQ29tcGFjdCBXaGV0aGVyIG9yIG5vdCB0byBjb21wYWN0IHRoZSBsYXlvdXRcbiAqICAgdmVydGljYWxseS5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICBOZXcgbGF5b3V0LlxuICovXG5mdW5jdGlvbiBmaW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQobGF5b3V0cyAvKjogUmVzcG9uc2l2ZUxheW91dDxCcmVha3BvaW50PiovLCBicmVha3BvaW50cyAvKjogQnJlYWtwb2ludHM8QnJlYWtwb2ludD4qLywgYnJlYWtwb2ludCAvKjogQnJlYWtwb2ludCovLCBsYXN0QnJlYWtwb2ludCAvKjogQnJlYWtwb2ludCovLCBjb2xzIC8qOiBudW1iZXIqLywgY29tcGFjdFR5cGUgLyo6IENvbXBhY3RUeXBlKi8pIC8qOiBMYXlvdXQqL3tcbiAgLy8gSWYgaXQgYWxyZWFkeSBleGlzdHMsIGp1c3QgcmV0dXJuIGl0LlxuICBpZiAobGF5b3V0c1ticmVha3BvaW50XSkgcmV0dXJuICgwLCBfdXRpbHMuY2xvbmVMYXlvdXQpKGxheW91dHNbYnJlYWtwb2ludF0pO1xuICAvLyBGaW5kIG9yIGdlbmVyYXRlIHRoZSBuZXh0IGxheW91dFxuICBsZXQgbGF5b3V0ID0gbGF5b3V0c1tsYXN0QnJlYWtwb2ludF07XG4gIGNvbnN0IGJyZWFrcG9pbnRzU29ydGVkID0gc29ydEJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKTtcbiAgY29uc3QgYnJlYWtwb2ludHNBYm92ZSA9IGJyZWFrcG9pbnRzU29ydGVkLnNsaWNlKGJyZWFrcG9pbnRzU29ydGVkLmluZGV4T2YoYnJlYWtwb2ludCkpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnJlYWtwb2ludHNBYm92ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGIgPSBicmVha3BvaW50c0Fib3ZlW2ldO1xuICAgIGlmIChsYXlvdXRzW2JdKSB7XG4gICAgICBsYXlvdXQgPSBsYXlvdXRzW2JdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGxheW91dCA9ICgwLCBfdXRpbHMuY2xvbmVMYXlvdXQpKGxheW91dCB8fCBbXSk7IC8vIGNsb25lIGxheW91dCBzbyB3ZSBkb24ndCBtb2RpZnkgZXhpc3RpbmcgaXRlbXNcbiAgcmV0dXJuICgwLCBfdXRpbHMuY29tcGFjdCkoKDAsIF91dGlscy5jb3JyZWN0Qm91bmRzKShsYXlvdXQsIHtcbiAgICBjb2xzOiBjb2xzXG4gIH0pLCBjb21wYWN0VHlwZSwgY29scyk7XG59XG5cbi8qKlxuICogR2l2ZW4gYnJlYWtwb2ludHMsIHJldHVybiBhbiBhcnJheSBvZiBicmVha3BvaW50cyBzb3J0ZWQgYnkgd2lkdGguIFRoaXMgaXMgdXN1YWxseVxuICogZS5nLiBbJ3h4cycsICd4cycsICdzbScsIC4uLl1cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGJyZWFrcG9pbnRzIEtleS92YWx1ZSBwYWlyIG9mIGJyZWFrcG9pbnQgbmFtZXMgdG8gd2lkdGhzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBTb3J0ZWQgYnJlYWtwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHNvcnRCcmVha3BvaW50cyhicmVha3BvaW50cyAvKjogQnJlYWtwb2ludHM8QnJlYWtwb2ludD4qLykgLyo6IEFycmF5PEJyZWFrcG9pbnQ+Ki97XG4gIGNvbnN0IGtleXMgLyo6IEFycmF5PHN0cmluZz4qLyA9IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKTtcbiAgcmV0dXJuIGtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBicmVha3BvaW50c1thXSAtIGJyZWFrcG9pbnRzW2JdO1xuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-grid-layout/build/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.resizeItemInDirection = resizeItemInDirection;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\");\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: export type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";*/\n/*:: export type LayoutItem = {\n  w: number,\n  h: number,\n  x: number,\n  y: number,\n  i: string,\n  minW?: number,\n  minH?: number,\n  maxW?: number,\n  maxH?: number,\n  moved?: boolean,\n  static?: boolean,\n  isDraggable?: ?boolean,\n  isResizable?: ?boolean,\n  resizeHandles?: Array<ResizeHandleAxis>,\n  isBounded?: ?boolean\n};*/\n/*:: export type Layout = $ReadOnlyArray<LayoutItem>;*/\n/*:: export type Position = {\n  left: number,\n  top: number,\n  width: number,\n  height: number\n};*/\n/*:: export type ReactDraggableCallbackData = {\n  node: HTMLElement,\n  x?: number,\n  y?: number,\n  deltaX: number,\n  deltaY: number,\n  lastX?: number,\n  lastY?: number\n};*/\n/*:: export type PartialPosition = { left: number, top: number };*/\n/*:: export type DroppingPosition = { left: number, top: number, e: Event };*/\n/*:: export type Size = { width: number, height: number };*/\n/*:: export type GridDragEvent = {\n  e: Event,\n  node: HTMLElement,\n  newPosition: PartialPosition\n};*/\n/*:: export type GridResizeEvent = {\n  e: Event,\n  node: HTMLElement,\n  size: Size,\n  handle: string\n};*/\n/*:: export type DragOverEvent = MouseEvent & {\n  nativeEvent: {\n    layerX: number,\n    layerY: number,\n    ...Event\n  }\n};*/\n/*:: export type Pick<FromType, Properties: { [string]: 0 }> = $Exact<\n  $ObjMapi<Properties, <K, V>(k: K, v: V) => $ElementType<FromType, K>>\n>;*/\n// Helpful port from TS\n/*:: type REl = ReactElement<any>;*/\n/*:: export type ReactChildren = ReactChildrenArray<REl>;*/\n/*:: export type EventCallback = (\n  Layout,\n  oldItem: ?LayoutItem,\n  newItem: ?LayoutItem,\n  placeholder: ?LayoutItem,\n  Event,\n  ?HTMLElement\n) => void;*/\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\n/*:: export type CompactType = ?(\"horizontal\" | \"vertical\");*/\nconst isProduction = \"development\" === \"production\";\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nfunction bottom(layout /*: Layout*/) /*: number*/{\n  let max = 0,\n    bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\nfunction cloneLayout(layout /*: Layout*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n}\n\n// Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\nfunction modifyLayout(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n  return newLayout;\n}\n\n// Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\nfunction withLayoutItem(layout /*: Layout*/, itemKey /*: string*/, cb /*: LayoutItem => LayoutItem*/) /*: [Layout, ?LayoutItem]*/{\n  let item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n}\n\n// Fast path to cloning, since this is monomorphic\nfunction cloneLayoutItem(layoutItem /*: LayoutItem*/) /*: LayoutItem*/{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nfunction childrenEqual(a /*: ReactChildren*/, b /*: ReactChildren*/) /*: boolean*/{\n  return (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.key), _react.default.Children.map(b, c => c?.key)) && (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.props[\"data-grid\"]), _react.default.Children.map(b, c => c?.props[\"data-grid\"]));\n}\n\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\nconst fastRGLPropsEqual /*: FastRGLPropsEqual*/ = exports.fastRGLPropsEqual = __webpack_require__(/*! ./fastRGLPropsEqual */ \"(ssr)/./node_modules/react-grid-layout/build/fastRGLPropsEqual.js\");\n\n// Like the above, but a lot simpler.\nfunction fastPositionEqual(a /*: Position*/, b /*: Position*/) /*: boolean*/{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nfunction collides(l1 /*: LayoutItem*/, l2 /*: LayoutItem*/) /*: boolean*/{\n  if (l1.i === l2.i) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @param  {Boolean} allowOverlap When `true`, allows overlapping grid items.\n * @return {Array}       Compacted Layout.\n */\nfunction compact(layout /*: Layout*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  const sorted = sortLayoutItems(layout, compactType);\n  // Holding for new items.\n  const out = Array(layout.length);\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]);\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted, allowOverlap);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(sorted[i])] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n  return out;\n}\nconst heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(layout /*: Layout*/, item /*: LayoutItem*/, moveToCoord /*: number*/, axis /*: \"x\" | \"y\"*/) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout.map(layoutItem => {\n    return layoutItem.i;\n  }).indexOf(item.i);\n\n  // Go through each item we collide with.\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    // Ignore static items\n    if (otherItem.static) continue;\n\n    // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n    if (otherItem.y > item.y + item.h) break;\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n  item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\nfunction compactItem(compareWith /*: Layout*/, l /*: LayoutItem*/, compactType /*: CompactType*/, cols /*: number*/, fullLayout /*: Layout*/, allowOverlap /*: ?boolean*/) /*: LayoutItem*/{\n  const compactV = compactType === \"vertical\";\n  const compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  let collides;\n  // Checking the compactType null value to avoid breaking the layout when overlapping is allowed.\n  while ((collides = getFirstCollision(compareWith, l)) && !(compactType === null && allowOverlap)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    }\n    // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n      // ALso move element as left as we can\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        l.x--;\n      }\n    }\n  }\n\n  // Ensure that there are no negative positions\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nfunction correctBounds(layout /*: Layout*/, bounds /*: { cols: number }*/) /*: Layout*/{\n  const collidesWith = getStatics(layout);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nfunction getLayoutItem(layout /*: Layout*/, id /*: string*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nfunction getFirstCollision(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nfunction getAllCollisions(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nfunction getStatics(layout /*: Layout*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nfunction moveElement(layout /*: Layout*/, l /*: LayoutItem*/, x /*: ?number*/, y /*: ?number*/, isUserAction /*: ?boolean*/, preventCollision /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout;\n\n  // Short-circuit if nothing to do.\n  if (l.y === y && l.x === x) return layout;\n  log(`Moving element ${l.i} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n  const oldX = l.x;\n  const oldY = l.y;\n\n  // This is quite a bit faster than extending the object\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false;\n  // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n  if (movingUp) sorted = sorted.reverse();\n  const collisions = getAllCollisions(sorted, l);\n  const hasCollisions = collisions.length > 0;\n\n  // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(`Collision prevented on ${l.i}, reverting.`);\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  }\n\n  // Move each item that collides away from this element.\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(`Resolving collision between ${l.i} at [${l.x},${l.y}] and ${collision.i} at [${collision.x},${collision.y}]`);\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n  return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nfunction moveElementAwayFromCollision(layout /*: Layout*/, collidesWith /*: LayoutItem*/, itemToMove /*: LayoutItem*/, isUserAction /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/) /*: Layout*/{\n  const compactH = compactType === \"horizontal\";\n  // Compact vertically if not set to horizontal\n  const compactV = compactType === \"vertical\";\n  const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false;\n\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    const fakeItem /*: LayoutItem*/ = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n    const firstCollision = getFirstCollision(layout, fakeItem);\n    const collisionNorth = firstCollision && firstCollision.y + firstCollision.h > collidesWith.y;\n    const collisionWest = firstCollision && collidesWith.x + collidesWith.w > firstCollision.x;\n\n    // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n    if (!firstCollision) {\n      log(`Doing reverse collision on ${itemToMove.i} up to [${fakeItem.x},${fakeItem.y}].`);\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactV) {\n      return moveElement(layout, itemToMove, undefined, collidesWith.y + 1, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactType == null) {\n      collidesWith.y = itemToMove.y;\n      itemToMove.y = itemToMove.y + itemToMove.h;\n      return layout;\n    } else if (collisionWest && compactH) {\n      return moveElement(layout, collidesWith, itemToMove.x, undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n  const newX = compactH ? itemToMove.x + 1 : undefined;\n  const newY = compactV ? itemToMove.y + 1 : undefined;\n  if (newX == null && newY == null) {\n    return layout;\n  }\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nfunction perc(num /*: number*/) /*: string*/{\n  return num * 100 + \"%\";\n}\n\n/**\n * Helper functions to constrain dimensions of a GridItem\n */\nconst constrainWidth = (left /*: number*/, currentWidth /*: number*/, newWidth /*: number*/, containerWidth /*: number*/) => {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n};\nconst constrainHeight = (top /*: number*/, currentHeight /*: number*/, newHeight /*: number*/) => {\n  return top < 0 ? currentHeight : newHeight;\n};\nconst constrainLeft = (left /*: number*/) => Math.max(0, left);\nconst constrainTop = (top /*: number*/) => Math.max(0, top);\nconst resizeNorth = (currentSize, _ref, _containerWidth) => {\n  let {\n    left,\n    height,\n    width\n  } = _ref;\n  const top = currentSize.top - (height - currentSize.height);\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeEast = (currentSize, _ref2, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref2;\n  return {\n    top,\n    height,\n    width: constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    left: constrainLeft(left)\n  };\n};\nconst resizeWest = (currentSize, _ref3, containerWidth) => {\n  let {\n    top,\n    height,\n    width\n  } = _ref3;\n  const left = currentSize.left - (width - currentSize.width);\n  return {\n    height,\n    width: left < 0 ? currentSize.width : constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    top: constrainTop(top),\n    left: constrainLeft(left)\n  };\n};\nconst resizeSouth = (currentSize, _ref4, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref4;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeNorthEast = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeNorthWest = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthEast = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthWest = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst ordinalResizeHandlerMap = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n\n/**\n * Helper for clamping width and position when resizing an item.\n */\nfunction resizeItemInDirection(direction /*: ResizeHandleAxis*/, currentSize /*: Position*/, newSize /*: Position*/, containerWidth /*: number*/) /*: Position*/{\n  const ordinalHandler = ordinalResizeHandlerMap[direction];\n  // Shouldn't be possible given types; that said, don't fail hard\n  if (!ordinalHandler) return newSize;\n  return ordinalHandler(currentSize, {\n    ...currentSize,\n    ...newSize\n  }, containerWidth);\n}\nfunction setTransform(_ref5 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref5 /*: Position*/;\n  // Replace unitless items with px\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\nfunction setTopLeft(_ref6 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref6 /*: Position*/;\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nfunction sortLayoutItems(layout /*: Layout*/, compactType /*: CompactType*/) /*: Layout*/{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByRowCol(layout /*: Layout*/) /*: Layout*/{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByColRow(layout /*: Layout*/) /*: Layout*/{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nfunction synchronizeLayoutWithChildren(initialLayout /*: Layout*/, children /*: ReactChildren*/, cols /*: number*/, compactType /*: CompactType*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  initialLayout = initialLayout || [];\n\n  // Generate one layout item per child.\n  const layout /*: LayoutItem[]*/ = [];\n  _react.default.Children.forEach(children, (child /*: ReactElement<any>*/) => {\n    // Child may not exist\n    if (child?.key == null) return;\n    const exists = getLayoutItem(initialLayout, String(child.key));\n    const g = child.props[\"data-grid\"];\n    // Don't overwrite the layout item if it's already in the initial layout.\n    // If it has a `data-grid` property, prefer that over what's in the layout.\n    if (exists && g == null) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      // Hey, this item has a data-grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          ...g,\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  });\n\n  // Correct the layout.\n  const correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nfunction validateLayout(layout /*: Layout*/) /*: void*/{\n  let contextName /*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  const subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n    for (let j = 0; j < subProps.length; j++) {\n      const key = subProps[j];\n      const value = item[key];\n      if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new Error(`ReactGridLayout: ${contextName}[${i}].${key} must be a number! Received: ${value} (${typeof value})`);\n      }\n    }\n    if (typeof item.i !== \"undefined\" && typeof item.i !== \"string\") {\n      throw new Error(`ReactGridLayout: ${contextName}[${i}].i must be a string! Received: ${item.i} (${typeof item.i})`);\n    }\n  }\n}\n\n// Legacy support for verticalCompact: false\nfunction compactType(props /*: ?{ verticalCompact: boolean, compactType: CompactType }*/) /*: CompactType*/{\n  const {\n    verticalCompact,\n    compactType\n  } = props || {};\n  return verticalCompact === false ? null : compactType;\n}\nfunction log() {\n  if (!DEBUG) return;\n  // eslint-disable-next-line no-console\n  console.log(...arguments);\n}\nconst noop = () => {};\nexports.noop = noop;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsY0FBYztBQUNkLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixvQ0FBb0M7QUFDcEMsWUFBWTtBQUNaLFlBQVk7QUFDWiw2QkFBNkI7QUFDN0Isa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN2QyxvQ0FBb0MsbUJBQU8sQ0FBQyx3R0FBTztBQUNuRCxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLEVBQUUsYUFBYTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixxQ0FBcUMsNEJBQTRCO0FBQ2pFLHNDQUFzQyxzQ0FBc0M7QUFDNUUsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRiw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBLEVBQUU7QUFDRjtBQUNBLGtDQUFrQztBQUNsQyx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw0REFBNEQ7QUFDNUQscUJBQXFCLGFBQW9CO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsa0RBQWtELCtJQUEwRDs7QUFFNUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUssTUFBTSxVQUFVLEdBQUcsVUFBVSxVQUFVLElBQUksR0FBRyxJQUFJO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0EsdUNBQXVDLEtBQUssTUFBTSxJQUFJLEdBQUcsSUFBSSxRQUFRLGFBQWEsTUFBTSxZQUFZLEdBQUcsWUFBWTs7QUFFbkg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLHdDQUF3QyxjQUFjLFNBQVMsV0FBVyxHQUFHLFdBQVc7QUFDeEY7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpQ0FBaUMsS0FBSyxLQUFLLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLElBQUk7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCLGNBQWMsTUFBTTtBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWSxHQUFHLEVBQUUsSUFBSSxLQUFLLDhCQUE4QixPQUFPLEdBQUcsYUFBYTtBQUMzSDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWSxHQUFHLEVBQUUsa0NBQWtDLFFBQVEsR0FBRyxjQUFjO0FBQ3RIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxvREFBb0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RvY2ttYXN0ZXItaW1zLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL3V0aWxzLmpzP2Y4MzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmJvdHRvbSA9IGJvdHRvbTtcbmV4cG9ydHMuY2hpbGRyZW5FcXVhbCA9IGNoaWxkcmVuRXF1YWw7XG5leHBvcnRzLmNsb25lTGF5b3V0ID0gY2xvbmVMYXlvdXQ7XG5leHBvcnRzLmNsb25lTGF5b3V0SXRlbSA9IGNsb25lTGF5b3V0SXRlbTtcbmV4cG9ydHMuY29sbGlkZXMgPSBjb2xsaWRlcztcbmV4cG9ydHMuY29tcGFjdCA9IGNvbXBhY3Q7XG5leHBvcnRzLmNvbXBhY3RJdGVtID0gY29tcGFjdEl0ZW07XG5leHBvcnRzLmNvbXBhY3RUeXBlID0gY29tcGFjdFR5cGU7XG5leHBvcnRzLmNvcnJlY3RCb3VuZHMgPSBjb3JyZWN0Qm91bmRzO1xuZXhwb3J0cy5mYXN0UG9zaXRpb25FcXVhbCA9IGZhc3RQb3NpdGlvbkVxdWFsO1xuZXhwb3J0cy5mYXN0UkdMUHJvcHNFcXVhbCA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0QWxsQ29sbGlzaW9ucyA9IGdldEFsbENvbGxpc2lvbnM7XG5leHBvcnRzLmdldEZpcnN0Q29sbGlzaW9uID0gZ2V0Rmlyc3RDb2xsaXNpb247XG5leHBvcnRzLmdldExheW91dEl0ZW0gPSBnZXRMYXlvdXRJdGVtO1xuZXhwb3J0cy5nZXRTdGF0aWNzID0gZ2V0U3RhdGljcztcbmV4cG9ydHMubW9kaWZ5TGF5b3V0ID0gbW9kaWZ5TGF5b3V0O1xuZXhwb3J0cy5tb3ZlRWxlbWVudCA9IG1vdmVFbGVtZW50O1xuZXhwb3J0cy5tb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uID0gbW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbjtcbmV4cG9ydHMubm9vcCA9IHZvaWQgMDtcbmV4cG9ydHMucGVyYyA9IHBlcmM7XG5leHBvcnRzLnJlc2l6ZUl0ZW1JbkRpcmVjdGlvbiA9IHJlc2l6ZUl0ZW1JbkRpcmVjdGlvbjtcbmV4cG9ydHMuc2V0VG9wTGVmdCA9IHNldFRvcExlZnQ7XG5leHBvcnRzLnNldFRyYW5zZm9ybSA9IHNldFRyYW5zZm9ybTtcbmV4cG9ydHMuc29ydExheW91dEl0ZW1zID0gc29ydExheW91dEl0ZW1zO1xuZXhwb3J0cy5zb3J0TGF5b3V0SXRlbXNCeUNvbFJvdyA9IHNvcnRMYXlvdXRJdGVtc0J5Q29sUm93O1xuZXhwb3J0cy5zb3J0TGF5b3V0SXRlbXNCeVJvd0NvbCA9IHNvcnRMYXlvdXRJdGVtc0J5Um93Q29sO1xuZXhwb3J0cy5zeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbiA9IHN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuO1xuZXhwb3J0cy52YWxpZGF0ZUxheW91dCA9IHZhbGlkYXRlTGF5b3V0O1xuZXhwb3J0cy53aXRoTGF5b3V0SXRlbSA9IHdpdGhMYXlvdXRJdGVtO1xudmFyIF9mYXN0RXF1YWxzID0gcmVxdWlyZShcImZhc3QtZXF1YWxzXCIpO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cbi8qOjogaW1wb3J0IHR5cGUge1xuICBDaGlsZHJlbkFycmF5IGFzIFJlYWN0Q2hpbGRyZW5BcnJheSxcbiAgRWxlbWVudCBhcyBSZWFjdEVsZW1lbnRcbn0gZnJvbSBcInJlYWN0XCI7Ki9cbi8qOjogZXhwb3J0IHR5cGUgUmVzaXplSGFuZGxlQXhpcyA9XG4gIHwgXCJzXCJcbiAgfCBcIndcIlxuICB8IFwiZVwiXG4gIHwgXCJuXCJcbiAgfCBcInN3XCJcbiAgfCBcIm53XCJcbiAgfCBcInNlXCJcbiAgfCBcIm5lXCI7Ki9cbi8qOjogZXhwb3J0IHR5cGUgTGF5b3V0SXRlbSA9IHtcbiAgdzogbnVtYmVyLFxuICBoOiBudW1iZXIsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBpOiBzdHJpbmcsXG4gIG1pblc/OiBudW1iZXIsXG4gIG1pbkg/OiBudW1iZXIsXG4gIG1heFc/OiBudW1iZXIsXG4gIG1heEg/OiBudW1iZXIsXG4gIG1vdmVkPzogYm9vbGVhbixcbiAgc3RhdGljPzogYm9vbGVhbixcbiAgaXNEcmFnZ2FibGU/OiA/Ym9vbGVhbixcbiAgaXNSZXNpemFibGU/OiA/Ym9vbGVhbixcbiAgcmVzaXplSGFuZGxlcz86IEFycmF5PFJlc2l6ZUhhbmRsZUF4aXM+LFxuICBpc0JvdW5kZWQ/OiA/Ym9vbGVhblxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBMYXlvdXQgPSAkUmVhZE9ubHlBcnJheTxMYXlvdXRJdGVtPjsqL1xuLyo6OiBleHBvcnQgdHlwZSBQb3NpdGlvbiA9IHtcbiAgbGVmdDogbnVtYmVyLFxuICB0b3A6IG51bWJlcixcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXJcbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgUmVhY3REcmFnZ2FibGVDYWxsYmFja0RhdGEgPSB7XG4gIG5vZGU6IEhUTUxFbGVtZW50LFxuICB4PzogbnVtYmVyLFxuICB5PzogbnVtYmVyLFxuICBkZWx0YVg6IG51bWJlcixcbiAgZGVsdGFZOiBudW1iZXIsXG4gIGxhc3RYPzogbnVtYmVyLFxuICBsYXN0WT86IG51bWJlclxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBQYXJ0aWFsUG9zaXRpb24gPSB7IGxlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIgfTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcm9wcGluZ1Bvc2l0aW9uID0geyBsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBlOiBFdmVudCB9OyovXG4vKjo6IGV4cG9ydCB0eXBlIFNpemUgPSB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH07Ki9cbi8qOjogZXhwb3J0IHR5cGUgR3JpZERyYWdFdmVudCA9IHtcbiAgZTogRXZlbnQsXG4gIG5vZGU6IEhUTUxFbGVtZW50LFxuICBuZXdQb3NpdGlvbjogUGFydGlhbFBvc2l0aW9uXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIEdyaWRSZXNpemVFdmVudCA9IHtcbiAgZTogRXZlbnQsXG4gIG5vZGU6IEhUTUxFbGVtZW50LFxuICBzaXplOiBTaXplLFxuICBoYW5kbGU6IHN0cmluZ1xufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnT3ZlckV2ZW50ID0gTW91c2VFdmVudCAmIHtcbiAgbmF0aXZlRXZlbnQ6IHtcbiAgICBsYXllclg6IG51bWJlcixcbiAgICBsYXllclk6IG51bWJlcixcbiAgICAuLi5FdmVudFxuICB9XG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIFBpY2s8RnJvbVR5cGUsIFByb3BlcnRpZXM6IHsgW3N0cmluZ106IDAgfT4gPSAkRXhhY3Q8XG4gICRPYmpNYXBpPFByb3BlcnRpZXMsIDxLLCBWPihrOiBLLCB2OiBWKSA9PiAkRWxlbWVudFR5cGU8RnJvbVR5cGUsIEs+PlxuPjsqL1xuLy8gSGVscGZ1bCBwb3J0IGZyb20gVFNcbi8qOjogdHlwZSBSRWwgPSBSZWFjdEVsZW1lbnQ8YW55PjsqL1xuLyo6OiBleHBvcnQgdHlwZSBSZWFjdENoaWxkcmVuID0gUmVhY3RDaGlsZHJlbkFycmF5PFJFbD47Ki9cbi8qOjogZXhwb3J0IHR5cGUgRXZlbnRDYWxsYmFjayA9IChcbiAgTGF5b3V0LFxuICBvbGRJdGVtOiA/TGF5b3V0SXRlbSxcbiAgbmV3SXRlbTogP0xheW91dEl0ZW0sXG4gIHBsYWNlaG9sZGVyOiA/TGF5b3V0SXRlbSxcbiAgRXZlbnQsXG4gID9IVE1MRWxlbWVudFxuKSA9PiB2b2lkOyovXG4vLyBBbGwgY2FsbGJhY2tzIGFyZSBvZiB0aGUgc2lnbmF0dXJlIChsYXlvdXQsIG9sZEl0ZW0sIG5ld0l0ZW0sIHBsYWNlaG9sZGVyLCBlKS5cbi8qOjogZXhwb3J0IHR5cGUgQ29tcGFjdFR5cGUgPSA/KFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiKTsqL1xuY29uc3QgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xuY29uc3QgREVCVUcgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJvdHRvbSBjb29yZGluYXRlIG9mIHRoZSBsYXlvdXQuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQgYXJyYXkuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIEJvdHRvbSBjb29yZGluYXRlLlxuICovXG5mdW5jdGlvbiBib3R0b20obGF5b3V0IC8qOiBMYXlvdXQqLykgLyo6IG51bWJlciove1xuICBsZXQgbWF4ID0gMCxcbiAgICBib3R0b21ZO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYm90dG9tWSA9IGxheW91dFtpXS55ICsgbGF5b3V0W2ldLmg7XG4gICAgaWYgKGJvdHRvbVkgPiBtYXgpIG1heCA9IGJvdHRvbVk7XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cbmZ1bmN0aW9uIGNsb25lTGF5b3V0KGxheW91dCAvKjogTGF5b3V0Ki8pIC8qOiBMYXlvdXQqL3tcbiAgY29uc3QgbmV3TGF5b3V0ID0gQXJyYXkobGF5b3V0Lmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuZXdMYXlvdXRbaV0gPSBjbG9uZUxheW91dEl0ZW0obGF5b3V0W2ldKTtcbiAgfVxuICByZXR1cm4gbmV3TGF5b3V0O1xufVxuXG4vLyBNb2RpZnkgYSBsYXlvdXRJdGVtIGluc2lkZSBhIGxheW91dC4gUmV0dXJucyBhIG5ldyBMYXlvdXQsXG4vLyBkb2VzIG5vdCBtdXRhdGUuIENhcnJpZXMgb3ZlciBhbGwgb3RoZXIgTGF5b3V0SXRlbXMgdW5tb2RpZmllZC5cbmZ1bmN0aW9uIG1vZGlmeUxheW91dChsYXlvdXQgLyo6IExheW91dCovLCBsYXlvdXRJdGVtIC8qOiBMYXlvdXRJdGVtKi8pIC8qOiBMYXlvdXQqL3tcbiAgY29uc3QgbmV3TGF5b3V0ID0gQXJyYXkobGF5b3V0Lmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAobGF5b3V0SXRlbS5pID09PSBsYXlvdXRbaV0uaSkge1xuICAgICAgbmV3TGF5b3V0W2ldID0gbGF5b3V0SXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3TGF5b3V0W2ldID0gbGF5b3V0W2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3TGF5b3V0O1xufVxuXG4vLyBGdW5jdGlvbiB0byBiZSBjYWxsZWQgdG8gbW9kaWZ5IGEgbGF5b3V0IGl0ZW0uXG4vLyBEb2VzIGRlZmVuc2l2ZSBjbG9uZXMgdG8gZW5zdXJlIHRoZSBsYXlvdXQgaXMgbm90IG1vZGlmaWVkLlxuZnVuY3Rpb24gd2l0aExheW91dEl0ZW0obGF5b3V0IC8qOiBMYXlvdXQqLywgaXRlbUtleSAvKjogc3RyaW5nKi8sIGNiIC8qOiBMYXlvdXRJdGVtID0+IExheW91dEl0ZW0qLykgLyo6IFtMYXlvdXQsID9MYXlvdXRJdGVtXSove1xuICBsZXQgaXRlbSA9IGdldExheW91dEl0ZW0obGF5b3V0LCBpdGVtS2V5KTtcbiAgaWYgKCFpdGVtKSByZXR1cm4gW2xheW91dCwgbnVsbF07XG4gIGl0ZW0gPSBjYihjbG9uZUxheW91dEl0ZW0oaXRlbSkpOyAvLyBkZWZlbnNpdmUgY2xvbmUgdGhlbiBtb2RpZnlcbiAgLy8gRklYTUUgY291bGQgZG8gdGhpcyBmYXN0ZXIgaWYgd2UgYWxyZWFkeSBrbmV3IHRoZSBpbmRleFxuICBsYXlvdXQgPSBtb2RpZnlMYXlvdXQobGF5b3V0LCBpdGVtKTtcbiAgcmV0dXJuIFtsYXlvdXQsIGl0ZW1dO1xufVxuXG4vLyBGYXN0IHBhdGggdG8gY2xvbmluZywgc2luY2UgdGhpcyBpcyBtb25vbW9ycGhpY1xuZnVuY3Rpb24gY2xvbmVMYXlvdXRJdGVtKGxheW91dEl0ZW0gLyo6IExheW91dEl0ZW0qLykgLyo6IExheW91dEl0ZW0qL3tcbiAgcmV0dXJuIHtcbiAgICB3OiBsYXlvdXRJdGVtLncsXG4gICAgaDogbGF5b3V0SXRlbS5oLFxuICAgIHg6IGxheW91dEl0ZW0ueCxcbiAgICB5OiBsYXlvdXRJdGVtLnksXG4gICAgaTogbGF5b3V0SXRlbS5pLFxuICAgIG1pblc6IGxheW91dEl0ZW0ubWluVyxcbiAgICBtYXhXOiBsYXlvdXRJdGVtLm1heFcsXG4gICAgbWluSDogbGF5b3V0SXRlbS5taW5ILFxuICAgIG1heEg6IGxheW91dEl0ZW0ubWF4SCxcbiAgICBtb3ZlZDogQm9vbGVhbihsYXlvdXRJdGVtLm1vdmVkKSxcbiAgICBzdGF0aWM6IEJvb2xlYW4obGF5b3V0SXRlbS5zdGF0aWMpLFxuICAgIC8vIFRoZXNlIGNhbiBiZSBudWxsL3VuZGVmaW5lZFxuICAgIGlzRHJhZ2dhYmxlOiBsYXlvdXRJdGVtLmlzRHJhZ2dhYmxlLFxuICAgIGlzUmVzaXphYmxlOiBsYXlvdXRJdGVtLmlzUmVzaXphYmxlLFxuICAgIHJlc2l6ZUhhbmRsZXM6IGxheW91dEl0ZW0ucmVzaXplSGFuZGxlcyxcbiAgICBpc0JvdW5kZWQ6IGxheW91dEl0ZW0uaXNCb3VuZGVkXG4gIH07XG59XG5cbi8qKlxuICogQ29tcGFyaW5nIFJlYWN0IGBjaGlsZHJlbmAgaXMgYSBiaXQgZGlmZmljdWx0LiBUaGlzIGlzIGEgZ29vZCB3YXkgdG8gY29tcGFyZSB0aGVtLlxuICogVGhpcyB3aWxsIGNhdGNoIGRpZmZlcmVuY2VzIGluIGtleXMsIG9yZGVyLCBhbmQgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBjaGlsZHJlbkVxdWFsKGEgLyo6IFJlYWN0Q2hpbGRyZW4qLywgYiAvKjogUmVhY3RDaGlsZHJlbiovKSAvKjogYm9vbGVhbiove1xuICByZXR1cm4gKDAsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkoX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ubWFwKGEsIGMgPT4gYz8ua2V5KSwgX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ubWFwKGIsIGMgPT4gYz8ua2V5KSkgJiYgKDAsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkoX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ubWFwKGEsIGMgPT4gYz8ucHJvcHNbXCJkYXRhLWdyaWRcIl0pLCBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5tYXAoYiwgYyA9PiBjPy5wcm9wc1tcImRhdGEtZ3JpZFwiXSkpO1xufVxuXG4vKipcbiAqIFNlZSBgZmFzdFJHTFByb3BzRXF1YWwuanNgLlxuICogV2Ugd2FudCB0aGlzIHRvIHJ1biBhcyBmYXN0IGFzIHBvc3NpYmxlIC0gaXQgaXMgY2FsbGVkIG9mdGVuIC0gYW5kIHRvIGJlXG4gKiByZXNpbGllbnQgdG8gbmV3IHByb3BzIHRoYXQgd2UgYWRkLiBTbyByYXRoZXIgdGhhbiBjYWxsIGxvZGFzaC5pc0VxdWFsLFxuICogd2hpY2ggaXNuJ3Qgc3VpdGVkIHRvIGNvbXBhcmluZyBwcm9wcyB2ZXJ5IHdlbGwsIHdlIHVzZSB0aGlzIHNwZWNpYWxpemVkXG4gKiBmdW5jdGlvbiBpbiBjb25qdW5jdGlvbiB3aXRoIHByZXZhbCB0byBnZW5lcmF0ZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBjb21wYXJpc29uXG4gKiBmdW5jdGlvbiwgdHVuZWQgZm9yIGV4YWN0bHkgb3VyIHByb3BzLlxuICovXG4vKjo6IHR5cGUgRmFzdFJHTFByb3BzRXF1YWwgPSAoT2JqZWN0LCBPYmplY3QsIEZ1bmN0aW9uKSA9PiBib29sZWFuOyovXG5jb25zdCBmYXN0UkdMUHJvcHNFcXVhbCAvKjogRmFzdFJHTFByb3BzRXF1YWwqLyA9IGV4cG9ydHMuZmFzdFJHTFByb3BzRXF1YWwgPSByZXF1aXJlKFwiLi9mYXN0UkdMUHJvcHNFcXVhbFwiKTtcblxuLy8gTGlrZSB0aGUgYWJvdmUsIGJ1dCBhIGxvdCBzaW1wbGVyLlxuZnVuY3Rpb24gZmFzdFBvc2l0aW9uRXF1YWwoYSAvKjogUG9zaXRpb24qLywgYiAvKjogUG9zaXRpb24qLykgLyo6IGJvb2xlYW4qL3tcbiAgcmV0dXJuIGEubGVmdCA9PT0gYi5sZWZ0ICYmIGEudG9wID09PSBiLnRvcCAmJiBhLndpZHRoID09PSBiLndpZHRoICYmIGEuaGVpZ2h0ID09PSBiLmhlaWdodDtcbn1cblxuLyoqXG4gKiBHaXZlbiB0d28gbGF5b3V0aXRlbXMsIGNoZWNrIGlmIHRoZXkgY29sbGlkZS5cbiAqL1xuZnVuY3Rpb24gY29sbGlkZXMobDEgLyo6IExheW91dEl0ZW0qLywgbDIgLyo6IExheW91dEl0ZW0qLykgLyo6IGJvb2xlYW4qL3tcbiAgaWYgKGwxLmkgPT09IGwyLmkpIHJldHVybiBmYWxzZTsgLy8gc2FtZSBlbGVtZW50XG4gIGlmIChsMS54ICsgbDEudyA8PSBsMi54KSByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIGxlZnQgb2YgbDJcbiAgaWYgKGwxLnggPj0gbDIueCArIGwyLncpIHJldHVybiBmYWxzZTsgLy8gbDEgaXMgcmlnaHQgb2YgbDJcbiAgaWYgKGwxLnkgKyBsMS5oIDw9IGwyLnkpIHJldHVybiBmYWxzZTsgLy8gbDEgaXMgYWJvdmUgbDJcbiAgaWYgKGwxLnkgPj0gbDIueSArIGwyLmgpIHJldHVybiBmYWxzZTsgLy8gbDEgaXMgYmVsb3cgbDJcbiAgcmV0dXJuIHRydWU7IC8vIGJveGVzIG92ZXJsYXBcbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxheW91dCwgY29tcGFjdCBpdC4gVGhpcyBpbnZvbHZlcyBnb2luZyBkb3duIGVhY2ggeSBjb29yZGluYXRlIGFuZCByZW1vdmluZyBnYXBzXG4gKiBiZXR3ZWVuIGl0ZW1zLlxuICpcbiAqIERvZXMgbm90IG1vZGlmeSBsYXlvdXQgaXRlbXMgKGNsb25lcykuIENyZWF0ZXMgYSBuZXcgbGF5b3V0IGFycmF5LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgTGF5b3V0LlxuICogQHBhcmFtICB7Qm9vbGVhbn0gdmVydGljYWxDb21wYWN0IFdoZXRoZXIgb3Igbm90IHRvIGNvbXBhY3QgdGhlIGxheW91dFxuICogICB2ZXJ0aWNhbGx5LlxuICogQHBhcmFtICB7Qm9vbGVhbn0gYWxsb3dPdmVybGFwIFdoZW4gYHRydWVgLCBhbGxvd3Mgb3ZlcmxhcHBpbmcgZ3JpZCBpdGVtcy5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICBDb21wYWN0ZWQgTGF5b3V0LlxuICovXG5mdW5jdGlvbiBjb21wYWN0KGxheW91dCAvKjogTGF5b3V0Ki8sIGNvbXBhY3RUeXBlIC8qOiBDb21wYWN0VHlwZSovLCBjb2xzIC8qOiBudW1iZXIqLywgYWxsb3dPdmVybGFwIC8qOiA/Ym9vbGVhbiovKSAvKjogTGF5b3V0Ki97XG4gIC8vIFN0YXRpY3MgZ28gaW4gdGhlIGNvbXBhcmVXaXRoIGFycmF5IHJpZ2h0IGF3YXkgc28gaXRlbXMgZmxvdyBhcm91bmQgdGhlbS5cbiAgY29uc3QgY29tcGFyZVdpdGggPSBnZXRTdGF0aWNzKGxheW91dCk7XG4gIC8vIFdlIGdvIHRocm91Z2ggdGhlIGl0ZW1zIGJ5IHJvdyBhbmQgY29sdW1uLlxuICBjb25zdCBzb3J0ZWQgPSBzb3J0TGF5b3V0SXRlbXMobGF5b3V0LCBjb21wYWN0VHlwZSk7XG4gIC8vIEhvbGRpbmcgZm9yIG5ldyBpdGVtcy5cbiAgY29uc3Qgb3V0ID0gQXJyYXkobGF5b3V0Lmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzb3J0ZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgbCA9IGNsb25lTGF5b3V0SXRlbShzb3J0ZWRbaV0pO1xuXG4gICAgLy8gRG9uJ3QgbW92ZSBzdGF0aWMgZWxlbWVudHNcbiAgICBpZiAoIWwuc3RhdGljKSB7XG4gICAgICBsID0gY29tcGFjdEl0ZW0oY29tcGFyZVdpdGgsIGwsIGNvbXBhY3RUeXBlLCBjb2xzLCBzb3J0ZWQsIGFsbG93T3ZlcmxhcCk7XG5cbiAgICAgIC8vIEFkZCB0byBjb21wYXJpc29uIGFycmF5LiBXZSBvbmx5IGNvbGxpZGUgd2l0aCBpdGVtcyBiZWZvcmUgdGhpcyBvbmUuXG4gICAgICAvLyBTdGF0aWNzIGFyZSBhbHJlYWR5IGluIHRoaXMgYXJyYXkuXG4gICAgICBjb21wYXJlV2l0aC5wdXNoKGwpO1xuICAgIH1cblxuICAgIC8vIEFkZCB0byBvdXRwdXQgYXJyYXkgdG8gbWFrZSBzdXJlIHRoZXkgc3RpbGwgY29tZSBvdXQgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuICAgIG91dFtsYXlvdXQuaW5kZXhPZihzb3J0ZWRbaV0pXSA9IGw7XG5cbiAgICAvLyBDbGVhciBtb3ZlZCBmbGFnLCBpZiBpdCBleGlzdHMuXG4gICAgbC5tb3ZlZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5jb25zdCBoZWlnaHRXaWR0aCA9IHtcbiAgeDogXCJ3XCIsXG4gIHk6IFwiaFwiXG59O1xuLyoqXG4gKiBCZWZvcmUgbW92aW5nIGl0ZW0gZG93biwgaXQgd2lsbCBjaGVjayBpZiB0aGUgbW92ZW1lbnQgd2lsbCBjYXVzZSBjb2xsaXNpb25zIGFuZCBtb3ZlIHRob3NlIGl0ZW1zIGRvd24gYmVmb3JlLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQ29tcGFjdGlvbkNvbGxpc2lvbihsYXlvdXQgLyo6IExheW91dCovLCBpdGVtIC8qOiBMYXlvdXRJdGVtKi8sIG1vdmVUb0Nvb3JkIC8qOiBudW1iZXIqLywgYXhpcyAvKjogXCJ4XCIgfCBcInlcIiovKSB7XG4gIGNvbnN0IHNpemVQcm9wID0gaGVpZ2h0V2lkdGhbYXhpc107XG4gIGl0ZW1bYXhpc10gKz0gMTtcbiAgY29uc3QgaXRlbUluZGV4ID0gbGF5b3V0Lm1hcChsYXlvdXRJdGVtID0+IHtcbiAgICByZXR1cm4gbGF5b3V0SXRlbS5pO1xuICB9KS5pbmRleE9mKGl0ZW0uaSk7XG5cbiAgLy8gR28gdGhyb3VnaCBlYWNoIGl0ZW0gd2UgY29sbGlkZSB3aXRoLlxuICBmb3IgKGxldCBpID0gaXRlbUluZGV4ICsgMTsgaSA8IGxheW91dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG90aGVySXRlbSA9IGxheW91dFtpXTtcbiAgICAvLyBJZ25vcmUgc3RhdGljIGl0ZW1zXG4gICAgaWYgKG90aGVySXRlbS5zdGF0aWMpIGNvbnRpbnVlO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uOiB3ZSBjYW4gYnJlYWsgZWFybHkgaWYgd2Uga25vdyB3ZSdyZSBwYXN0IHRoaXMgZWxcbiAgICAvLyBXZSBjYW4gZG8gdGhpcyBiL2MgaXQncyBhIHNvcnRlZCBsYXlvdXRcbiAgICBpZiAob3RoZXJJdGVtLnkgPiBpdGVtLnkgKyBpdGVtLmgpIGJyZWFrO1xuICAgIGlmIChjb2xsaWRlcyhpdGVtLCBvdGhlckl0ZW0pKSB7XG4gICAgICByZXNvbHZlQ29tcGFjdGlvbkNvbGxpc2lvbihsYXlvdXQsIG90aGVySXRlbSwgbW92ZVRvQ29vcmQgKyBpdGVtW3NpemVQcm9wXSwgYXhpcyk7XG4gICAgfVxuICB9XG4gIGl0ZW1bYXhpc10gPSBtb3ZlVG9Db29yZDtcbn1cblxuLyoqXG4gKiBDb21wYWN0IGFuIGl0ZW0gaW4gdGhlIGxheW91dC5cbiAqXG4gKiBNb2RpZmllcyBpdGVtLlxuICpcbiAqL1xuZnVuY3Rpb24gY29tcGFjdEl0ZW0oY29tcGFyZVdpdGggLyo6IExheW91dCovLCBsIC8qOiBMYXlvdXRJdGVtKi8sIGNvbXBhY3RUeXBlIC8qOiBDb21wYWN0VHlwZSovLCBjb2xzIC8qOiBudW1iZXIqLywgZnVsbExheW91dCAvKjogTGF5b3V0Ki8sIGFsbG93T3ZlcmxhcCAvKjogP2Jvb2xlYW4qLykgLyo6IExheW91dEl0ZW0qL3tcbiAgY29uc3QgY29tcGFjdFYgPSBjb21wYWN0VHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICBjb25zdCBjb21wYWN0SCA9IGNvbXBhY3RUeXBlID09PSBcImhvcml6b250YWxcIjtcbiAgaWYgKGNvbXBhY3RWKSB7XG4gICAgLy8gQm90dG9tICd5JyBwb3NzaWJsZSBpcyB0aGUgYm90dG9tIG9mIHRoZSBsYXlvdXQuXG4gICAgLy8gVGhpcyBhbGxvd3MgeW91IHRvIGRvIG5pY2Ugc3R1ZmYgbGlrZSBzcGVjaWZ5IHt5OiBJbmZpbml0eX1cbiAgICAvLyBUaGlzIGlzIGhlcmUgYmVjYXVzZSB0aGUgbGF5b3V0IG11c3QgYmUgc29ydGVkIGluIG9yZGVyIHRvIGdldCB0aGUgY29ycmVjdCBib3R0b20gYHlgLlxuICAgIGwueSA9IE1hdGgubWluKGJvdHRvbShjb21wYXJlV2l0aCksIGwueSk7XG4gICAgLy8gTW92ZSB0aGUgZWxlbWVudCB1cCBhcyBmYXIgYXMgaXQgY2FuIGdvIHdpdGhvdXQgY29sbGlkaW5nLlxuICAgIHdoaWxlIChsLnkgPiAwICYmICFnZXRGaXJzdENvbGxpc2lvbihjb21wYXJlV2l0aCwgbCkpIHtcbiAgICAgIGwueS0tO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb21wYWN0SCkge1xuICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgbGVmdCBhcyBmYXIgYXMgaXQgY2FuIGdvIHdpdGhvdXQgY29sbGlkaW5nLlxuICAgIHdoaWxlIChsLnggPiAwICYmICFnZXRGaXJzdENvbGxpc2lvbihjb21wYXJlV2l0aCwgbCkpIHtcbiAgICAgIGwueC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1vdmUgaXQgZG93biwgYW5kIGtlZXAgbW92aW5nIGl0IGRvd24gaWYgaXQncyBjb2xsaWRpbmcuXG4gIGxldCBjb2xsaWRlcztcbiAgLy8gQ2hlY2tpbmcgdGhlIGNvbXBhY3RUeXBlIG51bGwgdmFsdWUgdG8gYXZvaWQgYnJlYWtpbmcgdGhlIGxheW91dCB3aGVuIG92ZXJsYXBwaW5nIGlzIGFsbG93ZWQuXG4gIHdoaWxlICgoY29sbGlkZXMgPSBnZXRGaXJzdENvbGxpc2lvbihjb21wYXJlV2l0aCwgbCkpICYmICEoY29tcGFjdFR5cGUgPT09IG51bGwgJiYgYWxsb3dPdmVybGFwKSkge1xuICAgIGlmIChjb21wYWN0SCkge1xuICAgICAgcmVzb2x2ZUNvbXBhY3Rpb25Db2xsaXNpb24oZnVsbExheW91dCwgbCwgY29sbGlkZXMueCArIGNvbGxpZGVzLncsIFwieFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZUNvbXBhY3Rpb25Db2xsaXNpb24oZnVsbExheW91dCwgbCwgY29sbGlkZXMueSArIGNvbGxpZGVzLmgsIFwieVwiKTtcbiAgICB9XG4gICAgLy8gU2luY2Ugd2UgY2FuJ3QgZ3JvdyB3aXRob3V0IGJvdW5kcyBob3Jpem9udGFsbHksIGlmIHdlJ3ZlIG92ZXJmbG93biwgbGV0J3MgbW92ZSBpdCBkb3duIGFuZCB0cnkgYWdhaW4uXG4gICAgaWYgKGNvbXBhY3RIICYmIGwueCArIGwudyA+IGNvbHMpIHtcbiAgICAgIGwueCA9IGNvbHMgLSBsLnc7XG4gICAgICBsLnkrKztcbiAgICAgIC8vIEFMc28gbW92ZSBlbGVtZW50IGFzIGxlZnQgYXMgd2UgY2FuXG4gICAgICB3aGlsZSAobC54ID4gMCAmJiAhZ2V0Rmlyc3RDb2xsaXNpb24oY29tcGFyZVdpdGgsIGwpKSB7XG4gICAgICAgIGwueC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZXJlIGFyZSBubyBuZWdhdGl2ZSBwb3NpdGlvbnNcbiAgbC55ID0gTWF0aC5tYXgobC55LCAwKTtcbiAgbC54ID0gTWF0aC5tYXgobC54LCAwKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBsYXlvdXQsIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgZml0IHdpdGhpbiBpdHMgYm91bmRzLlxuICpcbiAqIE1vZGlmaWVzIGxheW91dCBpdGVtcy5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0IExheW91dCBhcnJheS5cbiAqIEBwYXJhbSAge051bWJlcn0gYm91bmRzIE51bWJlciBvZiBjb2x1bW5zLlxuICovXG5mdW5jdGlvbiBjb3JyZWN0Qm91bmRzKGxheW91dCAvKjogTGF5b3V0Ki8sIGJvdW5kcyAvKjogeyBjb2xzOiBudW1iZXIgfSovKSAvKjogTGF5b3V0Ki97XG4gIGNvbnN0IGNvbGxpZGVzV2l0aCA9IGdldFN0YXRpY3MobGF5b3V0KTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGwgPSBsYXlvdXRbaV07XG4gICAgLy8gT3ZlcmZsb3dzIHJpZ2h0XG4gICAgaWYgKGwueCArIGwudyA+IGJvdW5kcy5jb2xzKSBsLnggPSBib3VuZHMuY29scyAtIGwudztcbiAgICAvLyBPdmVyZmxvd3MgbGVmdFxuICAgIGlmIChsLnggPCAwKSB7XG4gICAgICBsLnggPSAwO1xuICAgICAgbC53ID0gYm91bmRzLmNvbHM7XG4gICAgfVxuICAgIGlmICghbC5zdGF0aWMpIGNvbGxpZGVzV2l0aC5wdXNoKGwpO2Vsc2Uge1xuICAgICAgLy8gSWYgdGhpcyBpcyBzdGF0aWMgYW5kIGNvbGxpZGVzIHdpdGggb3RoZXIgc3RhdGljcywgd2UgbXVzdCBtb3ZlIGl0IGRvd24uXG4gICAgICAvLyBXZSBoYXZlIHRvIGRvIHNvbWV0aGluZyBuaWNlciB0aGFuIGp1c3QgbGV0dGluZyB0aGVtIG92ZXJsYXAuXG4gICAgICB3aGlsZSAoZ2V0Rmlyc3RDb2xsaXNpb24oY29sbGlkZXNXaXRoLCBsKSkge1xuICAgICAgICBsLnkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxheW91dDtcbn1cblxuLyoqXG4gKiBHZXQgYSBsYXlvdXQgaXRlbSBieSBJRC4gVXNlZCBzbyB3ZSBjYW4gb3ZlcnJpZGUgbGF0ZXIgb24gaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgbGF5b3V0IExheW91dCBhcnJheS5cbiAqIEBwYXJhbSAge1N0cmluZ30gaWQgICAgIElEXG4gKiBAcmV0dXJuIHtMYXlvdXRJdGVtfSAgICBJdGVtIGF0IElELlxuICovXG5mdW5jdGlvbiBnZXRMYXlvdXRJdGVtKGxheW91dCAvKjogTGF5b3V0Ki8sIGlkIC8qOiBzdHJpbmcqLykgLyo6ID9MYXlvdXRJdGVtKi97XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAobGF5b3V0W2ldLmkgPT09IGlkKSByZXR1cm4gbGF5b3V0W2ldO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSB0aGlzIGxheW91dCBjb2xsaWRlcyB3aXRoLlxuICogSXQgZG9lc24ndCBhcHBlYXIgdG8gbWF0dGVyIHdoaWNoIG9yZGVyIHdlIGFwcHJvYWNoIHRoaXMgZnJvbSwgYWx0aG91Z2hcbiAqIHBlcmhhcHMgdGhhdCBpcyB0aGUgd3JvbmcgdGhpbmcgdG8gZG8uXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBsYXlvdXRJdGVtIExheW91dCBpdGVtLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gIEEgY29sbGlkaW5nIGxheW91dCBpdGVtLCBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0Q29sbGlzaW9uKGxheW91dCAvKjogTGF5b3V0Ki8sIGxheW91dEl0ZW0gLyo6IExheW91dEl0ZW0qLykgLyo6ID9MYXlvdXRJdGVtKi97XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoY29sbGlkZXMobGF5b3V0W2ldLCBsYXlvdXRJdGVtKSkgcmV0dXJuIGxheW91dFtpXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWxsQ29sbGlzaW9ucyhsYXlvdXQgLyo6IExheW91dCovLCBsYXlvdXRJdGVtIC8qOiBMYXlvdXRJdGVtKi8pIC8qOiBBcnJheTxMYXlvdXRJdGVtPiove1xuICByZXR1cm4gbGF5b3V0LmZpbHRlcihsID0+IGNvbGxpZGVzKGwsIGxheW91dEl0ZW0pKTtcbn1cblxuLyoqXG4gKiBHZXQgYWxsIHN0YXRpYyBlbGVtZW50cy5cbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgQXJyYXkgb2YgbGF5b3V0IG9iamVjdHMuXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgIEFycmF5IG9mIHN0YXRpYyBsYXlvdXQgaXRlbXMuLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0aWNzKGxheW91dCAvKjogTGF5b3V0Ki8pIC8qOiBBcnJheTxMYXlvdXRJdGVtPiove1xuICByZXR1cm4gbGF5b3V0LmZpbHRlcihsID0+IGwuc3RhdGljKTtcbn1cblxuLyoqXG4gKiBNb3ZlIGFuIGVsZW1lbnQuIFJlc3BvbnNpYmxlIGZvciBkb2luZyBjYXNjYWRpbmcgbW92ZW1lbnRzIG9mIG90aGVyIGVsZW1lbnRzLlxuICpcbiAqIE1vZGlmaWVzIGxheW91dCBpdGVtcy5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBsYXlvdXQgICAgICAgICAgICBGdWxsIGxheW91dCB0byBtb2RpZnkuXG4gKiBAcGFyYW0gIHtMYXlvdXRJdGVtfSBsICAgICAgICAgICAgICAgICBlbGVtZW50IHRvIG1vdmUuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBbeF0gICAgICAgICAgICAgICBYIHBvc2l0aW9uIGluIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBbeV0gICAgICAgICAgICAgICBZIHBvc2l0aW9uIGluIGdyaWQgdW5pdHMuXG4gKi9cbmZ1bmN0aW9uIG1vdmVFbGVtZW50KGxheW91dCAvKjogTGF5b3V0Ki8sIGwgLyo6IExheW91dEl0ZW0qLywgeCAvKjogP251bWJlciovLCB5IC8qOiA/bnVtYmVyKi8sIGlzVXNlckFjdGlvbiAvKjogP2Jvb2xlYW4qLywgcHJldmVudENvbGxpc2lvbiAvKjogP2Jvb2xlYW4qLywgY29tcGFjdFR5cGUgLyo6IENvbXBhY3RUeXBlKi8sIGNvbHMgLyo6IG51bWJlciovLCBhbGxvd092ZXJsYXAgLyo6ID9ib29sZWFuKi8pIC8qOiBMYXlvdXQqL3tcbiAgLy8gSWYgdGhpcyBpcyBzdGF0aWMgYW5kIG5vdCBleHBsaWNpdGx5IGVuYWJsZWQgYXMgZHJhZ2dhYmxlLFxuICAvLyBubyBtb3ZlIGlzIHBvc3NpYmxlLCBzbyB3ZSBjYW4gc2hvcnQtY2lyY3VpdCB0aGlzIGltbWVkaWF0ZWx5LlxuICBpZiAobC5zdGF0aWMgJiYgbC5pc0RyYWdnYWJsZSAhPT0gdHJ1ZSkgcmV0dXJuIGxheW91dDtcblxuICAvLyBTaG9ydC1jaXJjdWl0IGlmIG5vdGhpbmcgdG8gZG8uXG4gIGlmIChsLnkgPT09IHkgJiYgbC54ID09PSB4KSByZXR1cm4gbGF5b3V0O1xuICBsb2coYE1vdmluZyBlbGVtZW50ICR7bC5pfSB0byBbJHtTdHJpbmcoeCl9LCR7U3RyaW5nKHkpfV0gZnJvbSBbJHtsLnh9LCR7bC55fV1gKTtcbiAgY29uc3Qgb2xkWCA9IGwueDtcbiAgY29uc3Qgb2xkWSA9IGwueTtcblxuICAvLyBUaGlzIGlzIHF1aXRlIGEgYml0IGZhc3RlciB0aGFuIGV4dGVuZGluZyB0aGUgb2JqZWN0XG4gIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikgbC54ID0geDtcbiAgaWYgKHR5cGVvZiB5ID09PSBcIm51bWJlclwiKSBsLnkgPSB5O1xuICBsLm1vdmVkID0gdHJ1ZTtcblxuICAvLyBJZiB0aGlzIGNvbGxpZGVzIHdpdGggYW55dGhpbmcsIG1vdmUgaXQuXG4gIC8vIFdoZW4gZG9pbmcgdGhpcyBjb21wYXJpc29uLCB3ZSBoYXZlIHRvIHNvcnQgdGhlIGl0ZW1zIHdlIGNvbXBhcmUgd2l0aFxuICAvLyB0byBlbnN1cmUsIGluIHRoZSBjYXNlIG9mIG11bHRpcGxlIGNvbGxpc2lvbnMsIHRoYXQgd2UncmUgZ2V0dGluZyB0aGVcbiAgLy8gbmVhcmVzdCBjb2xsaXNpb24uXG4gIGxldCBzb3J0ZWQgPSBzb3J0TGF5b3V0SXRlbXMobGF5b3V0LCBjb21wYWN0VHlwZSk7XG4gIGNvbnN0IG1vdmluZ1VwID0gY29tcGFjdFR5cGUgPT09IFwidmVydGljYWxcIiAmJiB0eXBlb2YgeSA9PT0gXCJudW1iZXJcIiA/IG9sZFkgPj0geSA6IGNvbXBhY3RUeXBlID09PSBcImhvcml6b250YWxcIiAmJiB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiA/IG9sZFggPj0geCA6IGZhbHNlO1xuICAvLyAkRmxvd0lnbm9yZSBhY2NlcHRhYmxlIG1vZGlmaWNhdGlvbiBvZiByZWFkLW9ubHkgYXJyYXkgYXMgaXQgd2FzIHJlY2VudGx5IGNsb25lZFxuICBpZiAobW92aW5nVXApIHNvcnRlZCA9IHNvcnRlZC5yZXZlcnNlKCk7XG4gIGNvbnN0IGNvbGxpc2lvbnMgPSBnZXRBbGxDb2xsaXNpb25zKHNvcnRlZCwgbCk7XG4gIGNvbnN0IGhhc0NvbGxpc2lvbnMgPSBjb2xsaXNpb25zLmxlbmd0aCA+IDA7XG5cbiAgLy8gV2UgbWF5IGhhdmUgY29sbGlzaW9ucy4gV2UgY2FuIHNob3J0LWNpcmN1aXQgaWYgd2UndmUgdHVybmVkIG9mZiBjb2xsaXNpb25zIG9yXG4gIC8vIGFsbG93ZWQgb3ZlcmxhcC5cbiAgaWYgKGhhc0NvbGxpc2lvbnMgJiYgYWxsb3dPdmVybGFwKSB7XG4gICAgLy8gRWFzeSwgd2UgZG9uJ3QgbmVlZCB0byByZXNvbHZlIGNvbGxpc2lvbnMuIEJ1dCB3ZSAqZGlkKiBjaGFuZ2UgdGhlIGxheW91dCxcbiAgICAvLyBzbyBjbG9uZSBpdCBvbiB0aGUgd2F5IG91dC5cbiAgICByZXR1cm4gY2xvbmVMYXlvdXQobGF5b3V0KTtcbiAgfSBlbHNlIGlmIChoYXNDb2xsaXNpb25zICYmIHByZXZlbnRDb2xsaXNpb24pIHtcbiAgICAvLyBJZiB3ZSBhcmUgcHJldmVudGluZyBjb2xsaXNpb24gYnV0IG5vdCBhbGxvd2luZyBvdmVybGFwLCB3ZSBuZWVkIHRvXG4gICAgLy8gcmV2ZXJ0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQgc28gaXQgZ29lcyB0byB3aGVyZSBpdCBjYW1lIGZyb20sIHJhdGhlclxuICAgIC8vIHRoYW4gdGhlIHVzZXIncyBkZXNpcmVkIGxvY2F0aW9uLlxuICAgIGxvZyhgQ29sbGlzaW9uIHByZXZlbnRlZCBvbiAke2wuaX0sIHJldmVydGluZy5gKTtcbiAgICBsLnggPSBvbGRYO1xuICAgIGwueSA9IG9sZFk7XG4gICAgbC5tb3ZlZCA9IGZhbHNlO1xuICAgIHJldHVybiBsYXlvdXQ7IC8vIGRpZCBub3QgY2hhbmdlIHNvIGRvbid0IGNsb25lXG4gIH1cblxuICAvLyBNb3ZlIGVhY2ggaXRlbSB0aGF0IGNvbGxpZGVzIGF3YXkgZnJvbSB0aGlzIGVsZW1lbnQuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb2xsaXNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY29sbGlzaW9uID0gY29sbGlzaW9uc1tpXTtcbiAgICBsb2coYFJlc29sdmluZyBjb2xsaXNpb24gYmV0d2VlbiAke2wuaX0gYXQgWyR7bC54fSwke2wueX1dIGFuZCAke2NvbGxpc2lvbi5pfSBhdCBbJHtjb2xsaXNpb24ueH0sJHtjb2xsaXNpb24ueX1dYCk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IHNvIHdlIGNhbid0IGluZmluaXRlIGxvb3BcbiAgICBpZiAoY29sbGlzaW9uLm1vdmVkKSBjb250aW51ZTtcblxuICAgIC8vIERvbid0IG1vdmUgc3RhdGljIGl0ZW1zIC0gd2UgaGF2ZSB0byBtb3ZlICp0aGlzKiBlbGVtZW50IGF3YXlcbiAgICBpZiAoY29sbGlzaW9uLnN0YXRpYykge1xuICAgICAgbGF5b3V0ID0gbW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbihsYXlvdXQsIGNvbGxpc2lvbiwgbCwgaXNVc2VyQWN0aW9uLCBjb21wYWN0VHlwZSwgY29scyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheW91dCA9IG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb24obGF5b3V0LCBsLCBjb2xsaXNpb24sIGlzVXNlckFjdGlvbiwgY29tcGFjdFR5cGUsIGNvbHMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGF5b3V0O1xufVxuXG4vKipcbiAqIFRoaXMgaXMgd2hlcmUgdGhlIG1hZ2ljIG5lZWRzIHRvIGhhcHBlbiAtIGdpdmVuIGEgY29sbGlzaW9uLCBtb3ZlIGFuIGVsZW1lbnQgYXdheSBmcm9tIHRoZSBjb2xsaXNpb24uXG4gKiBXZSBhdHRlbXB0IHRvIG1vdmUgaXQgdXAgaWYgdGhlcmUncyByb29tLCBvdGhlcndpc2UgaXQgZ29lcyBiZWxvdy5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0ICAgICAgICAgICAgRnVsbCBsYXlvdXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtICB7TGF5b3V0SXRlbX0gY29sbGlkZXNXaXRoIExheW91dCBpdGVtIHdlJ3JlIGNvbGxpZGluZyB3aXRoLlxuICogQHBhcmFtICB7TGF5b3V0SXRlbX0gaXRlbVRvTW92ZSAgIExheW91dCBpdGVtIHdlJ3JlIG1vdmluZy5cbiAqL1xuZnVuY3Rpb24gbW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbihsYXlvdXQgLyo6IExheW91dCovLCBjb2xsaWRlc1dpdGggLyo6IExheW91dEl0ZW0qLywgaXRlbVRvTW92ZSAvKjogTGF5b3V0SXRlbSovLCBpc1VzZXJBY3Rpb24gLyo6ID9ib29sZWFuKi8sIGNvbXBhY3RUeXBlIC8qOiBDb21wYWN0VHlwZSovLCBjb2xzIC8qOiBudW1iZXIqLykgLyo6IExheW91dCove1xuICBjb25zdCBjb21wYWN0SCA9IGNvbXBhY3RUeXBlID09PSBcImhvcml6b250YWxcIjtcbiAgLy8gQ29tcGFjdCB2ZXJ0aWNhbGx5IGlmIG5vdCBzZXQgdG8gaG9yaXpvbnRhbFxuICBjb25zdCBjb21wYWN0ViA9IGNvbXBhY3RUeXBlID09PSBcInZlcnRpY2FsXCI7XG4gIGNvbnN0IHByZXZlbnRDb2xsaXNpb24gPSBjb2xsaWRlc1dpdGguc3RhdGljOyAvLyB3ZSdyZSBhbHJlYWR5IGNvbGxpZGluZyAobm90IGZvciBzdGF0aWMgaXRlbXMpXG5cbiAgLy8gSWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGFib3ZlIHRoZSBjb2xsaXNpb24gdG8gcHV0IHRoaXMgZWxlbWVudCwgbW92ZSBpdCB0aGVyZS5cbiAgLy8gV2Ugb25seSBkbyB0aGlzIG9uIHRoZSBtYWluIGNvbGxpc2lvbiBhcyB0aGlzIGNhbiBnZXQgZnVua3kgaW4gY2FzY2FkZXMgYW5kIGNhdXNlXG4gIC8vIHVud2FudGVkIHN3YXBwaW5nIGJlaGF2aW9yLlxuICBpZiAoaXNVc2VyQWN0aW9uKSB7XG4gICAgLy8gUmVzZXQgaXNVc2VyQWN0aW9uIGZsYWcgYmVjYXVzZSB3ZSdyZSBub3QgaW4gdGhlIG1haW4gY29sbGlzaW9uIGFueW1vcmUuXG4gICAgaXNVc2VyQWN0aW9uID0gZmFsc2U7XG5cbiAgICAvLyBNYWtlIGEgbW9jayBpdGVtIHNvIHdlIGRvbid0IG1vZGlmeSB0aGUgaXRlbSBoZXJlLCBvbmx5IG1vZGlmeSBpbiBtb3ZlRWxlbWVudC5cbiAgICBjb25zdCBmYWtlSXRlbSAvKjogTGF5b3V0SXRlbSovID0ge1xuICAgICAgeDogY29tcGFjdEggPyBNYXRoLm1heChjb2xsaWRlc1dpdGgueCAtIGl0ZW1Ub01vdmUudywgMCkgOiBpdGVtVG9Nb3ZlLngsXG4gICAgICB5OiBjb21wYWN0ViA/IE1hdGgubWF4KGNvbGxpZGVzV2l0aC55IC0gaXRlbVRvTW92ZS5oLCAwKSA6IGl0ZW1Ub01vdmUueSxcbiAgICAgIHc6IGl0ZW1Ub01vdmUudyxcbiAgICAgIGg6IGl0ZW1Ub01vdmUuaCxcbiAgICAgIGk6IFwiLTFcIlxuICAgIH07XG4gICAgY29uc3QgZmlyc3RDb2xsaXNpb24gPSBnZXRGaXJzdENvbGxpc2lvbihsYXlvdXQsIGZha2VJdGVtKTtcbiAgICBjb25zdCBjb2xsaXNpb25Ob3J0aCA9IGZpcnN0Q29sbGlzaW9uICYmIGZpcnN0Q29sbGlzaW9uLnkgKyBmaXJzdENvbGxpc2lvbi5oID4gY29sbGlkZXNXaXRoLnk7XG4gICAgY29uc3QgY29sbGlzaW9uV2VzdCA9IGZpcnN0Q29sbGlzaW9uICYmIGNvbGxpZGVzV2l0aC54ICsgY29sbGlkZXNXaXRoLncgPiBmaXJzdENvbGxpc2lvbi54O1xuXG4gICAgLy8gTm8gY29sbGlzaW9uPyBJZiBzbywgd2UgY2FuIGdvIHVwIHRoZXJlOyBvdGhlcndpc2UsIHdlJ2xsIGVuZCB1cCBtb3ZpbmcgZG93biBhcyBub3JtYWxcbiAgICBpZiAoIWZpcnN0Q29sbGlzaW9uKSB7XG4gICAgICBsb2coYERvaW5nIHJldmVyc2UgY29sbGlzaW9uIG9uICR7aXRlbVRvTW92ZS5pfSB1cCB0byBbJHtmYWtlSXRlbS54fSwke2Zha2VJdGVtLnl9XS5gKTtcbiAgICAgIHJldHVybiBtb3ZlRWxlbWVudChsYXlvdXQsIGl0ZW1Ub01vdmUsIGNvbXBhY3RIID8gZmFrZUl0ZW0ueCA6IHVuZGVmaW5lZCwgY29tcGFjdFYgPyBmYWtlSXRlbS55IDogdW5kZWZpbmVkLCBpc1VzZXJBY3Rpb24sIHByZXZlbnRDb2xsaXNpb24sIGNvbXBhY3RUeXBlLCBjb2xzKTtcbiAgICB9IGVsc2UgaWYgKGNvbGxpc2lvbk5vcnRoICYmIGNvbXBhY3RWKSB7XG4gICAgICByZXR1cm4gbW92ZUVsZW1lbnQobGF5b3V0LCBpdGVtVG9Nb3ZlLCB1bmRlZmluZWQsIGNvbGxpZGVzV2l0aC55ICsgMSwgaXNVc2VyQWN0aW9uLCBwcmV2ZW50Q29sbGlzaW9uLCBjb21wYWN0VHlwZSwgY29scyk7XG4gICAgfSBlbHNlIGlmIChjb2xsaXNpb25Ob3J0aCAmJiBjb21wYWN0VHlwZSA9PSBudWxsKSB7XG4gICAgICBjb2xsaWRlc1dpdGgueSA9IGl0ZW1Ub01vdmUueTtcbiAgICAgIGl0ZW1Ub01vdmUueSA9IGl0ZW1Ub01vdmUueSArIGl0ZW1Ub01vdmUuaDtcbiAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfSBlbHNlIGlmIChjb2xsaXNpb25XZXN0ICYmIGNvbXBhY3RIKSB7XG4gICAgICByZXR1cm4gbW92ZUVsZW1lbnQobGF5b3V0LCBjb2xsaWRlc1dpdGgsIGl0ZW1Ub01vdmUueCwgdW5kZWZpbmVkLCBpc1VzZXJBY3Rpb24sIHByZXZlbnRDb2xsaXNpb24sIGNvbXBhY3RUeXBlLCBjb2xzKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbmV3WCA9IGNvbXBhY3RIID8gaXRlbVRvTW92ZS54ICsgMSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbmV3WSA9IGNvbXBhY3RWID8gaXRlbVRvTW92ZS55ICsgMSA6IHVuZGVmaW5lZDtcbiAgaWYgKG5ld1ggPT0gbnVsbCAmJiBuZXdZID09IG51bGwpIHtcbiAgICByZXR1cm4gbGF5b3V0O1xuICB9XG4gIHJldHVybiBtb3ZlRWxlbWVudChsYXlvdXQsIGl0ZW1Ub01vdmUsIGNvbXBhY3RIID8gaXRlbVRvTW92ZS54ICsgMSA6IHVuZGVmaW5lZCwgY29tcGFjdFYgPyBpdGVtVG9Nb3ZlLnkgKyAxIDogdW5kZWZpbmVkLCBpc1VzZXJBY3Rpb24sIHByZXZlbnRDb2xsaXNpb24sIGNvbXBhY3RUeXBlLCBjb2xzKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gY29udmVydCBhIG51bWJlciB0byBhIHBlcmNlbnRhZ2Ugc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gbnVtIEFueSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgIFRoYXQgbnVtYmVyIGFzIGEgcGVyY2VudGFnZS5cbiAqL1xuZnVuY3Rpb24gcGVyYyhudW0gLyo6IG51bWJlciovKSAvKjogc3RyaW5nKi97XG4gIHJldHVybiBudW0gKiAxMDAgKyBcIiVcIjtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIHRvIGNvbnN0cmFpbiBkaW1lbnNpb25zIG9mIGEgR3JpZEl0ZW1cbiAqL1xuY29uc3QgY29uc3RyYWluV2lkdGggPSAobGVmdCAvKjogbnVtYmVyKi8sIGN1cnJlbnRXaWR0aCAvKjogbnVtYmVyKi8sIG5ld1dpZHRoIC8qOiBudW1iZXIqLywgY29udGFpbmVyV2lkdGggLyo6IG51bWJlciovKSA9PiB7XG4gIHJldHVybiBsZWZ0ICsgbmV3V2lkdGggPiBjb250YWluZXJXaWR0aCA/IGN1cnJlbnRXaWR0aCA6IG5ld1dpZHRoO1xufTtcbmNvbnN0IGNvbnN0cmFpbkhlaWdodCA9ICh0b3AgLyo6IG51bWJlciovLCBjdXJyZW50SGVpZ2h0IC8qOiBudW1iZXIqLywgbmV3SGVpZ2h0IC8qOiBudW1iZXIqLykgPT4ge1xuICByZXR1cm4gdG9wIDwgMCA/IGN1cnJlbnRIZWlnaHQgOiBuZXdIZWlnaHQ7XG59O1xuY29uc3QgY29uc3RyYWluTGVmdCA9IChsZWZ0IC8qOiBudW1iZXIqLykgPT4gTWF0aC5tYXgoMCwgbGVmdCk7XG5jb25zdCBjb25zdHJhaW5Ub3AgPSAodG9wIC8qOiBudW1iZXIqLykgPT4gTWF0aC5tYXgoMCwgdG9wKTtcbmNvbnN0IHJlc2l6ZU5vcnRoID0gKGN1cnJlbnRTaXplLCBfcmVmLCBfY29udGFpbmVyV2lkdGgpID0+IHtcbiAgbGV0IHtcbiAgICBsZWZ0LFxuICAgIGhlaWdodCxcbiAgICB3aWR0aFxuICB9ID0gX3JlZjtcbiAgY29uc3QgdG9wID0gY3VycmVudFNpemUudG9wIC0gKGhlaWdodCAtIGN1cnJlbnRTaXplLmhlaWdodCk7XG4gIHJldHVybiB7XG4gICAgbGVmdCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQ6IGNvbnN0cmFpbkhlaWdodCh0b3AsIGN1cnJlbnRTaXplLmhlaWdodCwgaGVpZ2h0KSxcbiAgICB0b3A6IGNvbnN0cmFpblRvcCh0b3ApXG4gIH07XG59O1xuY29uc3QgcmVzaXplRWFzdCA9IChjdXJyZW50U2l6ZSwgX3JlZjIsIGNvbnRhaW5lcldpZHRoKSA9PiB7XG4gIGxldCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoXG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIHtcbiAgICB0b3AsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoOiBjb25zdHJhaW5XaWR0aChjdXJyZW50U2l6ZS5sZWZ0LCBjdXJyZW50U2l6ZS53aWR0aCwgd2lkdGgsIGNvbnRhaW5lcldpZHRoKSxcbiAgICBsZWZ0OiBjb25zdHJhaW5MZWZ0KGxlZnQpXG4gIH07XG59O1xuY29uc3QgcmVzaXplV2VzdCA9IChjdXJyZW50U2l6ZSwgX3JlZjMsIGNvbnRhaW5lcldpZHRoKSA9PiB7XG4gIGxldCB7XG4gICAgdG9wLFxuICAgIGhlaWdodCxcbiAgICB3aWR0aFxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IGxlZnQgPSBjdXJyZW50U2l6ZS5sZWZ0IC0gKHdpZHRoIC0gY3VycmVudFNpemUud2lkdGgpO1xuICByZXR1cm4ge1xuICAgIGhlaWdodCxcbiAgICB3aWR0aDogbGVmdCA8IDAgPyBjdXJyZW50U2l6ZS53aWR0aCA6IGNvbnN0cmFpbldpZHRoKGN1cnJlbnRTaXplLmxlZnQsIGN1cnJlbnRTaXplLndpZHRoLCB3aWR0aCwgY29udGFpbmVyV2lkdGgpLFxuICAgIHRvcDogY29uc3RyYWluVG9wKHRvcCksXG4gICAgbGVmdDogY29uc3RyYWluTGVmdChsZWZ0KVxuICB9O1xufTtcbmNvbnN0IHJlc2l6ZVNvdXRoID0gKGN1cnJlbnRTaXplLCBfcmVmNCwgY29udGFpbmVyV2lkdGgpID0+IHtcbiAgbGV0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGhcbiAgfSA9IF9yZWY0O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGxlZnQsXG4gICAgaGVpZ2h0OiBjb25zdHJhaW5IZWlnaHQodG9wLCBjdXJyZW50U2l6ZS5oZWlnaHQsIGhlaWdodCksXG4gICAgdG9wOiBjb25zdHJhaW5Ub3AodG9wKVxuICB9O1xufTtcbmNvbnN0IHJlc2l6ZU5vcnRoRWFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlc2l6ZU5vcnRoKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgcmVzaXplRWFzdCguLi5hcmd1bWVudHMpLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xufTtcbmNvbnN0IHJlc2l6ZU5vcnRoV2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlc2l6ZU5vcnRoKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgcmVzaXplV2VzdCguLi5hcmd1bWVudHMpLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xufTtcbmNvbnN0IHJlc2l6ZVNvdXRoRWFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlc2l6ZVNvdXRoKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgcmVzaXplRWFzdCguLi5hcmd1bWVudHMpLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xufTtcbmNvbnN0IHJlc2l6ZVNvdXRoV2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlc2l6ZVNvdXRoKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgcmVzaXplV2VzdCguLi5hcmd1bWVudHMpLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xufTtcbmNvbnN0IG9yZGluYWxSZXNpemVIYW5kbGVyTWFwID0ge1xuICBuOiByZXNpemVOb3J0aCxcbiAgbmU6IHJlc2l6ZU5vcnRoRWFzdCxcbiAgZTogcmVzaXplRWFzdCxcbiAgc2U6IHJlc2l6ZVNvdXRoRWFzdCxcbiAgczogcmVzaXplU291dGgsXG4gIHN3OiByZXNpemVTb3V0aFdlc3QsXG4gIHc6IHJlc2l6ZVdlc3QsXG4gIG53OiByZXNpemVOb3J0aFdlc3Rcbn07XG5cbi8qKlxuICogSGVscGVyIGZvciBjbGFtcGluZyB3aWR0aCBhbmQgcG9zaXRpb24gd2hlbiByZXNpemluZyBhbiBpdGVtLlxuICovXG5mdW5jdGlvbiByZXNpemVJdGVtSW5EaXJlY3Rpb24oZGlyZWN0aW9uIC8qOiBSZXNpemVIYW5kbGVBeGlzKi8sIGN1cnJlbnRTaXplIC8qOiBQb3NpdGlvbiovLCBuZXdTaXplIC8qOiBQb3NpdGlvbiovLCBjb250YWluZXJXaWR0aCAvKjogbnVtYmVyKi8pIC8qOiBQb3NpdGlvbiove1xuICBjb25zdCBvcmRpbmFsSGFuZGxlciA9IG9yZGluYWxSZXNpemVIYW5kbGVyTWFwW2RpcmVjdGlvbl07XG4gIC8vIFNob3VsZG4ndCBiZSBwb3NzaWJsZSBnaXZlbiB0eXBlczsgdGhhdCBzYWlkLCBkb24ndCBmYWlsIGhhcmRcbiAgaWYgKCFvcmRpbmFsSGFuZGxlcikgcmV0dXJuIG5ld1NpemU7XG4gIHJldHVybiBvcmRpbmFsSGFuZGxlcihjdXJyZW50U2l6ZSwge1xuICAgIC4uLmN1cnJlbnRTaXplLFxuICAgIC4uLm5ld1NpemVcbiAgfSwgY29udGFpbmVyV2lkdGgpO1xufVxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtKF9yZWY1IC8qOjogKi8pIC8qOiBPYmplY3QqL3tcbiAgbGV0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSAvKjogUG9zaXRpb24qLyA9IF9yZWY1IC8qOiBQb3NpdGlvbiovO1xuICAvLyBSZXBsYWNlIHVuaXRsZXNzIGl0ZW1zIHdpdGggcHhcbiAgY29uc3QgdHJhbnNsYXRlID0gYHRyYW5zbGF0ZSgke2xlZnR9cHgsJHt0b3B9cHgpYDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICBXZWJraXRUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICBNb3pUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICBtc1RyYW5zZm9ybTogdHJhbnNsYXRlLFxuICAgIE9UcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICB3aWR0aDogYCR7d2lkdGh9cHhgLFxuICAgIGhlaWdodDogYCR7aGVpZ2h0fXB4YCxcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gIH07XG59XG5mdW5jdGlvbiBzZXRUb3BMZWZ0KF9yZWY2IC8qOjogKi8pIC8qOiBPYmplY3QqL3tcbiAgbGV0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSAvKjogUG9zaXRpb24qLyA9IF9yZWY2IC8qOiBQb3NpdGlvbiovO1xuICByZXR1cm4ge1xuICAgIHRvcDogYCR7dG9wfXB4YCxcbiAgICBsZWZ0OiBgJHtsZWZ0fXB4YCxcbiAgICB3aWR0aDogYCR7d2lkdGh9cHhgLFxuICAgIGhlaWdodDogYCR7aGVpZ2h0fXB4YCxcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gIH07XG59XG5cbi8qKlxuICogR2V0IGxheW91dCBpdGVtcyBzb3J0ZWQgZnJvbSB0b3AgbGVmdCB0byByaWdodCBhbmQgZG93bi5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgbGF5b3V0IG9iamVjdHMuXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgIExheW91dCwgc29ydGVkIHN0YXRpYyBpdGVtcyBmaXJzdC5cbiAqL1xuZnVuY3Rpb24gc29ydExheW91dEl0ZW1zKGxheW91dCAvKjogTGF5b3V0Ki8sIGNvbXBhY3RUeXBlIC8qOiBDb21wYWN0VHlwZSovKSAvKjogTGF5b3V0Ki97XG4gIGlmIChjb21wYWN0VHlwZSA9PT0gXCJob3Jpem9udGFsXCIpIHJldHVybiBzb3J0TGF5b3V0SXRlbXNCeUNvbFJvdyhsYXlvdXQpO1xuICBpZiAoY29tcGFjdFR5cGUgPT09IFwidmVydGljYWxcIikgcmV0dXJuIHNvcnRMYXlvdXRJdGVtc0J5Um93Q29sKGxheW91dCk7ZWxzZSByZXR1cm4gbGF5b3V0O1xufVxuXG4vKipcbiAqIFNvcnQgbGF5b3V0IGl0ZW1zIGJ5IHJvdyBhc2NlbmRpbmcgYW5kIGNvbHVtbiBhc2NlbmRpbmcuXG4gKlxuICogRG9lcyBub3QgbW9kaWZ5IExheW91dC5cbiAqL1xuZnVuY3Rpb24gc29ydExheW91dEl0ZW1zQnlSb3dDb2wobGF5b3V0IC8qOiBMYXlvdXQqLykgLyo6IExheW91dCove1xuICAvLyBTbGljZSB0byBjbG9uZSBhcnJheSBhcyBzb3J0IG1vZGlmaWVzXG4gIHJldHVybiBsYXlvdXQuc2xpY2UoMCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLnkgPiBiLnkgfHwgYS55ID09PSBiLnkgJiYgYS54ID4gYi54KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGEueSA9PT0gYi55ICYmIGEueCA9PT0gYi54KSB7XG4gICAgICAvLyBXaXRob3V0IHRoaXMsIHdlIGNhbiBnZXQgZGlmZmVyZW50IHNvcnQgcmVzdWx0cyBpbiBJRSB2cy4gQ2hyb21lL0ZGXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTb3J0IGxheW91dCBpdGVtcyBieSBjb2x1bW4gYXNjZW5kaW5nIHRoZW4gcm93IGFzY2VuZGluZy5cbiAqXG4gKiBEb2VzIG5vdCBtb2RpZnkgTGF5b3V0LlxuICovXG5mdW5jdGlvbiBzb3J0TGF5b3V0SXRlbXNCeUNvbFJvdyhsYXlvdXQgLyo6IExheW91dCovKSAvKjogTGF5b3V0Ki97XG4gIHJldHVybiBsYXlvdXQuc2xpY2UoMCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLnggPiBiLnggfHwgYS54ID09PSBiLnggJiYgYS55ID4gYi55KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGxheW91dCB1c2luZyB0aGUgaW5pdGlhbExheW91dCBhbmQgY2hpbGRyZW4gYXMgYSB0ZW1wbGF0ZS5cbiAqIE1pc3NpbmcgZW50cmllcyB3aWxsIGJlIGFkZGVkLCBleHRyYW5lb3VzIG9uZXMgd2lsbCBiZSB0cnVuY2F0ZWQuXG4gKlxuICogRG9lcyBub3QgbW9kaWZ5IGluaXRpYWxMYXlvdXQuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBpbml0aWFsTGF5b3V0IExheW91dCBwYXNzZWQgaW4gdGhyb3VnaCBwcm9wcy5cbiAqIEBwYXJhbSAge1N0cmluZ30gYnJlYWtwb2ludCAgICBDdXJyZW50IHJlc3BvbnNpdmUgYnJlYWtwb2ludC5cbiAqIEBwYXJhbSAgez9TdHJpbmd9IGNvbXBhY3QgICAgICBDb21wYWN0aW9uIG9wdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICBXb3JraW5nIGxheW91dC5cbiAqL1xuZnVuY3Rpb24gc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4oaW5pdGlhbExheW91dCAvKjogTGF5b3V0Ki8sIGNoaWxkcmVuIC8qOiBSZWFjdENoaWxkcmVuKi8sIGNvbHMgLyo6IG51bWJlciovLCBjb21wYWN0VHlwZSAvKjogQ29tcGFjdFR5cGUqLywgYWxsb3dPdmVybGFwIC8qOiA/Ym9vbGVhbiovKSAvKjogTGF5b3V0Ki97XG4gIGluaXRpYWxMYXlvdXQgPSBpbml0aWFsTGF5b3V0IHx8IFtdO1xuXG4gIC8vIEdlbmVyYXRlIG9uZSBsYXlvdXQgaXRlbSBwZXIgY2hpbGQuXG4gIGNvbnN0IGxheW91dCAvKjogTGF5b3V0SXRlbVtdKi8gPSBbXTtcbiAgX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkIC8qOiBSZWFjdEVsZW1lbnQ8YW55PiovKSA9PiB7XG4gICAgLy8gQ2hpbGQgbWF5IG5vdCBleGlzdFxuICAgIGlmIChjaGlsZD8ua2V5ID09IG51bGwpIHJldHVybjtcbiAgICBjb25zdCBleGlzdHMgPSBnZXRMYXlvdXRJdGVtKGluaXRpYWxMYXlvdXQsIFN0cmluZyhjaGlsZC5rZXkpKTtcbiAgICBjb25zdCBnID0gY2hpbGQucHJvcHNbXCJkYXRhLWdyaWRcIl07XG4gICAgLy8gRG9uJ3Qgb3ZlcndyaXRlIHRoZSBsYXlvdXQgaXRlbSBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIGluaXRpYWwgbGF5b3V0LlxuICAgIC8vIElmIGl0IGhhcyBhIGBkYXRhLWdyaWRgIHByb3BlcnR5LCBwcmVmZXIgdGhhdCBvdmVyIHdoYXQncyBpbiB0aGUgbGF5b3V0LlxuICAgIGlmIChleGlzdHMgJiYgZyA9PSBudWxsKSB7XG4gICAgICBsYXlvdXQucHVzaChjbG9uZUxheW91dEl0ZW0oZXhpc3RzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhleSwgdGhpcyBpdGVtIGhhcyBhIGRhdGEtZ3JpZCBwcm9wZXJ0eSwgdXNlIGl0LlxuICAgICAgaWYgKGcpIHtcbiAgICAgICAgaWYgKCFpc1Byb2R1Y3Rpb24pIHtcbiAgICAgICAgICB2YWxpZGF0ZUxheW91dChbZ10sIFwiUmVhY3RHcmlkTGF5b3V0LmNoaWxkcmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZJWE1FIGNsb25lIG5vdCByZWFsbHkgbmVjZXNzYXJ5IGhlcmVcbiAgICAgICAgbGF5b3V0LnB1c2goY2xvbmVMYXlvdXRJdGVtKHtcbiAgICAgICAgICAuLi5nLFxuICAgICAgICAgIGk6IGNoaWxkLmtleVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3RoaW5nIHByb3ZpZGVkOiBlbnN1cmUgdGhpcyBpcyBhZGRlZCB0byB0aGUgYm90dG9tXG4gICAgICAgIC8vIEZJWE1FIGNsb25lIG5vdCByZWFsbHkgbmVjZXNzYXJ5IGhlcmVcbiAgICAgICAgbGF5b3V0LnB1c2goY2xvbmVMYXlvdXRJdGVtKHtcbiAgICAgICAgICB3OiAxLFxuICAgICAgICAgIGg6IDEsXG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiBib3R0b20obGF5b3V0KSxcbiAgICAgICAgICBpOiBTdHJpbmcoY2hpbGQua2V5KVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBDb3JyZWN0IHRoZSBsYXlvdXQuXG4gIGNvbnN0IGNvcnJlY3RlZExheW91dCA9IGNvcnJlY3RCb3VuZHMobGF5b3V0LCB7XG4gICAgY29sczogY29sc1xuICB9KTtcbiAgcmV0dXJuIGFsbG93T3ZlcmxhcCA/IGNvcnJlY3RlZExheW91dCA6IGNvbXBhY3QoY29ycmVjdGVkTGF5b3V0LCBjb21wYWN0VHlwZSwgY29scyk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgYSBsYXlvdXQuIFRocm93cyBlcnJvcnMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBsYXlvdXQgICAgICAgIEFycmF5IG9mIGxheW91dCBpdGVtcy5cbiAqIEBwYXJhbSAge1N0cmluZ30gW2NvbnRleHROYW1lXSBDb250ZXh0IG5hbWUgZm9yIGVycm9ycy5cbiAqIEB0aHJvdyAge0Vycm9yfSAgICAgICAgICAgICAgICBWYWxpZGF0aW9uIGVycm9yLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUxheW91dChsYXlvdXQgLyo6IExheW91dCovKSAvKjogdm9pZCove1xuICBsZXQgY29udGV4dE5hbWUgLyo6IHN0cmluZyovID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIkxheW91dFwiO1xuICBjb25zdCBzdWJQcm9wcyA9IFtcInhcIiwgXCJ5XCIsIFwid1wiLCBcImhcIl07XG4gIGlmICghQXJyYXkuaXNBcnJheShsYXlvdXQpKSB0aHJvdyBuZXcgRXJyb3IoY29udGV4dE5hbWUgKyBcIiBtdXN0IGJlIGFuIGFycmF5IVwiKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGl0ZW0gPSBsYXlvdXRbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdWJQcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qga2V5ID0gc3ViUHJvcHNbal07XG4gICAgICBjb25zdCB2YWx1ZSA9IGl0ZW1ba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgfHwgTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlYWN0R3JpZExheW91dDogJHtjb250ZXh0TmFtZX1bJHtpfV0uJHtrZXl9IG11c3QgYmUgYSBudW1iZXIhIFJlY2VpdmVkOiAke3ZhbHVlfSAoJHt0eXBlb2YgdmFsdWV9KWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZW0uaSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgaXRlbS5pICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlYWN0R3JpZExheW91dDogJHtjb250ZXh0TmFtZX1bJHtpfV0uaSBtdXN0IGJlIGEgc3RyaW5nISBSZWNlaXZlZDogJHtpdGVtLml9ICgke3R5cGVvZiBpdGVtLml9KWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBMZWdhY3kgc3VwcG9ydCBmb3IgdmVydGljYWxDb21wYWN0OiBmYWxzZVxuZnVuY3Rpb24gY29tcGFjdFR5cGUocHJvcHMgLyo6ID97IHZlcnRpY2FsQ29tcGFjdDogYm9vbGVhbiwgY29tcGFjdFR5cGU6IENvbXBhY3RUeXBlIH0qLykgLyo6IENvbXBhY3RUeXBlKi97XG4gIGNvbnN0IHtcbiAgICB2ZXJ0aWNhbENvbXBhY3QsXG4gICAgY29tcGFjdFR5cGVcbiAgfSA9IHByb3BzIHx8IHt9O1xuICByZXR1cm4gdmVydGljYWxDb21wYWN0ID09PSBmYWxzZSA/IG51bGwgOiBjb21wYWN0VHlwZTtcbn1cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKCFERUJVRykgcmV0dXJuO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmxvZyguLi5hcmd1bWVudHMpO1xufVxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuZXhwb3J0cy5ub29wID0gbm9vcDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-grid-layout/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./build/ReactGridLayout */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js\")[\"default\"];\nmodule.exports.utils = __webpack_require__(/*! ./build/utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nmodule.exports.calculateUtils = __webpack_require__(/*! ./build/calculateUtils */ \"(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\");\nmodule.exports.Responsive = __webpack_require__(/*! ./build/ResponsiveReactGridLayout */ \"(ssr)/./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js\")[\"default\"];\nmodule.exports.Responsive.utils = __webpack_require__(/*! ./build/responsiveUtils */ \"(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js\");\nmodule.exports.WidthProvider = __webpack_require__(/*! ./build/components/WidthProvider */ \"(ssr)/./node_modules/react-grid-layout/build/components/WidthProvider.js\")[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsaUpBQTJEO0FBQzNELHdIQUErQztBQUMvQyxtSkFBaUU7QUFDakUsZ0xBQ3NEO0FBQ3RELHVKQUFvRTtBQUNwRSxpTEFDcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdG9ja21hc3Rlci1pbXMvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvaW5kZXguanM/ZDFmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2J1aWxkL1JlYWN0R3JpZExheW91dFwiKS5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMudXRpbHMgPSByZXF1aXJlKFwiLi9idWlsZC91dGlsc1wiKTtcbm1vZHVsZS5leHBvcnRzLmNhbGN1bGF0ZVV0aWxzID0gcmVxdWlyZShcIi4vYnVpbGQvY2FsY3VsYXRlVXRpbHNcIik7XG5tb2R1bGUuZXhwb3J0cy5SZXNwb25zaXZlID1cbiAgcmVxdWlyZShcIi4vYnVpbGQvUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dFwiKS5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuUmVzcG9uc2l2ZS51dGlscyA9IHJlcXVpcmUoXCIuL2J1aWxkL3Jlc3BvbnNpdmVVdGlsc1wiKTtcbm1vZHVsZS5leHBvcnRzLldpZHRoUHJvdmlkZXIgPVxuICByZXF1aXJlKFwiLi9idWlsZC9jb21wb25lbnRzL1dpZHRoUHJvdmlkZXJcIikuZGVmYXVsdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/css/styles.css":
/*!*******************************************************!*\
  !*** ./node_modules/react-grid-layout/css/styles.css ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"c6cf8de1bab5\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvY3NzL3N0eWxlcy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdG9ja21hc3Rlci1pbXMvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvY3NzL3N0eWxlcy5jc3M/ZjFiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImM2Y2Y4ZGUxYmFiNVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/css/styles.css\n");

/***/ })

};
;